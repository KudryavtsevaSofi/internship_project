{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/grid_core/sticky_columns/utils.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { isDefined } from \"../../../../core/utils/type\";\nimport gridCoreUtils from \"../../../grids/grid_core/m_utils\";\nimport { HIDDEN_COLUMNS_WIDTH } from \"../adaptivity/const\";\nimport { STICKY_BORDER_WIDTH, StickyPosition } from \"./const\";\nexport const getColumnFixedPosition = (that, column) => {\n  const {\n    fixedPosition: fixedPosition\n  } = column;\n  const rtlEnabled = that.option(\"rtlEnabled\");\n  const isExceptionCommandColumn = column.command && \"expand\" === column.command;\n  const isDefaultCommandColumn = column.command && !gridCoreUtils.isCustomCommandColumn(that._columns, column);\n  if (isDefaultCommandColumn && rtlEnabled && !isExceptionCommandColumn) {\n    return fixedPosition === StickyPosition.Right ? StickyPosition.Left : StickyPosition.Right;\n  }\n  return fixedPosition ?? StickyPosition.Left;\n};\nexport const needToDisableStickyColumn = function (that, column) {\n  return that.isVirtualMode() && !!column.fixed && column.fixedPosition === StickyPosition.Sticky;\n};\nexport const processFixedColumns = function (that, columns) {\n  return columns.map(column => {\n    if (needToDisableStickyColumn(that, column)) {\n      return _extends({}, column, {\n        fixed: false,\n        fixedPosition: \"\"\n      });\n    }\n    return column;\n  });\n};\nconst isVisibleColumn = function (that, column) {\n  return column.visibleWidth !== HIDDEN_COLUMNS_WIDTH && (!column.isBand || !!that.getVisibleDataColumnsByBandColumn(column.index).length);\n};\nconst areNextOnlyFixedOrHiddenColumns = function (that, columns) {\n  return !columns.some(column => !column.fixed && isVisibleColumn(that, column));\n};\nconst getStickyOffsetCore = function (that, columns, widths, columnIndex, fixedPosition, offsets) {\n  const column = columns[columnIndex];\n  const isChildColumn = isDefined(column.ownerBand);\n  const targetColumnIsRight = fixedPosition === StickyPosition.Right;\n  const targetColumnIsSticky = column.fixedPosition === StickyPosition.Sticky;\n  const nextOrPrevColumns = targetColumnIsRight ? columns.slice(columnIndex + 1) : columns.slice(0, columnIndex).reverse();\n  const nextOrPrevColumnWidths = targetColumnIsRight ? widths.slice(columnIndex + 1) : widths.slice(0, columnIndex).reverse();\n  let offset = 0;\n  let adjacentStickyColumnIndex = 0;\n  let nonSiblingStickyColumnCount = !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns) && targetColumnIsSticky && nextOrPrevColumns.length ? 1 : 0;\n  nextOrPrevColumns.forEach((col, colIndex) => {\n    if (col.fixed && (!isDefined(offsets) || column.ownerBand === col.ownerBand)) {\n      const columnIsSticky = col.fixedPosition === StickyPosition.Sticky;\n      offset += nextOrPrevColumnWidths[colIndex];\n      if (targetColumnIsSticky && columnIsSticky && !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns.slice(colIndex + 1))) {\n        if (colIndex !== adjacentStickyColumnIndex) {\n          nonSiblingStickyColumnCount += 1;\n          adjacentStickyColumnIndex = colIndex + 1;\n        } else {\n          adjacentStickyColumnIndex += 1;\n        }\n      }\n    } else if (!isVisibleColumn(that, col)) {\n      adjacentStickyColumnIndex += 1;\n    }\n  });\n  if (isChildColumn && isDefined(offsets)) {\n    var _offsets$column$owner;\n    offset += (null === offsets || void 0 === offsets || null === (_offsets$column$owner = offsets[column.ownerBand]) || void 0 === _offsets$column$owner ? void 0 : _offsets$column$owner[fixedPosition]) ?? 0;\n    return offset;\n  }\n  return offset - nonSiblingStickyColumnCount * STICKY_BORDER_WIDTH;\n};\nconst isFirstOrLastColumn = function (that, column, rowIndex) {\n  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\n  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;\n  const rtlEnabled = that.option(\"rtlEnabled\");\n  const methodName = rtlEnabled !== isLast ? \"isLastColumn\" : \"isFirstColumn\";\n  if (column.fixedPosition === StickyPosition.Sticky) {\n    const parentColumn = that.getParentColumn(column) ?? column;\n    if (that[methodName](parentColumn, 0)) {\n      return false;\n    }\n  }\n  return that[methodName](column, rowIndex, onlyWithinBandColumn, fixedPosition);\n};\nconst getPrevColumn = function (that, column, visibleColumns, rowIndex) {\n  const visibleColumnIndex = that.getVisibleIndex(column.index, rowIndex);\n  return null === visibleColumns || void 0 === visibleColumns ? void 0 : visibleColumns.slice(0, visibleColumnIndex).reverse().find(col => isVisibleColumn(that, col));\n};\nexport const getStickyOffset = function (that, columns, widths, columnIndex, offsets) {\n  const result = {};\n  const column = columns[columnIndex];\n  if (column) {\n    const fixedPosition = getColumnFixedPosition(that, column);\n    switch (fixedPosition) {\n      case StickyPosition.Sticky:\n        {\n          const offsetLeft = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Left, offsets);\n          const offsetRight = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Right, offsets);\n          result.left = offsetLeft;\n          result.right = offsetRight;\n          break;\n        }\n      case StickyPosition.Right:\n        {\n          const offsetRight = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Right, offsets);\n          result.right = offsetRight;\n          break;\n        }\n      default:\n        {\n          const offsetLeft = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Left, offsets);\n          result.left = offsetLeft;\n        }\n    }\n  }\n  return result;\n};\nconst needToRemoveColumnBorderCore = function (that, column, visibleColumns, rowIndex) {\n  const prevColumn = getPrevColumn(that, column, visibleColumns, rowIndex);\n  const columnFixedPosition = getColumnFixedPosition(that, column);\n  const prevColumnFixedPosition = prevColumn && getColumnFixedPosition(that, prevColumn);\n  return !!(null !== prevColumn && void 0 !== prevColumn && prevColumn.fixed) && !needToDisableStickyColumn(that, prevColumn) && (!column.fixed || columnFixedPosition === StickyPosition.Sticky || prevColumnFixedPosition === StickyPosition.Sticky);\n};\nexport const needToRemoveColumnBorder = function (that, column, rowIndex) {\n  let isDataColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n  const visibleColumns = that.getVisibleColumns(isDataColumn ? null : rowIndex);\n  const parentColumn = that.getParentColumn(column);\n  if (parentColumn) {\n    const isFirstColumn = that.isFirstColumn(column, rowIndex, true);\n    return isFirstColumn && needToRemoveColumnBorderCore(that, parentColumn, that.getVisibleColumns(0), 0);\n  }\n  return needToRemoveColumnBorderCore(that, column, visibleColumns, rowIndex);\n};\nexport const normalizeOffset = function (offset) {\n  const styleProps = {};\n  if (isDefined(offset.left)) {\n    styleProps.left = `${offset.left}px`;\n  }\n  if (isDefined(offset.right)) {\n    styleProps.right = `${offset.right}px`;\n  }\n  return styleProps;\n};\nexport const isFirstFixedColumn = function (that, column, rowIndex) {\n  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;\n  return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, false, fixedPosition);\n};\nexport const isLastFixedColumn = function (that, column, rowIndex) {\n  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;\n  return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, true, fixedPosition);\n};\nexport const isFixedEdge = function (point, column, nextColumn) {\n  const isSplitPoint = isDefined(point.isLeftBoundary) || isDefined(point.isRightBoundary);\n  return !isSplitPoint && !!column && !!nextColumn && column.fixed !== nextColumn.fixed;\n};","map":{"version":3,"names":["_extends","isDefined","gridCoreUtils","HIDDEN_COLUMNS_WIDTH","STICKY_BORDER_WIDTH","StickyPosition","getColumnFixedPosition","that","column","fixedPosition","rtlEnabled","option","isExceptionCommandColumn","command","isDefaultCommandColumn","isCustomCommandColumn","_columns","Right","Left","needToDisableStickyColumn","isVirtualMode","fixed","Sticky","processFixedColumns","columns","map","isVisibleColumn","visibleWidth","isBand","getVisibleDataColumnsByBandColumn","index","length","areNextOnlyFixedOrHiddenColumns","some","getStickyOffsetCore","widths","columnIndex","offsets","isChildColumn","ownerBand","targetColumnIsRight","targetColumnIsSticky","nextOrPrevColumns","slice","reverse","nextOrPrevColumnWidths","offset","adjacentStickyColumnIndex","nonSiblingStickyColumnCount","forEach","col","colIndex","columnIsSticky","_offsets$column$owner","isFirstOrLastColumn","rowIndex","onlyWithinBandColumn","arguments","isLast","methodName","parentColumn","getParentColumn","getPrevColumn","visibleColumns","visibleColumnIndex","getVisibleIndex","find","getStickyOffset","result","offsetLeft","offsetRight","left","right","needToRemoveColumnBorderCore","prevColumn","columnFixedPosition","prevColumnFixedPosition","needToRemoveColumnBorder","isDataColumn","getVisibleColumns","isFirstColumn","normalizeOffset","styleProps","isFirstFixedColumn","isLastFixedColumn","isFixedEdge","point","nextColumn","isSplitPoint","isLeftBoundary","isRightBoundary"],"sources":["C:/Users/Sofia/Desktop/Репозиторий ЦК/internship_project/client/node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/utils.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/grid_core/sticky_columns/utils.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport {\r\n    isDefined\r\n} from \"../../../../core/utils/type\";\r\nimport gridCoreUtils from \"../../../grids/grid_core/m_utils\";\r\nimport {\r\n    HIDDEN_COLUMNS_WIDTH\r\n} from \"../adaptivity/const\";\r\nimport {\r\n    STICKY_BORDER_WIDTH,\r\n    StickyPosition\r\n} from \"./const\";\r\nexport const getColumnFixedPosition = (that, column) => {\r\n    const {\r\n        fixedPosition: fixedPosition\r\n    } = column;\r\n    const rtlEnabled = that.option(\"rtlEnabled\");\r\n    const isExceptionCommandColumn = column.command && \"expand\" === column.command;\r\n    const isDefaultCommandColumn = column.command && !gridCoreUtils.isCustomCommandColumn(that._columns, column);\r\n    if (isDefaultCommandColumn && rtlEnabled && !isExceptionCommandColumn) {\r\n        return fixedPosition === StickyPosition.Right ? StickyPosition.Left : StickyPosition.Right\r\n    }\r\n    return fixedPosition ?? StickyPosition.Left\r\n};\r\nexport const needToDisableStickyColumn = function(that, column) {\r\n    return that.isVirtualMode() && !!column.fixed && column.fixedPosition === StickyPosition.Sticky\r\n};\r\nexport const processFixedColumns = function(that, columns) {\r\n    return columns.map((column => {\r\n        if (needToDisableStickyColumn(that, column)) {\r\n            return _extends({}, column, {\r\n                fixed: false,\r\n                fixedPosition: \"\"\r\n            })\r\n        }\r\n        return column\r\n    }))\r\n};\r\nconst isVisibleColumn = function(that, column) {\r\n    return column.visibleWidth !== HIDDEN_COLUMNS_WIDTH && (!column.isBand || !!that.getVisibleDataColumnsByBandColumn(column.index).length)\r\n};\r\nconst areNextOnlyFixedOrHiddenColumns = function(that, columns) {\r\n    return !columns.some((column => !column.fixed && isVisibleColumn(that, column)))\r\n};\r\nconst getStickyOffsetCore = function(that, columns, widths, columnIndex, fixedPosition, offsets) {\r\n    const column = columns[columnIndex];\r\n    const isChildColumn = isDefined(column.ownerBand);\r\n    const targetColumnIsRight = fixedPosition === StickyPosition.Right;\r\n    const targetColumnIsSticky = column.fixedPosition === StickyPosition.Sticky;\r\n    const nextOrPrevColumns = targetColumnIsRight ? columns.slice(columnIndex + 1) : columns.slice(0, columnIndex).reverse();\r\n    const nextOrPrevColumnWidths = targetColumnIsRight ? widths.slice(columnIndex + 1) : widths.slice(0, columnIndex).reverse();\r\n    let offset = 0;\r\n    let adjacentStickyColumnIndex = 0;\r\n    let nonSiblingStickyColumnCount = !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns) && targetColumnIsSticky && nextOrPrevColumns.length ? 1 : 0;\r\n    nextOrPrevColumns.forEach(((col, colIndex) => {\r\n        if (col.fixed && (!isDefined(offsets) || column.ownerBand === col.ownerBand)) {\r\n            const columnIsSticky = col.fixedPosition === StickyPosition.Sticky;\r\n            offset += nextOrPrevColumnWidths[colIndex];\r\n            if (targetColumnIsSticky && columnIsSticky && !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns.slice(colIndex + 1))) {\r\n                if (colIndex !== adjacentStickyColumnIndex) {\r\n                    nonSiblingStickyColumnCount += 1;\r\n                    adjacentStickyColumnIndex = colIndex + 1\r\n                } else {\r\n                    adjacentStickyColumnIndex += 1\r\n                }\r\n            }\r\n        } else if (!isVisibleColumn(that, col)) {\r\n            adjacentStickyColumnIndex += 1\r\n        }\r\n    }));\r\n    if (isChildColumn && isDefined(offsets)) {\r\n        var _offsets$column$owner;\r\n        offset += (null === offsets || void 0 === offsets || null === (_offsets$column$owner = offsets[column.ownerBand]) || void 0 === _offsets$column$owner ? void 0 : _offsets$column$owner[fixedPosition]) ?? 0;\r\n        return offset\r\n    }\r\n    return offset - nonSiblingStickyColumnCount * STICKY_BORDER_WIDTH\r\n};\r\nconst isFirstOrLastColumn = function(that, column, rowIndex) {\r\n    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\r\n    let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\r\n    let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;\r\n    const rtlEnabled = that.option(\"rtlEnabled\");\r\n    const methodName = rtlEnabled !== isLast ? \"isLastColumn\" : \"isFirstColumn\";\r\n    if (column.fixedPosition === StickyPosition.Sticky) {\r\n        const parentColumn = that.getParentColumn(column) ?? column;\r\n        if (that[methodName](parentColumn, 0)) {\r\n            return false\r\n        }\r\n    }\r\n    return that[methodName](column, rowIndex, onlyWithinBandColumn, fixedPosition)\r\n};\r\nconst getPrevColumn = function(that, column, visibleColumns, rowIndex) {\r\n    const visibleColumnIndex = that.getVisibleIndex(column.index, rowIndex);\r\n    return null === visibleColumns || void 0 === visibleColumns ? void 0 : visibleColumns.slice(0, visibleColumnIndex).reverse().find((col => isVisibleColumn(that, col)))\r\n};\r\nexport const getStickyOffset = function(that, columns, widths, columnIndex, offsets) {\r\n    const result = {};\r\n    const column = columns[columnIndex];\r\n    if (column) {\r\n        const fixedPosition = getColumnFixedPosition(that, column);\r\n        switch (fixedPosition) {\r\n            case StickyPosition.Sticky: {\r\n                const offsetLeft = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Left, offsets);\r\n                const offsetRight = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Right, offsets);\r\n                result.left = offsetLeft;\r\n                result.right = offsetRight;\r\n                break\r\n            }\r\n            case StickyPosition.Right: {\r\n                const offsetRight = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Right, offsets);\r\n                result.right = offsetRight;\r\n                break\r\n            }\r\n            default: {\r\n                const offsetLeft = getStickyOffsetCore(that, columns, widths, columnIndex, StickyPosition.Left, offsets);\r\n                result.left = offsetLeft\r\n            }\r\n        }\r\n    }\r\n    return result\r\n};\r\nconst needToRemoveColumnBorderCore = function(that, column, visibleColumns, rowIndex) {\r\n    const prevColumn = getPrevColumn(that, column, visibleColumns, rowIndex);\r\n    const columnFixedPosition = getColumnFixedPosition(that, column);\r\n    const prevColumnFixedPosition = prevColumn && getColumnFixedPosition(that, prevColumn);\r\n    return !!(null !== prevColumn && void 0 !== prevColumn && prevColumn.fixed) && !needToDisableStickyColumn(that, prevColumn) && (!column.fixed || columnFixedPosition === StickyPosition.Sticky || prevColumnFixedPosition === StickyPosition.Sticky)\r\n};\r\nexport const needToRemoveColumnBorder = function(that, column, rowIndex) {\r\n    let isDataColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\r\n    const visibleColumns = that.getVisibleColumns(isDataColumn ? null : rowIndex);\r\n    const parentColumn = that.getParentColumn(column);\r\n    if (parentColumn) {\r\n        const isFirstColumn = that.isFirstColumn(column, rowIndex, true);\r\n        return isFirstColumn && needToRemoveColumnBorderCore(that, parentColumn, that.getVisibleColumns(0), 0)\r\n    }\r\n    return needToRemoveColumnBorderCore(that, column, visibleColumns, rowIndex)\r\n};\r\nexport const normalizeOffset = function(offset) {\r\n    const styleProps = {};\r\n    if (isDefined(offset.left)) {\r\n        styleProps.left = `${offset.left}px`\r\n    }\r\n    if (isDefined(offset.right)) {\r\n        styleProps.right = `${offset.right}px`\r\n    }\r\n    return styleProps\r\n};\r\nexport const isFirstFixedColumn = function(that, column, rowIndex) {\r\n    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\r\n    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;\r\n    return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, false, fixedPosition)\r\n};\r\nexport const isLastFixedColumn = function(that, column, rowIndex) {\r\n    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\r\n    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;\r\n    return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, true, fixedPosition)\r\n};\r\nexport const isFixedEdge = function(point, column, nextColumn) {\r\n    const isSplitPoint = isDefined(point.isLeftBoundary) || isDefined(point.isRightBoundary);\r\n    return !isSplitPoint && !!column && !!nextColumn && column.fixed !== nextColumn.fixed\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}