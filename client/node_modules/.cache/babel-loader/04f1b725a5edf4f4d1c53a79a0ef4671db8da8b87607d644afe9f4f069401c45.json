{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/grid_core/columns_controller/m_columns_controller.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateLocalization from \"../../../../common/core/localization/date\";\nimport messageLocalization from \"../../../../common/core/localization/message\";\nimport { DataSource } from \"../../../../common/data/data_source/data_source\";\nimport { normalizeDataSourceOptions } from \"../../../../common/data/data_source/utils\";\nimport config from \"../../../../core/config\";\nimport $ from \"../../../../core/renderer\";\nimport Callbacks from \"../../../../core/utils/callbacks\";\nimport { compileGetter } from \"../../../../core/utils/data\";\nimport { Deferred, when } from \"../../../../core/utils/deferred\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport { each, map } from \"../../../../core/utils/iterator\";\nimport { orderEach } from \"../../../../core/utils/object\";\nimport { isDefined, isFunction, isNumeric, isObject, isPlainObject, isString } from \"../../../../core/utils/type\";\nimport variableWrapper from \"../../../../core/utils/variable_wrapper\";\nimport Store from \"../../../../data/abstract_store\";\nimport filterUtils from \"../../../../ui/shared/filtering\";\nimport errors from \"../../../../ui/widget/ui.errors\";\nimport inflector from \"../../../core/utils/m_inflector\";\nimport modules from \"../m_modules\";\nimport gridCoreUtils from \"../m_utils\";\nimport { StickyPosition } from \"../sticky_columns/const\";\nimport { COLUMN_CHOOSER_LOCATION, COLUMN_OPTION_REGEXP, COMMAND_EXPAND_CLASS, DATATYPE_OPERATIONS, DETAIL_COMMAND_COLUMN_NAME, GROUP_COMMAND_COLUMN_NAME, GROUP_LOCATION, MAX_SAFE_INTEGER, USER_STATE_FIELD_NAMES } from \"./const\";\nimport { addExpandColumn, applyUserState, assignColumns, columnOptionCore, convertOwnerBandToColumnReference, createColumn, createColumnsFromDataSource, createColumnsFromOptions, defaultSetCellValue, digitsCount, findColumn, fireColumnsChanged, getAlignmentByDataType, getChildrenByBandColumn, getColumnByIndexes, getColumnIndexByVisibleIndex, getCustomizeTextByDataType, getDataColumns, getFixedPosition, getParentBandColumns, getRowCount, getSerializationFormat, getValueDataType, isColumnFixed, isFirstOrLastColumn, isSortOrderValid, mergeColumns, moveColumnToGroup, numberToString, processBandColumns, processExpandColumns, resetBandColumnsCache, resetColumnsCache, setFilterOperationsAsDefaultValues, sortColumns, strictParseNumber, updateColumnChanges, updateColumnGroupIndexes, updateIndexes, updateSerializers } from \"./m_columns_controller_utils\";\nexport class ColumnsController extends modules.Controller {\n  init(isApplyingUserState) {\n    this._dataController = this.getController(\"data\");\n    this._focusController = this.getController(\"focus\");\n    this._stateStoringController = this.getController(\"stateStoring\");\n    const columns = this.option(\"columns\");\n    this._commandColumns = this._commandColumns || [];\n    this._columns = this._columns || [];\n    this._isColumnsFromOptions = !!columns;\n    if (this._isColumnsFromOptions) {\n      assignColumns(this, columns ? createColumnsFromOptions(this, columns) : []);\n      applyUserState(this);\n    } else {\n      assignColumns(this, this._columnsUserState ? createColumnsFromOptions(this, this._columnsUserState) : this._columns);\n    }\n    addExpandColumn(this);\n    if (this._dataSourceApplied) {\n      this.applyDataSource(this._dataSource, true, isApplyingUserState);\n    } else {\n      updateIndexes(this);\n    }\n    this._checkColumns();\n  }\n  _getExpandColumnOptions() {\n    return {\n      type: \"expand\",\n      command: \"expand\",\n      width: \"auto\",\n      cssClass: COMMAND_EXPAND_CLASS,\n      allowEditing: false,\n      allowGrouping: false,\n      allowSorting: false,\n      allowResizing: false,\n      allowReordering: false,\n      allowHiding: false\n    };\n  }\n  _getFirstItems(dataSource) {\n    let groupsCount;\n    let items = [];\n    const getFirstItemsCore = function (items, groupsCount) {\n      if (!items || !groupsCount) {\n        return items;\n      }\n      for (let i = 0; i < items.length; i++) {\n        const childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);\n        if (childItems && childItems.length) {\n          return childItems;\n        }\n      }\n    };\n    if (dataSource && dataSource.items().length > 0) {\n      groupsCount = gridCoreUtils.normalizeSortingInfo(dataSource.group()).length;\n      items = getFirstItemsCore(dataSource.items(), groupsCount) || [];\n    }\n    return items;\n  }\n  _endUpdateCore() {\n    !this._skipProcessingColumnsChange && fireColumnsChanged(this);\n  }\n  callbackNames() {\n    return [\"columnsChanged\"];\n  }\n  getColumnByPath(path, columns) {\n    const that = this;\n    let column;\n    const columnIndexes = [];\n    path.replace(COLUMN_OPTION_REGEXP, (_, columnIndex) => {\n      columnIndexes.push(parseInt(columnIndex));\n      return \"\";\n    });\n    if (columnIndexes.length) {\n      if (columns) {\n        column = columnIndexes.reduce((column, index) => column && column.columns && column.columns[index], {\n          columns: columns\n        });\n      } else {\n        column = getColumnByIndexes(that, columnIndexes);\n      }\n    }\n    return column;\n  }\n  optionChanged(args) {\n    let needUpdateRequireResize;\n    switch (args.name) {\n      case \"adaptColumnWidthByRatio\":\n        args.handled = true;\n        break;\n      case \"dataSource\":\n        if (args.value !== args.previousValue && !this.option(\"columns\") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {\n          this._columns = [];\n        }\n        break;\n      case \"columns\":\n        needUpdateRequireResize = this._skipProcessingColumnsChange;\n        args.handled = true;\n        if (!this._skipProcessingColumnsChange) {\n          if (args.name === args.fullName) {\n            this._columnsUserState = null;\n            this._ignoreColumnOptionNames = null;\n            this.init();\n          } else {\n            this._columnOptionChanged(args);\n            needUpdateRequireResize = true;\n          }\n        }\n        if (needUpdateRequireResize) {\n          this._updateRequireResize(args);\n        }\n        break;\n      case \"commonColumnSettings\":\n      case \"columnAutoWidth\":\n      case \"allowColumnResizing\":\n      case \"allowColumnReordering\":\n      case \"columnFixing\":\n      case \"grouping\":\n      case \"groupPanel\":\n      case \"regenerateColumnsByVisibleItems\":\n      case \"customizeColumns\":\n      case \"columnHidingEnabled\":\n      case \"dateSerializationFormat\":\n      case \"columnResizingMode\":\n      case \"columnMinWidth\":\n      case \"columnWidth\":\n        {\n          args.handled = true;\n          const ignoreColumnOptionNames = \"columnWidth\" === args.fullName && [\"width\"];\n          this.reinit(ignoreColumnOptionNames);\n          break;\n        }\n      case \"rtlEnabled\":\n        this.reinit();\n        break;\n      default:\n        super.optionChanged(args);\n    }\n  }\n  _columnOptionChanged(args) {\n    let columnOptionValue = {};\n    const column = this.getColumnByPath(args.fullName);\n    const columnOptionName = args.fullName.replace(COLUMN_OPTION_REGEXP, \"\");\n    if (column) {\n      if (columnOptionName) {\n        columnOptionValue[columnOptionName] = args.value;\n      } else {\n        columnOptionValue = args.value;\n      }\n      this._skipProcessingColumnsChange = args.fullName;\n      this.columnOption(column.index, columnOptionValue);\n      this._skipProcessingColumnsChange = false;\n    }\n  }\n  _updateRequireResize(args) {\n    const {\n      component: component\n    } = this;\n    if (\"width\" === args.fullName.replace(COLUMN_OPTION_REGEXP, \"\") && component._updateLockCount) {\n      component._requireResize = true;\n    }\n  }\n  publicMethods() {\n    return [\"addColumn\", \"deleteColumn\", \"columnOption\", \"columnCount\", \"clearSorting\", \"clearGrouping\", \"getVisibleColumns\", \"getVisibleColumnIndex\", \"getColumns\"];\n  }\n  applyDataSource(dataSource, forceApplying, isApplyingUserState) {\n    const that = this;\n    const isDataSourceLoaded = dataSource && dataSource.isLoaded();\n    that._dataSource = dataSource;\n    if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option(\"regenerateColumnsByVisibleItems\")) {\n      if (isDataSourceLoaded) {\n        if (!that._isColumnsFromOptions) {\n          const columnsFromDataSource = createColumnsFromDataSource(that, dataSource);\n          if (columnsFromDataSource.length) {\n            assignColumns(that, columnsFromDataSource);\n            that._dataSourceColumnsCount = that._columns.length;\n            applyUserState(that);\n          }\n        }\n        return that.updateColumns(dataSource, forceApplying, isApplyingUserState);\n      }\n      that._dataSourceApplied = false;\n      updateIndexes(that);\n    } else if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {\n      updateColumnChanges(that, \"columns\");\n      fireColumnsChanged(that);\n      return new Deferred().reject().promise();\n    }\n  }\n  reset() {\n    this._dataSource = null;\n    this._dataSourceApplied = false;\n    this._dataSourceColumnsCount = void 0;\n    this.reinit();\n  }\n  resetColumnsCache() {\n    this._visibleColumns = void 0;\n    this._fixedColumns = void 0;\n    this._rowCount = void 0;\n    resetBandColumnsCache(this);\n  }\n  reinit(ignoreColumnOptionNames) {\n    this._columnsUserState = this.getUserState();\n    this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;\n    this.init();\n    if (ignoreColumnOptionNames) {\n      this._ignoreColumnOptionNames = null;\n    }\n  }\n  isInitialized() {\n    return !!this._columns.length || !!this.option(\"columns\");\n  }\n  isDataSourceApplied() {\n    return this._dataSourceApplied;\n  }\n  getCommonSettings(column) {\n    const commonColumnSettings = (!column || !column.type) && this.option(\"commonColumnSettings\") || {};\n    const groupingOptions = this.option(\"grouping\") ?? {};\n    const groupPanelOptions = this.option(\"groupPanel\") ?? {};\n    return extend({\n      allowFixing: this.option(\"columnFixing.enabled\"),\n      allowResizing: this.option(\"allowColumnResizing\") || void 0,\n      allowReordering: this.option(\"allowColumnReordering\"),\n      minWidth: this.option(\"columnMinWidth\"),\n      width: this.option(\"columnWidth\"),\n      autoExpandGroup: groupingOptions.autoExpandAll,\n      allowCollapsing: groupingOptions.allowCollapsing,\n      allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled\n    }, commonColumnSettings);\n  }\n  isColumnOptionUsed(optionName) {\n    for (let i = 0; i < this._columns.length; i++) {\n      if (this._columns[i][optionName]) {\n        return true;\n      }\n    }\n  }\n  isAllDataTypesDefined(checkSerializers) {\n    const columns = this._columns;\n    if (!columns.length) {\n      return false;\n    }\n    for (let i = 0; i < columns.length; i++) {\n      if (!columns[i].dataField && columns[i].calculateCellValue === columns[i].defaultCalculateCellValue) {\n        continue;\n      }\n      if (!columns[i].dataType || checkSerializers && columns[i].deserializeValue && void 0 === columns[i].serializationFormat) {\n        return false;\n      }\n    }\n    return true;\n  }\n  getColumns() {\n    return this._columns;\n  }\n  isBandColumnsUsed() {\n    return this.getColumns().some(column => column.isBand);\n  }\n  getGroupColumns() {\n    const result = [];\n    each(this._columns, function () {\n      const column = this;\n      if (isDefined(column.groupIndex)) {\n        result[column.groupIndex] = column;\n      }\n    });\n    return result;\n  }\n  _shouldReturnVisibleColumns() {\n    return true;\n  }\n  _compileVisibleColumns(rowIndex) {\n    this._visibleColumns = this._visibleColumns || this._compileVisibleColumnsCore();\n    rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;\n    return this._visibleColumns[rowIndex] || [];\n  }\n  getVisibleColumns(rowIndex, isBase) {\n    if (!this._shouldReturnVisibleColumns()) {\n      return [];\n    }\n    return this._compileVisibleColumns.apply(this, arguments);\n  }\n  getFixedColumns(rowIndex) {\n    this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();\n    rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;\n    return this._fixedColumns[rowIndex] || [];\n  }\n  getFilteringColumns() {\n    return this.getColumns().filter(item => (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering)).map(item => {\n      const field = extend(true, {}, item);\n      if (!isDefined(field.dataField)) {\n        field.dataField = field.name;\n      }\n      field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;\n      return field;\n    });\n  }\n  getColumnIndexOffset() {\n    return 0;\n  }\n  getStickyColumns(rowIndex) {\n    const visibleColumns = this.getVisibleColumns(rowIndex, true);\n    return visibleColumns.filter(column => column.fixed);\n  }\n  _getFixedColumnsCore() {\n    const that = this;\n    const result = [];\n    const rowCount = that.getRowCount();\n    const isColumnFixing = that._isColumnFixing();\n    const transparentColumn = {\n      command: \"transparent\"\n    };\n    let transparentColspan = 0;\n    let notFixedColumnCount;\n    let transparentColumnIndex;\n    let lastFixedPosition;\n    if (isColumnFixing) {\n      for (let i = 0; i <= rowCount; i++) {\n        notFixedColumnCount = 0;\n        lastFixedPosition = null;\n        transparentColumnIndex = null;\n        const visibleColumns = that.getVisibleColumns(i, true);\n        for (let j = 0; j < visibleColumns.length; j++) {\n          const prevColumn = visibleColumns[j - 1];\n          const column = visibleColumns[j];\n          if (!column.fixed || column.fixedPosition === StickyPosition.Sticky) {\n            if (0 === i) {\n              if (column.isBand && column.colspan) {\n                transparentColspan += column.colspan;\n              } else {\n                transparentColspan++;\n              }\n            }\n            notFixedColumnCount++;\n            if (!isDefined(transparentColumnIndex)) {\n              transparentColumnIndex = j;\n            }\n          } else if (prevColumn && prevColumn.fixed && getFixedPosition(that, prevColumn) !== getFixedPosition(that, column)) {\n            if (!isDefined(transparentColumnIndex)) {\n              transparentColumnIndex = j;\n            }\n          } else {\n            lastFixedPosition = column.fixedPosition;\n          }\n        }\n        if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {\n          return [];\n        }\n        if (!isDefined(transparentColumnIndex)) {\n          transparentColumnIndex = \"right\" === lastFixedPosition ? 0 : visibleColumns.length;\n        }\n        result[i] = visibleColumns.slice(0);\n        if (!transparentColumn.colspan) {\n          transparentColumn.colspan = transparentColspan;\n        }\n        result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn);\n      }\n    }\n    return result.map(columns => columns.map(column => {\n      const newColumn = _extends({}, column);\n      if (newColumn.headerId) {\n        newColumn.headerId += \"-fixed\";\n      }\n      return newColumn;\n    }));\n  }\n  _isColumnFixing() {\n    let isColumnFixing = this.option(\"columnFixing.enabled\");\n    !isColumnFixing && each(this._columns, (_, column) => {\n      if (column.fixed) {\n        isColumnFixing = true;\n        return false;\n      }\n    });\n    return isColumnFixing;\n  }\n  _getExpandColumnsCore() {\n    return this.getGroupColumns();\n  }\n  getExpandColumns() {\n    let expandColumns = this._getExpandColumnsCore();\n    let expandColumn;\n    const firstGroupColumn = expandColumns.filter(column => 0 === column.groupIndex)[0];\n    const isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;\n    const isColumnFixing = this._isColumnFixing();\n    const rtlEnabled = this.option(\"rtlEnabled\");\n    if (expandColumns.length) {\n      expandColumn = this.columnOption(\"command:expand\");\n    }\n    expandColumns = map(expandColumns, column => extend({}, column, {\n      visibleWidth: null,\n      minWidth: null,\n      cellTemplate: !isDefined(column.groupIndex) ? column.cellTemplate : null,\n      headerCellTemplate: null,\n      fixed: !isDefined(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true,\n      fixedPosition: rtlEnabled ? \"right\" : \"left\"\n    }, expandColumn, {\n      index: column.index,\n      type: column.type || GROUP_COMMAND_COLUMN_NAME\n    }));\n    return expandColumns;\n  }\n  getBandColumnsCache() {\n    if (!this._bandColumnsCache) {\n      const columns = this._columns;\n      const columnChildrenByIndex = {};\n      const columnParentByIndex = {};\n      let isPlain = true;\n      columns.forEach(column => {\n        const {\n          ownerBand: ownerBand\n        } = column;\n        let parentIndex = isObject(ownerBand) ? ownerBand.index : ownerBand;\n        const parent = columns[parentIndex];\n        if (column.hasColumns) {\n          isPlain = false;\n        }\n        if (column.colspan) {\n          column.colspan = void 0;\n        }\n        if (column.rowspan) {\n          column.rowspan = void 0;\n        }\n        if (parent) {\n          columnParentByIndex[column.index] = parent;\n        } else {\n          parentIndex = -1;\n        }\n        columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];\n        columnChildrenByIndex[parentIndex].push(column);\n      });\n      this._bandColumnsCache = {\n        isPlain: isPlain,\n        columnChildrenByIndex: columnChildrenByIndex,\n        columnParentByIndex: columnParentByIndex\n      };\n    }\n    return this._bandColumnsCache;\n  }\n  _isColumnVisible(column) {\n    return column.visible && this.isParentColumnVisible(column.index);\n  }\n  _isColumnInGroupPanel(column) {\n    return isDefined(column.groupIndex) && !column.showWhenGrouped;\n  }\n  hasVisibleDataColumns() {\n    const columns = this._columns;\n    return columns.some(column => {\n      const isVisible = this._isColumnVisible(column);\n      const isInGroupPanel = this._isColumnInGroupPanel(column);\n      const isCommand = !!column.command;\n      return isVisible && !isInGroupPanel && !isCommand;\n    });\n  }\n  _compileVisibleColumnsCore() {\n    const bandColumnsCache = this.getBandColumnsCache();\n    const columns = mergeColumns(this, this._columns, this._commandColumns, true);\n    processBandColumns(this, columns, bandColumnsCache);\n    const indexedColumns = this._getIndexedColumns(columns);\n    const visibleColumns = this._getVisibleColumnsFromIndexed(indexedColumns);\n    const isDataColumnsInvisible = !this.hasVisibleDataColumns();\n    if (isDataColumnsInvisible && this._columns.length) {\n      visibleColumns[visibleColumns.length - 1].push({\n        command: \"empty\"\n      });\n    }\n    return visibleColumns;\n  }\n  _getIndexedColumns(columns) {\n    const rtlEnabled = this.option(\"rtlEnabled\");\n    const rowCount = this.getRowCount();\n    const columnDigitsCount = digitsCount(columns.length);\n    const bandColumnsCache = this.getBandColumnsCache();\n    const positiveIndexedColumns = [];\n    const negativeIndexedColumns = [];\n    for (let i = 0; i < rowCount; i += 1) {\n      negativeIndexedColumns[i] = [{}];\n      positiveIndexedColumns[i] = [{}, {}, {}];\n    }\n    columns.forEach(column => {\n      let {\n        visibleIndex: visibleIndex\n      } = column;\n      let indexedColumns;\n      const parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);\n      const isVisible = this._isColumnVisible(column);\n      const isInGroupPanel = this._isColumnInGroupPanel(column);\n      if (isVisible && !isInGroupPanel) {\n        const rowIndex = parentBandColumns.length;\n        if (visibleIndex < 0) {\n          visibleIndex = -visibleIndex;\n          indexedColumns = negativeIndexedColumns[rowIndex];\n        } else {\n          var _parentBandColumns$, _parentBandColumns$2;\n          column.fixed = (null === (_parentBandColumns$ = parentBandColumns[0]) || void 0 === _parentBandColumns$ ? void 0 : _parentBandColumns$.fixed) ?? column.fixed;\n          column.fixedPosition = (null === (_parentBandColumns$2 = parentBandColumns[0]) || void 0 === _parentBandColumns$2 ? void 0 : _parentBandColumns$2.fixedPosition) ?? column.fixedPosition;\n          if (column.fixed && column.fixedPosition !== StickyPosition.Sticky) {\n            const isDefaultCommandColumn = !!column.command && !gridCoreUtils.isCustomCommandColumn(this._columns, column);\n            let isFixedToEnd = \"right\" === column.fixedPosition;\n            if (rtlEnabled && !isDefaultCommandColumn) {\n              isFixedToEnd = !isFixedToEnd;\n            }\n            indexedColumns = isFixedToEnd ? positiveIndexedColumns[rowIndex][2] : positiveIndexedColumns[rowIndex][0];\n          } else {\n            indexedColumns = positiveIndexedColumns[rowIndex][1];\n          }\n        }\n        if (parentBandColumns.length) {\n          visibleIndex = numberToString(visibleIndex, columnDigitsCount);\n          for (let i = parentBandColumns.length - 1; i >= 0; i -= 1) {\n            visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex;\n          }\n        }\n        indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];\n        indexedColumns[visibleIndex].push(column);\n      }\n    });\n    return {\n      positiveIndexedColumns: positiveIndexedColumns,\n      negativeIndexedColumns: negativeIndexedColumns\n    };\n  }\n  _getVisibleColumnsFromIndexed(_ref) {\n    let {\n      positiveIndexedColumns: positiveIndexedColumns,\n      negativeIndexedColumns: negativeIndexedColumns\n    } = _ref;\n    const result = [];\n    const rowCount = this.getRowCount();\n    const expandColumns = mergeColumns(this, this.getExpandColumns(), this._columns);\n    let rowspanGroupColumns = 0;\n    let rowspanExpandColumns = 0;\n    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\n      result.push([]);\n      orderEach(negativeIndexedColumns[rowIndex], (_, columns) => {\n        result[rowIndex].unshift.apply(result[rowIndex], columns);\n      });\n      const firstPositiveIndexColumn = result[rowIndex].length;\n      const positiveIndexedRowColumns = positiveIndexedColumns[rowIndex];\n      positiveIndexedRowColumns.forEach(columnsByFixing => {\n        orderEach(columnsByFixing, (_, columnsByVisibleIndex) => {\n          result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex);\n        });\n      });\n      if (rowspanExpandColumns <= rowIndex) {\n        rowspanExpandColumns += processExpandColumns.call(this, result[rowIndex], expandColumns, DETAIL_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);\n      }\n      if (rowspanGroupColumns <= rowIndex) {\n        rowspanGroupColumns += processExpandColumns.call(this, result[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);\n      }\n    }\n    result.push(getDataColumns(result));\n    return result;\n  }\n  getInvisibleColumns(columns, bandColumnIndex) {\n    const that = this;\n    let result = [];\n    let hiddenColumnsByBand;\n    columns = columns || that._columns;\n    each(columns, (_, column) => {\n      if (column.ownerBand !== bandColumnIndex) {\n        return;\n      }\n      if (column.isBand) {\n        if (!column.visible) {\n          hiddenColumnsByBand = that.getChildrenByBandColumn(column.index);\n        } else {\n          hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index);\n        }\n        if (hiddenColumnsByBand.length) {\n          result.push(column);\n          result = result.concat(hiddenColumnsByBand);\n        }\n        return;\n      }\n      if (!column.visible) {\n        result.push(column);\n      }\n    });\n    return result;\n  }\n  getChooserColumns(getAllColumns) {\n    const columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();\n    const columnChooserColumns = columns.filter(column => column.showInColumnChooser);\n    const sortOrder = this.option(\"columnChooser.sortOrder\");\n    return sortColumns(columnChooserColumns, sortOrder);\n  }\n  allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\n    const columnIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);\n    const sourceColumn = this._columns[columnIndex];\n    if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {\n      if (sourceLocation === targetLocation) {\n        if (sourceLocation === COLUMN_CHOOSER_LOCATION) {\n          return false;\n        }\n        fromVisibleIndex = isObject(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;\n        toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\n        return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex;\n      }\n      if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {\n        return sourceColumn && sourceColumn.allowGrouping;\n      }\n      if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {\n        return sourceColumn && sourceColumn.allowHiding;\n      }\n      return true;\n    }\n    return false;\n  }\n  moveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\n    const that = this;\n    const options = {};\n    let prevGroupIndex;\n    const fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);\n    const toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);\n    let targetGroupIndex;\n    if (fromIndex >= 0) {\n      const column = that._columns[fromIndex];\n      toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\n      targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;\n      if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {\n        if (targetGroupIndex > column.groupIndex) {\n          targetGroupIndex--;\n        }\n        if (targetLocation !== GROUP_LOCATION) {\n          options.groupIndex = void 0;\n        } else {\n          prevGroupIndex = column.groupIndex;\n          delete column.groupIndex;\n          updateColumnGroupIndexes(that);\n        }\n      }\n      if (targetLocation === GROUP_LOCATION) {\n        options.groupIndex = moveColumnToGroup(that, column, targetGroupIndex);\n        column.groupIndex = prevGroupIndex;\n      } else if (toVisibleIndex >= 0) {\n        const targetColumn = that._columns[toIndex];\n        if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {\n          options.visibleIndex = MAX_SAFE_INTEGER;\n        } else if (isColumnFixed(that, column) ^ isColumnFixed(that, targetColumn)) {\n          options.visibleIndex = MAX_SAFE_INTEGER;\n        } else {\n          options.visibleIndex = targetColumn.visibleIndex;\n        }\n      }\n      const isVisible = targetLocation !== COLUMN_CHOOSER_LOCATION;\n      if (column.visible !== isVisible) {\n        options.visible = isVisible;\n      }\n      that.columnOption(column.index, options);\n    }\n  }\n  changeSortOrder(columnIndex, sortOrder) {\n    const that = this;\n    const options = {};\n    const sortingOptions = that.option(\"sorting\");\n    const sortingMode = sortingOptions && sortingOptions.mode;\n    const needResetSorting = \"single\" === sortingMode || !sortOrder;\n    const allowSorting = \"single\" === sortingMode || \"multiple\" === sortingMode;\n    const column = that._columns[columnIndex];\n    if (allowSorting && column && column.allowSorting) {\n      if (needResetSorting && !isDefined(column.groupIndex)) {\n        each(that._columns, function (index) {\n          if (index !== columnIndex && this.sortOrder) {\n            if (!isDefined(this.groupIndex)) {\n              delete this.sortOrder;\n            }\n            delete this.sortIndex;\n          }\n        });\n      }\n      if (isSortOrderValid(sortOrder)) {\n        if (column.sortOrder !== sortOrder) {\n          options.sortOrder = sortOrder;\n        }\n      } else if (\"none\" === sortOrder) {\n        if (column.sortOrder) {\n          options.sortIndex = void 0;\n          options.sortOrder = void 0;\n        }\n      } else {\n        !function (column) {\n          if (\"ctrl\" === sortOrder) {\n            if (!(\"sortOrder\" in column && \"sortIndex\" in column)) {\n              return false;\n            }\n            options.sortOrder = void 0;\n            options.sortIndex = void 0;\n          } else if (isDefined(column.groupIndex) || isDefined(column.sortIndex)) {\n            options.sortOrder = \"desc\" === column.sortOrder ? \"asc\" : \"desc\";\n          } else {\n            options.sortOrder = \"asc\";\n          }\n          return true;\n        }(column);\n      }\n    }\n    that.columnOption(column.index, options);\n  }\n  getSortDataSourceParameters(useLocalSelector) {\n    const sortColumns = [];\n    const sort = [];\n    each(this._columns, function () {\n      if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {\n        sortColumns[this.sortIndex] = this;\n      }\n    });\n    each(sortColumns, function () {\n      const sortOrder = this && this.sortOrder;\n      if (isSortOrderValid(sortOrder)) {\n        const sortItem = {\n          selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,\n          desc: \"desc\" === this.sortOrder\n        };\n        if (this.sortingMethod) {\n          sortItem.compare = this.sortingMethod.bind(this);\n        }\n        sort.push(sortItem);\n      }\n    });\n    return sort.length > 0 ? sort : null;\n  }\n  getGroupDataSourceParameters(useLocalSelector) {\n    const group = [];\n    each(this.getGroupColumns(), function () {\n      const selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;\n      if (selector) {\n        const groupItem = {\n          selector: selector,\n          desc: \"desc\" === this.sortOrder,\n          isExpanded: !!this.autoExpandGroup\n        };\n        if (this.sortingMethod) {\n          groupItem.compare = this.sortingMethod.bind(this);\n        }\n        group.push(groupItem);\n      }\n    });\n    return group.length > 0 ? group : null;\n  }\n  refresh(updateNewLookupsOnly) {\n    const deferreds = [];\n    each(this._columns, function () {\n      const {\n        lookup: lookup\n      } = this;\n      if (lookup && !this.calculateDisplayValue) {\n        if (updateNewLookupsOnly && lookup.valueMap) {\n          return;\n        }\n        if (lookup.update) {\n          deferreds.push(lookup.update());\n        }\n      }\n    });\n    return when.apply($, deferreds).done(resetColumnsCache.bind(null, this));\n  }\n  _updateColumnOptions(column, columnIndex) {\n    var _this$_previousColumn, _this$_previousColumn2;\n    const shouldTakeOriginalCallbackFromPrevious = this._reinitAfterLookupChanges && (null === (_this$_previousColumn = this._previousColumns) || void 0 === _this$_previousColumn ? void 0 : _this$_previousColumn[columnIndex]);\n    column.selector = column.selector ?? (data => column.calculateCellValue(data));\n    column.selector.columnIndex = columnIndex;\n    column.selector.originalCallback = shouldTakeOriginalCallbackFromPrevious ? (null === (_this$_previousColumn2 = this._previousColumns[columnIndex].selector) || void 0 === _this$_previousColumn2 ? void 0 : _this$_previousColumn2.originalCallback) ?? column.selector : column.selector;\n    each([\"calculateSortValue\", \"calculateGroupValue\", \"calculateDisplayValue\"], (_, calculateCallbackName) => {\n      const calculateCallback = column[calculateCallbackName];\n      if (isFunction(calculateCallback)) {\n        if (!calculateCallback.originalCallback) {\n          const context = {\n            column: column\n          };\n          column[calculateCallbackName] = function (data) {\n            return calculateCallback.call(context.column, data);\n          };\n          column[calculateCallbackName].originalCallback = calculateCallback;\n          column[calculateCallbackName].columnIndex = columnIndex;\n          column[calculateCallbackName].context = context;\n        } else {\n          column[calculateCallbackName].context.column = column;\n        }\n      }\n    });\n    if (isString(column.calculateDisplayValue)) {\n      column.displayField = column.calculateDisplayValue;\n      column.calculateDisplayValue = compileGetter(column.displayField);\n    }\n    if (column.calculateDisplayValue) {\n      column.displayValueMap = column.displayValueMap || {};\n    }\n    updateSerializers(column, column.dataType);\n    const {\n      lookup: lookup\n    } = column;\n    if (lookup) {\n      updateSerializers(lookup, lookup.dataType);\n    }\n    const dataType = lookup ? lookup.dataType : column.dataType;\n    if (dataType) {\n      column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option(\"rtlEnabled\"));\n      column.format = column.format || gridCoreUtils.getFormatByDataType(dataType);\n      column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);\n      column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];\n      if (!isDefined(column.filterOperations)) {\n        setFilterOperationsAsDefaultValues(column);\n      }\n      column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || \"=\";\n      column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : \"boolean\" === dataType && !column.cellTemplate && !column.lookup;\n    }\n  }\n  updateColumnDataTypes(dataSource) {\n    const that = this;\n    const dateSerializationFormat = that.option(\"dateSerializationFormat\");\n    const firstItems = that._getFirstItems(dataSource);\n    let isColumnDataTypesUpdated = false;\n    each(that._columns, (index, column) => {\n      let i;\n      let value;\n      let dataType;\n      let lookupDataType;\n      let valueDataType;\n      const {\n        lookup: lookup\n      } = column;\n      if (gridCoreUtils.isDateType(column.dataType) && void 0 === column.serializationFormat) {\n        column.serializationFormat = dateSerializationFormat;\n      }\n      if (lookup && gridCoreUtils.isDateType(lookup.dataType) && void 0 === column.serializationFormat) {\n        lookup.serializationFormat = dateSerializationFormat;\n      }\n      if (column.calculateCellValue && firstItems.length) {\n        if (!column.dataType || lookup && !lookup.dataType) {\n          for (i = 0; i < firstItems.length; i++) {\n            value = column.calculateCellValue(firstItems[i]);\n            if (!column.dataType) {\n              valueDataType = getValueDataType(value);\n              dataType = dataType || valueDataType;\n              if (dataType && valueDataType && dataType !== valueDataType) {\n                dataType = \"string\";\n              }\n            }\n            if (lookup && !lookup.dataType) {\n              valueDataType = getValueDataType(gridCoreUtils.getDisplayValue(column, value, firstItems[i]));\n              lookupDataType = lookupDataType || valueDataType;\n              if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {\n                lookupDataType = \"string\";\n              }\n            }\n          }\n          if (dataType || lookupDataType) {\n            if (dataType) {\n              column.dataType = dataType;\n            }\n            if (lookup && lookupDataType) {\n              lookup.dataType = lookupDataType;\n            }\n            isColumnDataTypesUpdated = true;\n          }\n        }\n        if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {\n          for (i = 0; i < firstItems.length; i++) {\n            value = column.calculateCellValue(firstItems[i], true);\n            if (void 0 === column.serializationFormat) {\n              column.serializationFormat = getSerializationFormat(column.dataType, value);\n            }\n            if (lookup && void 0 === lookup.serializationFormat) {\n              lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true));\n            }\n          }\n        }\n      }\n      that._updateColumnOptions(column, index);\n    });\n    return isColumnDataTypesUpdated;\n  }\n  _customizeColumns(columns) {\n    const that = this;\n    const customizeColumns = that.option(\"customizeColumns\");\n    if (customizeColumns) {\n      const hasOwnerBand = columns.some(column => isObject(column.ownerBand));\n      if (hasOwnerBand) {\n        updateIndexes(that);\n      }\n      customizeColumns(columns);\n      assignColumns(that, createColumnsFromOptions(that, columns));\n    }\n  }\n  updateColumns(dataSource, forceApplying, isApplyingUserState) {\n    if (!forceApplying) {\n      this.updateSortingGrouping(dataSource);\n    }\n    if (!dataSource || dataSource.isLoaded()) {\n      const sortParameters = dataSource ? dataSource.sort() || [] : this.getSortDataSourceParameters();\n      const groupParameters = dataSource ? dataSource.group() || [] : this.getGroupDataSourceParameters();\n      const filterParameters = null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().filter;\n      if (!isApplyingUserState) {\n        this._customizeColumns(this._columns);\n      }\n      updateIndexes(this);\n      const columns = this._columns;\n      return when(this.refresh(true)).always(() => {\n        if (this._columns !== columns) {\n          return;\n        }\n        this._updateChanges(dataSource, {\n          sorting: sortParameters,\n          grouping: groupParameters,\n          filtering: filterParameters\n        });\n        fireColumnsChanged(this);\n      });\n    }\n  }\n  _updateChanges(dataSource, parameters) {\n    var _dataSource$loadOptio;\n    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;\n    if (dataSource) {\n      this.updateColumnDataTypes(dataSource);\n      this._dataSourceApplied = true;\n    }\n    if (!gridCoreUtils.equalSortParameters(parameters.sorting, this.getSortDataSourceParameters())) {\n      updateColumnChanges(this, \"sorting\");\n    }\n    if (!gridCoreUtils.equalSortParameters(parameters.grouping, this.getGroupDataSourceParameters())) {\n      updateColumnChanges(this, \"grouping\");\n    }\n    if (this._dataController && !gridCoreUtils.equalFilterParameters(parameters.filtering, this._dataController.getCombinedFilter(), langParams)) {\n      updateColumnChanges(this, \"filtering\");\n    }\n    updateColumnChanges(this, \"columns\");\n  }\n  updateSortingGrouping(dataSource, fromDataSource) {\n    const that = this;\n    let isColumnsChanged;\n    const updateSortGroupParameterIndexes = function (columns, sortParameters, indexParameterName) {\n      each(columns, (index, column) => {\n        delete column[indexParameterName];\n        if (sortParameters) {\n          for (let i = 0; i < sortParameters.length; i++) {\n            const {\n              selector: selector\n            } = sortParameters[i];\n            const {\n              isExpanded: isExpanded\n            } = sortParameters[i];\n            if (selector === column.dataField || selector === column.name || selector === column.displayField || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue || selector === column.calculateDisplayValue) {\n              if (fromDataSource) {\n                column.sortOrder = \"sortOrder\" in column ? column.sortOrder : sortParameters[i].desc ? \"desc\" : \"asc\";\n              } else {\n                column.sortOrder = column.sortOrder || (sortParameters[i].desc ? \"desc\" : \"asc\");\n              }\n              if (void 0 !== isExpanded) {\n                column.autoExpandGroup = isExpanded;\n              }\n              column[indexParameterName] = i;\n              break;\n            }\n          }\n        }\n      });\n    };\n    if (dataSource) {\n      var _this$_columnChanges;\n      const sortParameters = gridCoreUtils.normalizeSortingInfo(dataSource.sort());\n      const groupParameters = gridCoreUtils.normalizeSortingInfo(dataSource.group());\n      const columnsGroupParameters = that.getGroupDataSourceParameters();\n      const columnsSortParameters = that.getSortDataSourceParameters();\n      const changeTypes = null === (_this$_columnChanges = this._columnChanges) || void 0 === _this$_columnChanges ? void 0 : _this$_columnChanges.changeTypes;\n      const sortingChanged = !gridCoreUtils.equalSortParameters(sortParameters, columnsSortParameters);\n      const needToApplySortingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.sorting);\n      const needToApplyGroupingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.grouping);\n      const groupingChanged = !gridCoreUtils.equalSortParameters(groupParameters, columnsGroupParameters, true);\n      const groupExpandingChanged = !groupingChanged && !gridCoreUtils.equalSortParameters(groupParameters, columnsGroupParameters);\n      if (!that._columns.length) {\n        each(groupParameters, (index, group) => {\n          that._columns.push(group.selector);\n        });\n        each(sortParameters, (index, sort) => {\n          if (!isFunction(sort.selector)) {\n            that._columns.push(sort.selector);\n          }\n        });\n        assignColumns(that, createColumnsFromOptions(that, that._columns));\n      }\n      if ((needToApplyGroupingFromDataSource || !columnsGroupParameters && !that._hasUserState) && (groupingChanged || groupExpandingChanged)) {\n        updateSortGroupParameterIndexes(that._columns, groupParameters, \"groupIndex\");\n        if (fromDataSource) {\n          groupingChanged && updateColumnChanges(that, \"grouping\");\n          groupExpandingChanged && updateColumnChanges(that, \"groupExpanding\");\n          isColumnsChanged = true;\n        }\n      }\n      if ((needToApplySortingFromDataSource || !columnsSortParameters && !that._hasUserState) && sortingChanged) {\n        updateSortGroupParameterIndexes(that._columns, sortParameters, \"sortIndex\");\n        if (fromDataSource) {\n          updateColumnChanges(that, \"sorting\");\n          isColumnsChanged = true;\n        }\n      }\n      if (isColumnsChanged) {\n        fireColumnsChanged(that);\n      }\n    }\n  }\n  updateFilter(filter, remoteFiltering, columnIndex, filterValue) {\n    const that = this;\n    if (!Array.isArray(filter)) {\n      return filter;\n    }\n    filter = extend([], filter);\n    columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;\n    filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;\n    if (isString(filter[0]) && \"!\" !== filter[0]) {\n      const column = that.columnOption(filter[0]);\n      if (remoteFiltering) {\n        if (config().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {\n          filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], \"filter\");\n        }\n      } else if (column && column.selector) {\n        filter[0] = column.selector;\n        filter[0].columnIndex = column.index;\n      }\n    } else if (isFunction(filter[0])) {\n      filter[0].columnIndex = columnIndex;\n      filter[0].filterValue = filterValue;\n      filter[0].selectedFilterOperation = filter.selectedFilterOperation;\n    }\n    for (let i = 0; i < filter.length; i++) {\n      filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue);\n    }\n    return filter;\n  }\n  columnCount() {\n    return this._columns ? this._columns.length : 0;\n  }\n  columnOption(identifier, option, value, notFireEvent) {\n    const that = this;\n    const columns = that._columns.concat(that._commandColumns);\n    const column = findColumn(columns, identifier);\n    if (column) {\n      if (1 === arguments.length) {\n        return extend({}, column);\n      }\n      if (isString(option)) {\n        if (2 === arguments.length) {\n          return columnOptionCore(that, column, option);\n        }\n        columnOptionCore(that, column, option, value, notFireEvent);\n      } else if (isObject(option)) {\n        each(option, (optionName, value) => {\n          columnOptionCore(that, column, optionName, value, notFireEvent);\n        });\n      }\n      fireColumnsChanged(that);\n    }\n  }\n  clearSorting() {\n    const that = this;\n    const columnCount = this.columnCount();\n    that.beginUpdate();\n    for (let i = 0; i < columnCount; i++) {\n      that.columnOption(i, \"sortOrder\", void 0);\n      delete findColumn(that._columns, i).sortOrder;\n    }\n    that.endUpdate();\n  }\n  clearGrouping() {\n    const that = this;\n    const columnCount = this.columnCount();\n    that.beginUpdate();\n    for (let i = 0; i < columnCount; i++) {\n      that.columnOption(i, \"groupIndex\", void 0);\n    }\n    that.endUpdate();\n  }\n  getVisibleIndex(index, rowIndex) {\n    const columns = this.getVisibleColumns(rowIndex);\n    for (let i = columns.length - 1; i >= 0; i--) {\n      if (columns[i].index === index) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  getVisibleIndexByColumn(column, rowIndex) {\n    const visibleColumns = this.getVisibleColumns(rowIndex);\n    const visibleColumn = visibleColumns.filter(col => col.index === column.index && col.command === column.command)[0];\n    return visibleColumns.indexOf(visibleColumn);\n  }\n  getVisibleColumnIndex(id, rowIndex) {\n    const index = this.columnOption(id, \"index\");\n    return this.getVisibleIndex(index, rowIndex);\n  }\n  addColumn(options) {\n    const that = this;\n    let column = createColumn(that, options);\n    const index = that._columns.length;\n    that._columns.push(column);\n    if (column.isBand) {\n      that._columns = createColumnsFromOptions(that, that._columns);\n      column = that._columns[index];\n    }\n    column.added = options;\n    updateIndexes(that, column);\n    that.updateColumns(that._dataSource);\n    that._checkColumns();\n  }\n  deleteColumn(id) {\n    const that = this;\n    const column = that.columnOption(id);\n    if (column && column.index >= 0) {\n      convertOwnerBandToColumnReference(that._columns);\n      that._columns.splice(column.index, 1);\n      if (column.isBand) {\n        const childIndexes = that.getChildrenByBandColumn(column.index).map(column => column.index);\n        that._columns = that._columns.filter(column => childIndexes.indexOf(column.index) < 0);\n      }\n      updateIndexes(that);\n      that.updateColumns(that._dataSource);\n    }\n  }\n  addCommandColumn(options) {\n    let commandColumn = this._commandColumns.filter(column => column.command === options.command)[0];\n    if (!commandColumn) {\n      commandColumn = options;\n      this._commandColumns.push(commandColumn);\n    }\n  }\n  getUserState() {\n    const columns = this._columns;\n    const result = [];\n    let i;\n    function handleStateField(index, value) {\n      if (void 0 !== columns[i][value]) {\n        result[i][value] = columns[i][value];\n      }\n    }\n    for (i = 0; i < columns.length; i++) {\n      result[i] = {};\n      each(USER_STATE_FIELD_NAMES, handleStateField);\n    }\n    return result;\n  }\n  setName(column) {\n    column.name = column.name || column.dataField || column.type;\n  }\n  setUserState(state) {\n    const that = this;\n    const dataSource = that._dataSource;\n    let ignoreColumnOptionNames = that.option(\"stateStoring.ignoreColumnOptionNames\");\n    null === state || void 0 === state || state.forEach(this.setName);\n    if (!ignoreColumnOptionNames) {\n      ignoreColumnOptionNames = [];\n      const commonColumnSettings = that.getCommonSettings();\n      if (!that.option(\"columnChooser.enabled\")) {\n        ignoreColumnOptionNames.push(\"visible\");\n      }\n      if (\"none\" === that.option(\"sorting.mode\")) {\n        ignoreColumnOptionNames.push(\"sortIndex\", \"sortOrder\");\n      }\n      if (!commonColumnSettings.allowGrouping) {\n        ignoreColumnOptionNames.push(\"groupIndex\");\n      }\n      if (!commonColumnSettings.allowFixing) {\n        ignoreColumnOptionNames.push(\"fixed\", \"fixedPosition\");\n      }\n      if (!commonColumnSettings.allowResizing) {\n        ignoreColumnOptionNames.push(\"width\", \"visibleWidth\");\n      }\n      const isFilterPanelHidden = !that.option(\"filterPanel.visible\");\n      if (!that.option(\"filterRow.visible\") && isFilterPanelHidden) {\n        ignoreColumnOptionNames.push(\"filterValue\", \"selectedFilterOperation\");\n      }\n      if (!that.option(\"headerFilter.visible\") && isFilterPanelHidden) {\n        ignoreColumnOptionNames.push(\"filterValues\", \"filterType\");\n      }\n    }\n    that._columnsUserState = state;\n    that._ignoreColumnOptionNames = ignoreColumnOptionNames;\n    that._hasUserState = !!state;\n    updateColumnChanges(that, \"filtering\");\n    that.init(true);\n    if (dataSource) {\n      dataSource.sort(that.getSortDataSourceParameters());\n      dataSource.group(that.getGroupDataSourceParameters());\n    }\n  }\n  _checkColumns() {\n    const usedNames = {};\n    let hasEditableColumnWithoutName = false;\n    const duplicatedNames = [];\n    this._columns.forEach(column => {\n      var _column$columns;\n      const {\n        name: name\n      } = column;\n      const isBand = null === (_column$columns = column.columns) || void 0 === _column$columns ? void 0 : _column$columns.length;\n      const isEditable = column.allowEditing && (column.dataField || column.setCellValue) && !isBand;\n      if (name) {\n        if (usedNames[name]) {\n          duplicatedNames.push(`\"${name}\"`);\n        }\n        usedNames[name] = true;\n      } else if (isEditable) {\n        hasEditableColumnWithoutName = true;\n      }\n    });\n    if (duplicatedNames.length) {\n      errors.log(\"E1059\", duplicatedNames.join(\", \"));\n    }\n    if (hasEditableColumnWithoutName) {\n      errors.log(\"E1060\");\n    }\n  }\n  _createCalculatedColumnOptions(columnOptions, bandColumn) {\n    let calculatedColumnOptions = {};\n    let {\n      dataField: dataField\n    } = columnOptions;\n    if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {\n      calculatedColumnOptions.isBand = true;\n      dataField = null;\n    }\n    if (dataField) {\n      if (isString(dataField)) {\n        const getter = compileGetter(dataField);\n        calculatedColumnOptions = {\n          caption: inflector.captionize(dataField),\n          calculateCellValue(data, skipDeserialization) {\n            const value = getter(data);\n            return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;\n          },\n          setCellValue: defaultSetCellValue,\n          parseValue(text) {\n            const column = this;\n            let result;\n            let parsedValue;\n            if (\"number\" === column.dataType) {\n              if (isString(text) && column.format) {\n                result = strictParseNumber(text.trim(), column.format);\n              } else if (isDefined(text) && isNumeric(text)) {\n                result = Number(text);\n              }\n            } else if (\"boolean\" === column.dataType) {\n              if (text === column.trueText) {\n                result = true;\n              } else if (text === column.falseText) {\n                result = false;\n              }\n            } else if (gridCoreUtils.isDateType(column.dataType)) {\n              parsedValue = dateLocalization.parse(text, column.format);\n              if (parsedValue) {\n                result = parsedValue;\n              }\n            } else {\n              result = text;\n            }\n            return result;\n          }\n        };\n      }\n      calculatedColumnOptions.allowFiltering = true;\n    } else {\n      calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;\n    }\n    calculatedColumnOptions.calculateFilterExpression = function () {\n      return filterUtils.defaultCalculateFilterExpression.apply(this, arguments);\n    };\n    calculatedColumnOptions.defaultFilterOperation = \"=\";\n    calculatedColumnOptions.createFilterExpression = function (filterValue, selectedFilterOperation) {\n      let result;\n      if (this.calculateFilterExpression) {\n        result = this.calculateFilterExpression.apply(this, arguments);\n      }\n      if (isFunction(result)) {\n        result = [result, \"=\", true];\n      }\n      if (result) {\n        result.columnIndex = this.index;\n        result.filterValue = filterValue;\n        result.selectedFilterOperation = selectedFilterOperation;\n      }\n      return result;\n    };\n    if (!dataField || !isString(dataField)) {\n      extend(true, calculatedColumnOptions, {\n        allowSorting: false,\n        allowGrouping: false,\n        calculateCellValue: () => null\n      });\n    }\n    if (bandColumn) {\n      calculatedColumnOptions.allowFixing = false;\n    }\n    if (columnOptions.dataType) {\n      calculatedColumnOptions.userDataType = columnOptions.dataType;\n    }\n    if (columnOptions.selectedFilterOperation && !(\"defaultSelectedFilterOperation\" in calculatedColumnOptions)) {\n      calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation;\n    }\n    if (columnOptions.lookup) {\n      calculatedColumnOptions.lookup = {\n        calculateCellValue(value, skipDeserialization) {\n          if (this.valueExpr) {\n            value = this.valueMap && this.valueMap[value];\n          }\n          return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;\n        },\n        updateValueMap() {\n          this.valueMap = {};\n          if (this.items) {\n            const calculateValue = compileGetter(this.valueExpr);\n            const calculateDisplayValue = compileGetter(this.displayExpr);\n            for (let i = 0; i < this.items.length; i++) {\n              const item = this.items[i];\n              const displayValue = calculateDisplayValue(item);\n              this.valueMap[calculateValue(item)] = displayValue;\n              this.dataType = this.dataType || getValueDataType(displayValue);\n            }\n          }\n        },\n        update() {\n          const that = this;\n          let {\n            dataSource: dataSource\n          } = that;\n          if (dataSource) {\n            if (isFunction(dataSource) && !variableWrapper.isWrapped(dataSource)) {\n              dataSource = dataSource({});\n            }\n            if (isPlainObject(dataSource) || dataSource instanceof Store || Array.isArray(dataSource)) {\n              if (that.valueExpr) {\n                const dataSourceOptions = normalizeDataSourceOptions(dataSource);\n                dataSourceOptions.paginate = false;\n                dataSource = new DataSource(dataSourceOptions);\n                return dataSource.load().done(data => {\n                  that.items = data;\n                  that.updateValueMap && that.updateValueMap();\n                });\n              }\n            } else {\n              errors.log(\"E1016\");\n            }\n          } else {\n            that.updateValueMap && that.updateValueMap();\n          }\n        }\n      };\n    }\n    calculatedColumnOptions.resizedCallbacks = Callbacks();\n    if (columnOptions.resized) {\n      calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions));\n    }\n    each(calculatedColumnOptions, optionName => {\n      if (isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf(\"default\")) {\n        const defaultOptionName = `default${optionName.charAt(0).toUpperCase()}${optionName.substr(1)}`;\n        calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName];\n      }\n    });\n    return calculatedColumnOptions;\n  }\n  getRowCount() {\n    this._rowCount = this._rowCount || getRowCount(this);\n    return this._rowCount;\n  }\n  getRowIndex(columnIndex, alwaysGetRowIndex) {\n    const column = this._columns[columnIndex];\n    const bandColumnsCache = this.getBandColumnsCache();\n    return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0;\n  }\n  getChildrenByBandColumn(bandColumnIndex, onlyVisibleDirectChildren) {\n    const bandColumnsCache = this.getBandColumnsCache();\n    const result = getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);\n    if (onlyVisibleDirectChildren) {\n      return result.filter(column => column.visible && !column.command).sort((column1, column2) => column1.visibleIndex - column2.visibleIndex);\n    }\n    return result;\n  }\n  getVisibleDataColumnsByBandColumn(bandColumnIndex) {\n    const bandColumnsCache = this.getBandColumnsCache();\n    const result = this.getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex);\n    return result.filter(column => !column.isBand && column.visible);\n  }\n  isParentBandColumn(columnIndex, bandColumnIndex) {\n    let result = false;\n    const column = this._columns[columnIndex];\n    const bandColumnsCache = this.getBandColumnsCache();\n    const parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\n    if (parentBandColumns) {\n      each(parentBandColumns, (_, bandColumn) => {\n        if (bandColumn.index === bandColumnIndex) {\n          result = true;\n          return false;\n        }\n      });\n    }\n    return result;\n  }\n  isParentColumnVisible(columnIndex) {\n    let result = true;\n    const bandColumnsCache = this.getBandColumnsCache();\n    const bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\n    bandColumns && each(bandColumns, (_, bandColumn) => {\n      result = result && bandColumn.visible;\n      return result;\n    });\n    return result;\n  }\n  getParentColumn(column) {\n    const bandColumnsCache = this.getBandColumnsCache();\n    const bandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);\n    return bandColumns[0];\n  }\n  isFirstColumn(column, rowIndex) {\n    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n    let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;\n    return isFirstOrLastColumn(this, column, rowIndex, onlyWithinBandColumn, false, fixedPosition);\n  }\n  isLastColumn(column, rowIndex) {\n    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n    let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;\n    return isFirstOrLastColumn(this, column, rowIndex, onlyWithinBandColumn, true, fixedPosition);\n  }\n  getColumnId(column) {\n    if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {\n      if (gridCoreUtils.isCustomCommandColumn(this._columns, column)) {\n        return `type:${column.type}`;\n      }\n      return `command:${column.command}`;\n    }\n    return column.index;\n  }\n  getCustomizeTextByDataType(dataType) {\n    return getCustomizeTextByDataType(dataType);\n  }\n  getHeaderContentAlignment(columnAlignment) {\n    const rtlEnabled = this.option(\"rtlEnabled\");\n    if (rtlEnabled) {\n      return \"left\" === columnAlignment ? \"right\" : \"left\";\n    }\n    return columnAlignment;\n  }\n  isVirtualMode() {\n    return false;\n  }\n}\nexport const columnsControllerModule = {\n  defaultOptions: () => ({\n    commonColumnSettings: {\n      allowFiltering: true,\n      allowHiding: true,\n      allowSorting: true,\n      allowEditing: true,\n      encodeHtml: true,\n      trueText: messageLocalization.format(\"dxDataGrid-trueText\"),\n      falseText: messageLocalization.format(\"dxDataGrid-falseText\")\n    },\n    allowColumnReordering: false,\n    allowColumnResizing: false,\n    columnResizingMode: \"nextColumn\",\n    columnMinWidth: void 0,\n    columnWidth: void 0,\n    adaptColumnWidthByRatio: true,\n    columns: void 0,\n    regenerateColumnsByVisibleItems: false,\n    customizeColumns: null,\n    dateSerializationFormat: void 0\n  }),\n  controllers: {\n    columns: ColumnsController\n  }\n};","map":{"version":3,"names":["_extends","dateLocalization","messageLocalization","DataSource","normalizeDataSourceOptions","config","$","Callbacks","compileGetter","Deferred","when","extend","each","map","orderEach","isDefined","isFunction","isNumeric","isObject","isPlainObject","isString","variableWrapper","Store","filterUtils","errors","inflector","modules","gridCoreUtils","StickyPosition","COLUMN_CHOOSER_LOCATION","COLUMN_OPTION_REGEXP","COMMAND_EXPAND_CLASS","DATATYPE_OPERATIONS","DETAIL_COMMAND_COLUMN_NAME","GROUP_COMMAND_COLUMN_NAME","GROUP_LOCATION","MAX_SAFE_INTEGER","USER_STATE_FIELD_NAMES","addExpandColumn","applyUserState","assignColumns","columnOptionCore","convertOwnerBandToColumnReference","createColumn","createColumnsFromDataSource","createColumnsFromOptions","defaultSetCellValue","digitsCount","findColumn","fireColumnsChanged","getAlignmentByDataType","getChildrenByBandColumn","getColumnByIndexes","getColumnIndexByVisibleIndex","getCustomizeTextByDataType","getDataColumns","getFixedPosition","getParentBandColumns","getRowCount","getSerializationFormat","getValueDataType","isColumnFixed","isFirstOrLastColumn","isSortOrderValid","mergeColumns","moveColumnToGroup","numberToString","processBandColumns","processExpandColumns","resetBandColumnsCache","resetColumnsCache","setFilterOperationsAsDefaultValues","sortColumns","strictParseNumber","updateColumnChanges","updateColumnGroupIndexes","updateIndexes","updateSerializers","ColumnsController","Controller","init","isApplyingUserState","_dataController","getController","_focusController","_stateStoringController","columns","option","_commandColumns","_columns","_isColumnsFromOptions","_columnsUserState","_dataSourceApplied","applyDataSource","_dataSource","_checkColumns","_getExpandColumnOptions","type","command","width","cssClass","allowEditing","allowGrouping","allowSorting","allowResizing","allowReordering","allowHiding","_getFirstItems","dataSource","groupsCount","items","getFirstItemsCore","i","length","childItems","collapsedItems","normalizeSortingInfo","group","_endUpdateCore","_skipProcessingColumnsChange","callbackNames","getColumnByPath","path","that","column","columnIndexes","replace","_","columnIndex","push","parseInt","reduce","index","optionChanged","args","needUpdateRequireResize","name","handled","value","previousValue","Array","isArray","fullName","_ignoreColumnOptionNames","_columnOptionChanged","_updateRequireResize","ignoreColumnOptionNames","reinit","columnOptionValue","columnOptionName","columnOption","component","_updateLockCount","_requireResize","publicMethods","forceApplying","isDataSourceLoaded","isLoaded","_dataSourceColumnsCount","columnsFromDataSource","updateColumns","isAllDataTypesDefined","updateColumnDataTypes","reject","promise","reset","_visibleColumns","_fixedColumns","_rowCount","getUserState","isInitialized","isDataSourceApplied","getCommonSettings","commonColumnSettings","groupingOptions","groupPanelOptions","allowFixing","minWidth","autoExpandGroup","autoExpandAll","allowCollapsing","allowColumnDragging","visible","contextMenuEnabled","isColumnOptionUsed","optionName","checkSerializers","dataField","calculateCellValue","defaultCalculateCellValue","dataType","deserializeValue","serializationFormat","getColumns","isBandColumnsUsed","some","isBand","getGroupColumns","result","groupIndex","_shouldReturnVisibleColumns","_compileVisibleColumns","rowIndex","_compileVisibleColumnsCore","getVisibleColumns","isBase","apply","arguments","getFixedColumns","_getFixedColumnsCore","getFilteringColumns","filter","item","allowFiltering","allowHeaderFiltering","field","filterOperations","defaultFilterOperations","getColumnIndexOffset","getStickyColumns","visibleColumns","fixed","rowCount","isColumnFixing","_isColumnFixing","transparentColumn","transparentColspan","notFixedColumnCount","transparentColumnIndex","lastFixedPosition","j","prevColumn","fixedPosition","Sticky","colspan","slice","splice","newColumn","headerId","_getExpandColumnsCore","getExpandColumns","expandColumns","expandColumn","firstGroupColumn","isFixedFirstGroupColumn","rtlEnabled","visibleWidth","cellTemplate","headerCellTemplate","getBandColumnsCache","_bandColumnsCache","columnChildrenByIndex","columnParentByIndex","isPlain","forEach","ownerBand","parentIndex","parent","hasColumns","rowspan","_isColumnVisible","isParentColumnVisible","_isColumnInGroupPanel","showWhenGrouped","hasVisibleDataColumns","isVisible","isInGroupPanel","isCommand","bandColumnsCache","indexedColumns","_getIndexedColumns","_getVisibleColumnsFromIndexed","isDataColumnsInvisible","columnDigitsCount","positiveIndexedColumns","negativeIndexedColumns","visibleIndex","parentBandColumns","_parentBandColumns$","_parentBandColumns$2","isDefaultCommandColumn","isCustomCommandColumn","isFixedToEnd","_ref","rowspanGroupColumns","rowspanExpandColumns","unshift","firstPositiveIndexColumn","positiveIndexedRowColumns","columnsByFixing","columnsByVisibleIndex","call","getInvisibleColumns","bandColumnIndex","hiddenColumnsByBand","concat","getChooserColumns","getAllColumns","columnChooserColumns","showInColumnChooser","sortOrder","allowMoveColumn","fromVisibleIndex","toVisibleIndex","sourceLocation","targetLocation","sourceColumn","moveColumn","options","prevGroupIndex","fromIndex","toIndex","targetGroupIndex","targetColumn","changeSortOrder","sortingOptions","sortingMode","mode","needResetSorting","sortIndex","getSortDataSourceParameters","useLocalSelector","sort","selector","sortItem","calculateSortValue","displayField","calculateDisplayValue","desc","sortingMethod","compare","bind","getGroupDataSourceParameters","calculateGroupValue","groupItem","isExpanded","refresh","updateNewLookupsOnly","deferreds","lookup","valueMap","update","done","_updateColumnOptions","_this$_previousColumn","_this$_previousColumn2","shouldTakeOriginalCallbackFromPrevious","_reinitAfterLookupChanges","_previousColumns","data","originalCallback","calculateCallbackName","calculateCallback","context","displayValueMap","alignment","format","getFormatByDataType","customizeText","defaultFilterOperation","showEditorAlways","dateSerializationFormat","firstItems","isColumnDataTypesUpdated","lookupDataType","valueDataType","isDateType","getDisplayValue","_customizeColumns","customizeColumns","hasOwnerBand","updateSortingGrouping","sortParameters","groupParameters","filterParameters","lastLoadOptions","always","_updateChanges","sorting","grouping","filtering","parameters","_dataSource$loadOptio","langParams","loadOptions","equalSortParameters","equalFilterParameters","getCombinedFilter","fromDataSource","isColumnsChanged","updateSortGroupParameterIndexes","indexParameterName","_this$_columnChanges","columnsGroupParameters","columnsSortParameters","changeTypes","_columnChanges","sortingChanged","needToApplySortingFromDataSource","needToApplyGroupingFromDataSource","groupingChanged","groupExpandingChanged","_hasUserState","updateFilter","remoteFiltering","filterValue","forceIsoDateParsing","serializeValue","selectedFilterOperation","columnCount","identifier","notFireEvent","clearSorting","beginUpdate","endUpdate","clearGrouping","getVisibleIndex","getVisibleIndexByColumn","visibleColumn","col","indexOf","getVisibleColumnIndex","id","addColumn","added","deleteColumn","childIndexes","addCommandColumn","commandColumn","handleStateField","setName","setUserState","state","isFilterPanelHidden","usedNames","hasEditableColumnWithoutName","duplicatedNames","_column$columns","isEditable","setCellValue","log","join","_createCalculatedColumnOptions","columnOptions","bandColumn","calculatedColumnOptions","getter","caption","captionize","skipDeserialization","parseValue","text","parsedValue","trim","Number","trueText","falseText","parse","calculateFilterExpression","defaultCalculateFilterExpression","createFilterExpression","userDataType","defaultSelectedFilterOperation","valueExpr","updateValueMap","calculateValue","displayExpr","displayValue","isWrapped","dataSourceOptions","paginate","load","resizedCallbacks","resized","add","defaultOptionName","charAt","toUpperCase","substr","getRowIndex","alwaysGetRowIndex","onlyVisibleDirectChildren","column1","column2","getVisibleDataColumnsByBandColumn","isParentBandColumn","bandColumns","getParentColumn","isFirstColumn","onlyWithinBandColumn","isLastColumn","getColumnId","getHeaderContentAlignment","columnAlignment","isVirtualMode","columnsControllerModule","defaultOptions","encodeHtml","allowColumnReordering","allowColumnResizing","columnResizingMode","columnMinWidth","columnWidth","adaptColumnWidthByRatio","regenerateColumnsByVisibleItems","controllers"],"sources":["C:/Users/Sofia/Desktop/ /internship_project/client/node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/m_columns_controller.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/grid_core/columns_controller/m_columns_controller.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateLocalization from \"../../../../common/core/localization/date\";\r\nimport messageLocalization from \"../../../../common/core/localization/message\";\r\nimport {\r\n    DataSource\r\n} from \"../../../../common/data/data_source/data_source\";\r\nimport {\r\n    normalizeDataSourceOptions\r\n} from \"../../../../common/data/data_source/utils\";\r\nimport config from \"../../../../core/config\";\r\nimport $ from \"../../../../core/renderer\";\r\nimport Callbacks from \"../../../../core/utils/callbacks\";\r\nimport {\r\n    compileGetter\r\n} from \"../../../../core/utils/data\";\r\nimport {\r\n    Deferred,\r\n    when\r\n} from \"../../../../core/utils/deferred\";\r\nimport {\r\n    extend\r\n} from \"../../../../core/utils/extend\";\r\nimport {\r\n    each,\r\n    map\r\n} from \"../../../../core/utils/iterator\";\r\nimport {\r\n    orderEach\r\n} from \"../../../../core/utils/object\";\r\nimport {\r\n    isDefined,\r\n    isFunction,\r\n    isNumeric,\r\n    isObject,\r\n    isPlainObject,\r\n    isString\r\n} from \"../../../../core/utils/type\";\r\nimport variableWrapper from \"../../../../core/utils/variable_wrapper\";\r\nimport Store from \"../../../../data/abstract_store\";\r\nimport filterUtils from \"../../../../ui/shared/filtering\";\r\nimport errors from \"../../../../ui/widget/ui.errors\";\r\nimport inflector from \"../../../core/utils/m_inflector\";\r\nimport modules from \"../m_modules\";\r\nimport gridCoreUtils from \"../m_utils\";\r\nimport {\r\n    StickyPosition\r\n} from \"../sticky_columns/const\";\r\nimport {\r\n    COLUMN_CHOOSER_LOCATION,\r\n    COLUMN_OPTION_REGEXP,\r\n    COMMAND_EXPAND_CLASS,\r\n    DATATYPE_OPERATIONS,\r\n    DETAIL_COMMAND_COLUMN_NAME,\r\n    GROUP_COMMAND_COLUMN_NAME,\r\n    GROUP_LOCATION,\r\n    MAX_SAFE_INTEGER,\r\n    USER_STATE_FIELD_NAMES\r\n} from \"./const\";\r\nimport {\r\n    addExpandColumn,\r\n    applyUserState,\r\n    assignColumns,\r\n    columnOptionCore,\r\n    convertOwnerBandToColumnReference,\r\n    createColumn,\r\n    createColumnsFromDataSource,\r\n    createColumnsFromOptions,\r\n    defaultSetCellValue,\r\n    digitsCount,\r\n    findColumn,\r\n    fireColumnsChanged,\r\n    getAlignmentByDataType,\r\n    getChildrenByBandColumn,\r\n    getColumnByIndexes,\r\n    getColumnIndexByVisibleIndex,\r\n    getCustomizeTextByDataType,\r\n    getDataColumns,\r\n    getFixedPosition,\r\n    getParentBandColumns,\r\n    getRowCount,\r\n    getSerializationFormat,\r\n    getValueDataType,\r\n    isColumnFixed,\r\n    isFirstOrLastColumn,\r\n    isSortOrderValid,\r\n    mergeColumns,\r\n    moveColumnToGroup,\r\n    numberToString,\r\n    processBandColumns,\r\n    processExpandColumns,\r\n    resetBandColumnsCache,\r\n    resetColumnsCache,\r\n    setFilterOperationsAsDefaultValues,\r\n    sortColumns,\r\n    strictParseNumber,\r\n    updateColumnChanges,\r\n    updateColumnGroupIndexes,\r\n    updateIndexes,\r\n    updateSerializers\r\n} from \"./m_columns_controller_utils\";\r\nexport class ColumnsController extends modules.Controller {\r\n    init(isApplyingUserState) {\r\n        this._dataController = this.getController(\"data\");\r\n        this._focusController = this.getController(\"focus\");\r\n        this._stateStoringController = this.getController(\"stateStoring\");\r\n        const columns = this.option(\"columns\");\r\n        this._commandColumns = this._commandColumns || [];\r\n        this._columns = this._columns || [];\r\n        this._isColumnsFromOptions = !!columns;\r\n        if (this._isColumnsFromOptions) {\r\n            assignColumns(this, columns ? createColumnsFromOptions(this, columns) : []);\r\n            applyUserState(this)\r\n        } else {\r\n            assignColumns(this, this._columnsUserState ? createColumnsFromOptions(this, this._columnsUserState) : this._columns)\r\n        }\r\n        addExpandColumn(this);\r\n        if (this._dataSourceApplied) {\r\n            this.applyDataSource(this._dataSource, true, isApplyingUserState)\r\n        } else {\r\n            updateIndexes(this)\r\n        }\r\n        this._checkColumns()\r\n    }\r\n    _getExpandColumnOptions() {\r\n        return {\r\n            type: \"expand\",\r\n            command: \"expand\",\r\n            width: \"auto\",\r\n            cssClass: COMMAND_EXPAND_CLASS,\r\n            allowEditing: false,\r\n            allowGrouping: false,\r\n            allowSorting: false,\r\n            allowResizing: false,\r\n            allowReordering: false,\r\n            allowHiding: false\r\n        }\r\n    }\r\n    _getFirstItems(dataSource) {\r\n        let groupsCount;\r\n        let items = [];\r\n        const getFirstItemsCore = function(items, groupsCount) {\r\n            if (!items || !groupsCount) {\r\n                return items\r\n            }\r\n            for (let i = 0; i < items.length; i++) {\r\n                const childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);\r\n                if (childItems && childItems.length) {\r\n                    return childItems\r\n                }\r\n            }\r\n        };\r\n        if (dataSource && dataSource.items().length > 0) {\r\n            groupsCount = gridCoreUtils.normalizeSortingInfo(dataSource.group()).length;\r\n            items = getFirstItemsCore(dataSource.items(), groupsCount) || []\r\n        }\r\n        return items\r\n    }\r\n    _endUpdateCore() {\r\n        !this._skipProcessingColumnsChange && fireColumnsChanged(this)\r\n    }\r\n    callbackNames() {\r\n        return [\"columnsChanged\"]\r\n    }\r\n    getColumnByPath(path, columns) {\r\n        const that = this;\r\n        let column;\r\n        const columnIndexes = [];\r\n        path.replace(COLUMN_OPTION_REGEXP, ((_, columnIndex) => {\r\n            columnIndexes.push(parseInt(columnIndex));\r\n            return \"\"\r\n        }));\r\n        if (columnIndexes.length) {\r\n            if (columns) {\r\n                column = columnIndexes.reduce(((column, index) => column && column.columns && column.columns[index]), {\r\n                    columns: columns\r\n                })\r\n            } else {\r\n                column = getColumnByIndexes(that, columnIndexes)\r\n            }\r\n        }\r\n        return column\r\n    }\r\n    optionChanged(args) {\r\n        let needUpdateRequireResize;\r\n        switch (args.name) {\r\n            case \"adaptColumnWidthByRatio\":\r\n                args.handled = true;\r\n                break;\r\n            case \"dataSource\":\r\n                if (args.value !== args.previousValue && !this.option(\"columns\") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {\r\n                    this._columns = []\r\n                }\r\n                break;\r\n            case \"columns\":\r\n                needUpdateRequireResize = this._skipProcessingColumnsChange;\r\n                args.handled = true;\r\n                if (!this._skipProcessingColumnsChange) {\r\n                    if (args.name === args.fullName) {\r\n                        this._columnsUserState = null;\r\n                        this._ignoreColumnOptionNames = null;\r\n                        this.init()\r\n                    } else {\r\n                        this._columnOptionChanged(args);\r\n                        needUpdateRequireResize = true\r\n                    }\r\n                }\r\n                if (needUpdateRequireResize) {\r\n                    this._updateRequireResize(args)\r\n                }\r\n                break;\r\n            case \"commonColumnSettings\":\r\n            case \"columnAutoWidth\":\r\n            case \"allowColumnResizing\":\r\n            case \"allowColumnReordering\":\r\n            case \"columnFixing\":\r\n            case \"grouping\":\r\n            case \"groupPanel\":\r\n            case \"regenerateColumnsByVisibleItems\":\r\n            case \"customizeColumns\":\r\n            case \"columnHidingEnabled\":\r\n            case \"dateSerializationFormat\":\r\n            case \"columnResizingMode\":\r\n            case \"columnMinWidth\":\r\n            case \"columnWidth\": {\r\n                args.handled = true;\r\n                const ignoreColumnOptionNames = \"columnWidth\" === args.fullName && [\"width\"];\r\n                this.reinit(ignoreColumnOptionNames);\r\n                break\r\n            }\r\n            case \"rtlEnabled\":\r\n                this.reinit();\r\n                break;\r\n            default:\r\n                super.optionChanged(args)\r\n        }\r\n    }\r\n    _columnOptionChanged(args) {\r\n        let columnOptionValue = {};\r\n        const column = this.getColumnByPath(args.fullName);\r\n        const columnOptionName = args.fullName.replace(COLUMN_OPTION_REGEXP, \"\");\r\n        if (column) {\r\n            if (columnOptionName) {\r\n                columnOptionValue[columnOptionName] = args.value\r\n            } else {\r\n                columnOptionValue = args.value\r\n            }\r\n            this._skipProcessingColumnsChange = args.fullName;\r\n            this.columnOption(column.index, columnOptionValue);\r\n            this._skipProcessingColumnsChange = false\r\n        }\r\n    }\r\n    _updateRequireResize(args) {\r\n        const {\r\n            component: component\r\n        } = this;\r\n        if (\"width\" === args.fullName.replace(COLUMN_OPTION_REGEXP, \"\") && component._updateLockCount) {\r\n            component._requireResize = true\r\n        }\r\n    }\r\n    publicMethods() {\r\n        return [\"addColumn\", \"deleteColumn\", \"columnOption\", \"columnCount\", \"clearSorting\", \"clearGrouping\", \"getVisibleColumns\", \"getVisibleColumnIndex\", \"getColumns\"]\r\n    }\r\n    applyDataSource(dataSource, forceApplying, isApplyingUserState) {\r\n        const that = this;\r\n        const isDataSourceLoaded = dataSource && dataSource.isLoaded();\r\n        that._dataSource = dataSource;\r\n        if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option(\"regenerateColumnsByVisibleItems\")) {\r\n            if (isDataSourceLoaded) {\r\n                if (!that._isColumnsFromOptions) {\r\n                    const columnsFromDataSource = createColumnsFromDataSource(that, dataSource);\r\n                    if (columnsFromDataSource.length) {\r\n                        assignColumns(that, columnsFromDataSource);\r\n                        that._dataSourceColumnsCount = that._columns.length;\r\n                        applyUserState(that)\r\n                    }\r\n                }\r\n                return that.updateColumns(dataSource, forceApplying, isApplyingUserState)\r\n            }\r\n            that._dataSourceApplied = false;\r\n            updateIndexes(that)\r\n        } else if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {\r\n            updateColumnChanges(that, \"columns\");\r\n            fireColumnsChanged(that);\r\n            return (new Deferred).reject().promise()\r\n        }\r\n    }\r\n    reset() {\r\n        this._dataSource = null;\r\n        this._dataSourceApplied = false;\r\n        this._dataSourceColumnsCount = void 0;\r\n        this.reinit()\r\n    }\r\n    resetColumnsCache() {\r\n        this._visibleColumns = void 0;\r\n        this._fixedColumns = void 0;\r\n        this._rowCount = void 0;\r\n        resetBandColumnsCache(this)\r\n    }\r\n    reinit(ignoreColumnOptionNames) {\r\n        this._columnsUserState = this.getUserState();\r\n        this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;\r\n        this.init();\r\n        if (ignoreColumnOptionNames) {\r\n            this._ignoreColumnOptionNames = null\r\n        }\r\n    }\r\n    isInitialized() {\r\n        return !!this._columns.length || !!this.option(\"columns\")\r\n    }\r\n    isDataSourceApplied() {\r\n        return this._dataSourceApplied\r\n    }\r\n    getCommonSettings(column) {\r\n        const commonColumnSettings = (!column || !column.type) && this.option(\"commonColumnSettings\") || {};\r\n        const groupingOptions = this.option(\"grouping\") ?? {};\r\n        const groupPanelOptions = this.option(\"groupPanel\") ?? {};\r\n        return extend({\r\n            allowFixing: this.option(\"columnFixing.enabled\"),\r\n            allowResizing: this.option(\"allowColumnResizing\") || void 0,\r\n            allowReordering: this.option(\"allowColumnReordering\"),\r\n            minWidth: this.option(\"columnMinWidth\"),\r\n            width: this.option(\"columnWidth\"),\r\n            autoExpandGroup: groupingOptions.autoExpandAll,\r\n            allowCollapsing: groupingOptions.allowCollapsing,\r\n            allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled\r\n        }, commonColumnSettings)\r\n    }\r\n    isColumnOptionUsed(optionName) {\r\n        for (let i = 0; i < this._columns.length; i++) {\r\n            if (this._columns[i][optionName]) {\r\n                return true\r\n            }\r\n        }\r\n    }\r\n    isAllDataTypesDefined(checkSerializers) {\r\n        const columns = this._columns;\r\n        if (!columns.length) {\r\n            return false\r\n        }\r\n        for (let i = 0; i < columns.length; i++) {\r\n            if (!columns[i].dataField && columns[i].calculateCellValue === columns[i].defaultCalculateCellValue) {\r\n                continue\r\n            }\r\n            if (!columns[i].dataType || checkSerializers && columns[i].deserializeValue && void 0 === columns[i].serializationFormat) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n    getColumns() {\r\n        return this._columns\r\n    }\r\n    isBandColumnsUsed() {\r\n        return this.getColumns().some((column => column.isBand))\r\n    }\r\n    getGroupColumns() {\r\n        const result = [];\r\n        each(this._columns, (function() {\r\n            const column = this;\r\n            if (isDefined(column.groupIndex)) {\r\n                result[column.groupIndex] = column\r\n            }\r\n        }));\r\n        return result\r\n    }\r\n    _shouldReturnVisibleColumns() {\r\n        return true\r\n    }\r\n    _compileVisibleColumns(rowIndex) {\r\n        this._visibleColumns = this._visibleColumns || this._compileVisibleColumnsCore();\r\n        rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;\r\n        return this._visibleColumns[rowIndex] || []\r\n    }\r\n    getVisibleColumns(rowIndex, isBase) {\r\n        if (!this._shouldReturnVisibleColumns()) {\r\n            return []\r\n        }\r\n        return this._compileVisibleColumns.apply(this, arguments)\r\n    }\r\n    getFixedColumns(rowIndex) {\r\n        this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();\r\n        rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;\r\n        return this._fixedColumns[rowIndex] || []\r\n    }\r\n    getFilteringColumns() {\r\n        return this.getColumns().filter((item => (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering))).map((item => {\r\n            const field = extend(true, {}, item);\r\n            if (!isDefined(field.dataField)) {\r\n                field.dataField = field.name\r\n            }\r\n            field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;\r\n            return field\r\n        }))\r\n    }\r\n    getColumnIndexOffset() {\r\n        return 0\r\n    }\r\n    getStickyColumns(rowIndex) {\r\n        const visibleColumns = this.getVisibleColumns(rowIndex, true);\r\n        return visibleColumns.filter((column => column.fixed))\r\n    }\r\n    _getFixedColumnsCore() {\r\n        const that = this;\r\n        const result = [];\r\n        const rowCount = that.getRowCount();\r\n        const isColumnFixing = that._isColumnFixing();\r\n        const transparentColumn = {\r\n            command: \"transparent\"\r\n        };\r\n        let transparentColspan = 0;\r\n        let notFixedColumnCount;\r\n        let transparentColumnIndex;\r\n        let lastFixedPosition;\r\n        if (isColumnFixing) {\r\n            for (let i = 0; i <= rowCount; i++) {\r\n                notFixedColumnCount = 0;\r\n                lastFixedPosition = null;\r\n                transparentColumnIndex = null;\r\n                const visibleColumns = that.getVisibleColumns(i, true);\r\n                for (let j = 0; j < visibleColumns.length; j++) {\r\n                    const prevColumn = visibleColumns[j - 1];\r\n                    const column = visibleColumns[j];\r\n                    if (!column.fixed || column.fixedPosition === StickyPosition.Sticky) {\r\n                        if (0 === i) {\r\n                            if (column.isBand && column.colspan) {\r\n                                transparentColspan += column.colspan\r\n                            } else {\r\n                                transparentColspan++\r\n                            }\r\n                        }\r\n                        notFixedColumnCount++;\r\n                        if (!isDefined(transparentColumnIndex)) {\r\n                            transparentColumnIndex = j\r\n                        }\r\n                    } else if (prevColumn && prevColumn.fixed && getFixedPosition(that, prevColumn) !== getFixedPosition(that, column)) {\r\n                        if (!isDefined(transparentColumnIndex)) {\r\n                            transparentColumnIndex = j\r\n                        }\r\n                    } else {\r\n                        lastFixedPosition = column.fixedPosition\r\n                    }\r\n                }\r\n                if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {\r\n                    return []\r\n                }\r\n                if (!isDefined(transparentColumnIndex)) {\r\n                    transparentColumnIndex = \"right\" === lastFixedPosition ? 0 : visibleColumns.length\r\n                }\r\n                result[i] = visibleColumns.slice(0);\r\n                if (!transparentColumn.colspan) {\r\n                    transparentColumn.colspan = transparentColspan\r\n                }\r\n                result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn)\r\n            }\r\n        }\r\n        return result.map((columns => columns.map((column => {\r\n            const newColumn = _extends({}, column);\r\n            if (newColumn.headerId) {\r\n                newColumn.headerId += \"-fixed\"\r\n            }\r\n            return newColumn\r\n        }))))\r\n    }\r\n    _isColumnFixing() {\r\n        let isColumnFixing = this.option(\"columnFixing.enabled\");\r\n        !isColumnFixing && each(this._columns, ((_, column) => {\r\n            if (column.fixed) {\r\n                isColumnFixing = true;\r\n                return false\r\n            }\r\n        }));\r\n        return isColumnFixing\r\n    }\r\n    _getExpandColumnsCore() {\r\n        return this.getGroupColumns()\r\n    }\r\n    getExpandColumns() {\r\n        let expandColumns = this._getExpandColumnsCore();\r\n        let expandColumn;\r\n        const firstGroupColumn = expandColumns.filter((column => 0 === column.groupIndex))[0];\r\n        const isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;\r\n        const isColumnFixing = this._isColumnFixing();\r\n        const rtlEnabled = this.option(\"rtlEnabled\");\r\n        if (expandColumns.length) {\r\n            expandColumn = this.columnOption(\"command:expand\")\r\n        }\r\n        expandColumns = map(expandColumns, (column => extend({}, column, {\r\n            visibleWidth: null,\r\n            minWidth: null,\r\n            cellTemplate: !isDefined(column.groupIndex) ? column.cellTemplate : null,\r\n            headerCellTemplate: null,\r\n            fixed: !isDefined(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true,\r\n            fixedPosition: rtlEnabled ? \"right\" : \"left\"\r\n        }, expandColumn, {\r\n            index: column.index,\r\n            type: column.type || GROUP_COMMAND_COLUMN_NAME\r\n        })));\r\n        return expandColumns\r\n    }\r\n    getBandColumnsCache() {\r\n        if (!this._bandColumnsCache) {\r\n            const columns = this._columns;\r\n            const columnChildrenByIndex = {};\r\n            const columnParentByIndex = {};\r\n            let isPlain = true;\r\n            columns.forEach((column => {\r\n                const {\r\n                    ownerBand: ownerBand\r\n                } = column;\r\n                let parentIndex = isObject(ownerBand) ? ownerBand.index : ownerBand;\r\n                const parent = columns[parentIndex];\r\n                if (column.hasColumns) {\r\n                    isPlain = false\r\n                }\r\n                if (column.colspan) {\r\n                    column.colspan = void 0\r\n                }\r\n                if (column.rowspan) {\r\n                    column.rowspan = void 0\r\n                }\r\n                if (parent) {\r\n                    columnParentByIndex[column.index] = parent\r\n                } else {\r\n                    parentIndex = -1\r\n                }\r\n                columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];\r\n                columnChildrenByIndex[parentIndex].push(column)\r\n            }));\r\n            this._bandColumnsCache = {\r\n                isPlain: isPlain,\r\n                columnChildrenByIndex: columnChildrenByIndex,\r\n                columnParentByIndex: columnParentByIndex\r\n            }\r\n        }\r\n        return this._bandColumnsCache\r\n    }\r\n    _isColumnVisible(column) {\r\n        return column.visible && this.isParentColumnVisible(column.index)\r\n    }\r\n    _isColumnInGroupPanel(column) {\r\n        return isDefined(column.groupIndex) && !column.showWhenGrouped\r\n    }\r\n    hasVisibleDataColumns() {\r\n        const columns = this._columns;\r\n        return columns.some((column => {\r\n            const isVisible = this._isColumnVisible(column);\r\n            const isInGroupPanel = this._isColumnInGroupPanel(column);\r\n            const isCommand = !!column.command;\r\n            return isVisible && !isInGroupPanel && !isCommand\r\n        }))\r\n    }\r\n    _compileVisibleColumnsCore() {\r\n        const bandColumnsCache = this.getBandColumnsCache();\r\n        const columns = mergeColumns(this, this._columns, this._commandColumns, true);\r\n        processBandColumns(this, columns, bandColumnsCache);\r\n        const indexedColumns = this._getIndexedColumns(columns);\r\n        const visibleColumns = this._getVisibleColumnsFromIndexed(indexedColumns);\r\n        const isDataColumnsInvisible = !this.hasVisibleDataColumns();\r\n        if (isDataColumnsInvisible && this._columns.length) {\r\n            visibleColumns[visibleColumns.length - 1].push({\r\n                command: \"empty\"\r\n            })\r\n        }\r\n        return visibleColumns\r\n    }\r\n    _getIndexedColumns(columns) {\r\n        const rtlEnabled = this.option(\"rtlEnabled\");\r\n        const rowCount = this.getRowCount();\r\n        const columnDigitsCount = digitsCount(columns.length);\r\n        const bandColumnsCache = this.getBandColumnsCache();\r\n        const positiveIndexedColumns = [];\r\n        const negativeIndexedColumns = [];\r\n        for (let i = 0; i < rowCount; i += 1) {\r\n            negativeIndexedColumns[i] = [{}];\r\n            positiveIndexedColumns[i] = [{}, {}, {}]\r\n        }\r\n        columns.forEach((column => {\r\n            let {\r\n                visibleIndex: visibleIndex\r\n            } = column;\r\n            let indexedColumns;\r\n            const parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);\r\n            const isVisible = this._isColumnVisible(column);\r\n            const isInGroupPanel = this._isColumnInGroupPanel(column);\r\n            if (isVisible && !isInGroupPanel) {\r\n                const rowIndex = parentBandColumns.length;\r\n                if (visibleIndex < 0) {\r\n                    visibleIndex = -visibleIndex;\r\n                    indexedColumns = negativeIndexedColumns[rowIndex]\r\n                } else {\r\n                    var _parentBandColumns$, _parentBandColumns$2;\r\n                    column.fixed = (null === (_parentBandColumns$ = parentBandColumns[0]) || void 0 === _parentBandColumns$ ? void 0 : _parentBandColumns$.fixed) ?? column.fixed;\r\n                    column.fixedPosition = (null === (_parentBandColumns$2 = parentBandColumns[0]) || void 0 === _parentBandColumns$2 ? void 0 : _parentBandColumns$2.fixedPosition) ?? column.fixedPosition;\r\n                    if (column.fixed && column.fixedPosition !== StickyPosition.Sticky) {\r\n                        const isDefaultCommandColumn = !!column.command && !gridCoreUtils.isCustomCommandColumn(this._columns, column);\r\n                        let isFixedToEnd = \"right\" === column.fixedPosition;\r\n                        if (rtlEnabled && !isDefaultCommandColumn) {\r\n                            isFixedToEnd = !isFixedToEnd\r\n                        }\r\n                        indexedColumns = isFixedToEnd ? positiveIndexedColumns[rowIndex][2] : positiveIndexedColumns[rowIndex][0]\r\n                    } else {\r\n                        indexedColumns = positiveIndexedColumns[rowIndex][1]\r\n                    }\r\n                }\r\n                if (parentBandColumns.length) {\r\n                    visibleIndex = numberToString(visibleIndex, columnDigitsCount);\r\n                    for (let i = parentBandColumns.length - 1; i >= 0; i -= 1) {\r\n                        visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex\r\n                    }\r\n                }\r\n                indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];\r\n                indexedColumns[visibleIndex].push(column)\r\n            }\r\n        }));\r\n        return {\r\n            positiveIndexedColumns: positiveIndexedColumns,\r\n            negativeIndexedColumns: negativeIndexedColumns\r\n        }\r\n    }\r\n    _getVisibleColumnsFromIndexed(_ref) {\r\n        let {\r\n            positiveIndexedColumns: positiveIndexedColumns,\r\n            negativeIndexedColumns: negativeIndexedColumns\r\n        } = _ref;\r\n        const result = [];\r\n        const rowCount = this.getRowCount();\r\n        const expandColumns = mergeColumns(this, this.getExpandColumns(), this._columns);\r\n        let rowspanGroupColumns = 0;\r\n        let rowspanExpandColumns = 0;\r\n        for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\r\n            result.push([]);\r\n            orderEach(negativeIndexedColumns[rowIndex], ((_, columns) => {\r\n                result[rowIndex].unshift.apply(result[rowIndex], columns)\r\n            }));\r\n            const firstPositiveIndexColumn = result[rowIndex].length;\r\n            const positiveIndexedRowColumns = positiveIndexedColumns[rowIndex];\r\n            positiveIndexedRowColumns.forEach((columnsByFixing => {\r\n                orderEach(columnsByFixing, ((_, columnsByVisibleIndex) => {\r\n                    result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex)\r\n                }))\r\n            }));\r\n            if (rowspanExpandColumns <= rowIndex) {\r\n                rowspanExpandColumns += processExpandColumns.call(this, result[rowIndex], expandColumns, DETAIL_COMMAND_COLUMN_NAME, firstPositiveIndexColumn)\r\n            }\r\n            if (rowspanGroupColumns <= rowIndex) {\r\n                rowspanGroupColumns += processExpandColumns.call(this, result[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn)\r\n            }\r\n        }\r\n        result.push(getDataColumns(result));\r\n        return result\r\n    }\r\n    getInvisibleColumns(columns, bandColumnIndex) {\r\n        const that = this;\r\n        let result = [];\r\n        let hiddenColumnsByBand;\r\n        columns = columns || that._columns;\r\n        each(columns, ((_, column) => {\r\n            if (column.ownerBand !== bandColumnIndex) {\r\n                return\r\n            }\r\n            if (column.isBand) {\r\n                if (!column.visible) {\r\n                    hiddenColumnsByBand = that.getChildrenByBandColumn(column.index)\r\n                } else {\r\n                    hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index)\r\n                }\r\n                if (hiddenColumnsByBand.length) {\r\n                    result.push(column);\r\n                    result = result.concat(hiddenColumnsByBand)\r\n                }\r\n                return\r\n            }\r\n            if (!column.visible) {\r\n                result.push(column)\r\n            }\r\n        }));\r\n        return result\r\n    }\r\n    getChooserColumns(getAllColumns) {\r\n        const columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();\r\n        const columnChooserColumns = columns.filter((column => column.showInColumnChooser));\r\n        const sortOrder = this.option(\"columnChooser.sortOrder\");\r\n        return sortColumns(columnChooserColumns, sortOrder)\r\n    }\r\n    allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\r\n        const columnIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);\r\n        const sourceColumn = this._columns[columnIndex];\r\n        if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {\r\n            if (sourceLocation === targetLocation) {\r\n                if (sourceLocation === COLUMN_CHOOSER_LOCATION) {\r\n                    return false\r\n                }\r\n                fromVisibleIndex = isObject(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;\r\n                toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\r\n                return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex\r\n            }\r\n            if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {\r\n                return sourceColumn && sourceColumn.allowGrouping\r\n            }\r\n            if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {\r\n                return sourceColumn && sourceColumn.allowHiding\r\n            }\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n    moveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\r\n        const that = this;\r\n        const options = {};\r\n        let prevGroupIndex;\r\n        const fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);\r\n        const toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);\r\n        let targetGroupIndex;\r\n        if (fromIndex >= 0) {\r\n            const column = that._columns[fromIndex];\r\n            toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\r\n            targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;\r\n            if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {\r\n                if (targetGroupIndex > column.groupIndex) {\r\n                    targetGroupIndex--\r\n                }\r\n                if (targetLocation !== GROUP_LOCATION) {\r\n                    options.groupIndex = void 0\r\n                } else {\r\n                    prevGroupIndex = column.groupIndex;\r\n                    delete column.groupIndex;\r\n                    updateColumnGroupIndexes(that)\r\n                }\r\n            }\r\n            if (targetLocation === GROUP_LOCATION) {\r\n                options.groupIndex = moveColumnToGroup(that, column, targetGroupIndex);\r\n                column.groupIndex = prevGroupIndex\r\n            } else if (toVisibleIndex >= 0) {\r\n                const targetColumn = that._columns[toIndex];\r\n                if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {\r\n                    options.visibleIndex = MAX_SAFE_INTEGER\r\n                } else if (isColumnFixed(that, column) ^ isColumnFixed(that, targetColumn)) {\r\n                    options.visibleIndex = MAX_SAFE_INTEGER\r\n                } else {\r\n                    options.visibleIndex = targetColumn.visibleIndex\r\n                }\r\n            }\r\n            const isVisible = targetLocation !== COLUMN_CHOOSER_LOCATION;\r\n            if (column.visible !== isVisible) {\r\n                options.visible = isVisible\r\n            }\r\n            that.columnOption(column.index, options)\r\n        }\r\n    }\r\n    changeSortOrder(columnIndex, sortOrder) {\r\n        const that = this;\r\n        const options = {};\r\n        const sortingOptions = that.option(\"sorting\");\r\n        const sortingMode = sortingOptions && sortingOptions.mode;\r\n        const needResetSorting = \"single\" === sortingMode || !sortOrder;\r\n        const allowSorting = \"single\" === sortingMode || \"multiple\" === sortingMode;\r\n        const column = that._columns[columnIndex];\r\n        if (allowSorting && column && column.allowSorting) {\r\n            if (needResetSorting && !isDefined(column.groupIndex)) {\r\n                each(that._columns, (function(index) {\r\n                    if (index !== columnIndex && this.sortOrder) {\r\n                        if (!isDefined(this.groupIndex)) {\r\n                            delete this.sortOrder\r\n                        }\r\n                        delete this.sortIndex\r\n                    }\r\n                }))\r\n            }\r\n            if (isSortOrderValid(sortOrder)) {\r\n                if (column.sortOrder !== sortOrder) {\r\n                    options.sortOrder = sortOrder\r\n                }\r\n            } else if (\"none\" === sortOrder) {\r\n                if (column.sortOrder) {\r\n                    options.sortIndex = void 0;\r\n                    options.sortOrder = void 0\r\n                }\r\n            } else {\r\n                ! function(column) {\r\n                    if (\"ctrl\" === sortOrder) {\r\n                        if (!(\"sortOrder\" in column && \"sortIndex\" in column)) {\r\n                            return false\r\n                        }\r\n                        options.sortOrder = void 0;\r\n                        options.sortIndex = void 0\r\n                    } else if (isDefined(column.groupIndex) || isDefined(column.sortIndex)) {\r\n                        options.sortOrder = \"desc\" === column.sortOrder ? \"asc\" : \"desc\"\r\n                    } else {\r\n                        options.sortOrder = \"asc\"\r\n                    }\r\n                    return true\r\n                }(column)\r\n            }\r\n        }\r\n        that.columnOption(column.index, options)\r\n    }\r\n    getSortDataSourceParameters(useLocalSelector) {\r\n        const sortColumns = [];\r\n        const sort = [];\r\n        each(this._columns, (function() {\r\n            if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {\r\n                sortColumns[this.sortIndex] = this\r\n            }\r\n        }));\r\n        each(sortColumns, (function() {\r\n            const sortOrder = this && this.sortOrder;\r\n            if (isSortOrderValid(sortOrder)) {\r\n                const sortItem = {\r\n                    selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,\r\n                    desc: \"desc\" === this.sortOrder\r\n                };\r\n                if (this.sortingMethod) {\r\n                    sortItem.compare = this.sortingMethod.bind(this)\r\n                }\r\n                sort.push(sortItem)\r\n            }\r\n        }));\r\n        return sort.length > 0 ? sort : null\r\n    }\r\n    getGroupDataSourceParameters(useLocalSelector) {\r\n        const group = [];\r\n        each(this.getGroupColumns(), (function() {\r\n            const selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;\r\n            if (selector) {\r\n                const groupItem = {\r\n                    selector: selector,\r\n                    desc: \"desc\" === this.sortOrder,\r\n                    isExpanded: !!this.autoExpandGroup\r\n                };\r\n                if (this.sortingMethod) {\r\n                    groupItem.compare = this.sortingMethod.bind(this)\r\n                }\r\n                group.push(groupItem)\r\n            }\r\n        }));\r\n        return group.length > 0 ? group : null\r\n    }\r\n    refresh(updateNewLookupsOnly) {\r\n        const deferreds = [];\r\n        each(this._columns, (function() {\r\n            const {\r\n                lookup: lookup\r\n            } = this;\r\n            if (lookup && !this.calculateDisplayValue) {\r\n                if (updateNewLookupsOnly && lookup.valueMap) {\r\n                    return\r\n                }\r\n                if (lookup.update) {\r\n                    deferreds.push(lookup.update())\r\n                }\r\n            }\r\n        }));\r\n        return when.apply($, deferreds).done(resetColumnsCache.bind(null, this))\r\n    }\r\n    _updateColumnOptions(column, columnIndex) {\r\n        var _this$_previousColumn, _this$_previousColumn2;\r\n        const shouldTakeOriginalCallbackFromPrevious = this._reinitAfterLookupChanges && (null === (_this$_previousColumn = this._previousColumns) || void 0 === _this$_previousColumn ? void 0 : _this$_previousColumn[columnIndex]);\r\n        column.selector = column.selector ?? (data => column.calculateCellValue(data));\r\n        column.selector.columnIndex = columnIndex;\r\n        column.selector.originalCallback = shouldTakeOriginalCallbackFromPrevious ? (null === (_this$_previousColumn2 = this._previousColumns[columnIndex].selector) || void 0 === _this$_previousColumn2 ? void 0 : _this$_previousColumn2.originalCallback) ?? column.selector : column.selector;\r\n        each([\"calculateSortValue\", \"calculateGroupValue\", \"calculateDisplayValue\"], ((_, calculateCallbackName) => {\r\n            const calculateCallback = column[calculateCallbackName];\r\n            if (isFunction(calculateCallback)) {\r\n                if (!calculateCallback.originalCallback) {\r\n                    const context = {\r\n                        column: column\r\n                    };\r\n                    column[calculateCallbackName] = function(data) {\r\n                        return calculateCallback.call(context.column, data)\r\n                    };\r\n                    column[calculateCallbackName].originalCallback = calculateCallback;\r\n                    column[calculateCallbackName].columnIndex = columnIndex;\r\n                    column[calculateCallbackName].context = context\r\n                } else {\r\n                    column[calculateCallbackName].context.column = column\r\n                }\r\n            }\r\n        }));\r\n        if (isString(column.calculateDisplayValue)) {\r\n            column.displayField = column.calculateDisplayValue;\r\n            column.calculateDisplayValue = compileGetter(column.displayField)\r\n        }\r\n        if (column.calculateDisplayValue) {\r\n            column.displayValueMap = column.displayValueMap || {}\r\n        }\r\n        updateSerializers(column, column.dataType);\r\n        const {\r\n            lookup: lookup\r\n        } = column;\r\n        if (lookup) {\r\n            updateSerializers(lookup, lookup.dataType)\r\n        }\r\n        const dataType = lookup ? lookup.dataType : column.dataType;\r\n        if (dataType) {\r\n            column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option(\"rtlEnabled\"));\r\n            column.format = column.format || gridCoreUtils.getFormatByDataType(dataType);\r\n            column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);\r\n            column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];\r\n            if (!isDefined(column.filterOperations)) {\r\n                setFilterOperationsAsDefaultValues(column)\r\n            }\r\n            column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || \"=\";\r\n            column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : \"boolean\" === dataType && !column.cellTemplate && !column.lookup\r\n        }\r\n    }\r\n    updateColumnDataTypes(dataSource) {\r\n        const that = this;\r\n        const dateSerializationFormat = that.option(\"dateSerializationFormat\");\r\n        const firstItems = that._getFirstItems(dataSource);\r\n        let isColumnDataTypesUpdated = false;\r\n        each(that._columns, ((index, column) => {\r\n            let i;\r\n            let value;\r\n            let dataType;\r\n            let lookupDataType;\r\n            let valueDataType;\r\n            const {\r\n                lookup: lookup\r\n            } = column;\r\n            if (gridCoreUtils.isDateType(column.dataType) && void 0 === column.serializationFormat) {\r\n                column.serializationFormat = dateSerializationFormat\r\n            }\r\n            if (lookup && gridCoreUtils.isDateType(lookup.dataType) && void 0 === column.serializationFormat) {\r\n                lookup.serializationFormat = dateSerializationFormat\r\n            }\r\n            if (column.calculateCellValue && firstItems.length) {\r\n                if (!column.dataType || lookup && !lookup.dataType) {\r\n                    for (i = 0; i < firstItems.length; i++) {\r\n                        value = column.calculateCellValue(firstItems[i]);\r\n                        if (!column.dataType) {\r\n                            valueDataType = getValueDataType(value);\r\n                            dataType = dataType || valueDataType;\r\n                            if (dataType && valueDataType && dataType !== valueDataType) {\r\n                                dataType = \"string\"\r\n                            }\r\n                        }\r\n                        if (lookup && !lookup.dataType) {\r\n                            valueDataType = getValueDataType(gridCoreUtils.getDisplayValue(column, value, firstItems[i]));\r\n                            lookupDataType = lookupDataType || valueDataType;\r\n                            if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {\r\n                                lookupDataType = \"string\"\r\n                            }\r\n                        }\r\n                    }\r\n                    if (dataType || lookupDataType) {\r\n                        if (dataType) {\r\n                            column.dataType = dataType\r\n                        }\r\n                        if (lookup && lookupDataType) {\r\n                            lookup.dataType = lookupDataType\r\n                        }\r\n                        isColumnDataTypesUpdated = true\r\n                    }\r\n                }\r\n                if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {\r\n                    for (i = 0; i < firstItems.length; i++) {\r\n                        value = column.calculateCellValue(firstItems[i], true);\r\n                        if (void 0 === column.serializationFormat) {\r\n                            column.serializationFormat = getSerializationFormat(column.dataType, value)\r\n                        }\r\n                        if (lookup && void 0 === lookup.serializationFormat) {\r\n                            lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true))\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            that._updateColumnOptions(column, index)\r\n        }));\r\n        return isColumnDataTypesUpdated\r\n    }\r\n    _customizeColumns(columns) {\r\n        const that = this;\r\n        const customizeColumns = that.option(\"customizeColumns\");\r\n        if (customizeColumns) {\r\n            const hasOwnerBand = columns.some((column => isObject(column.ownerBand)));\r\n            if (hasOwnerBand) {\r\n                updateIndexes(that)\r\n            }\r\n            customizeColumns(columns);\r\n            assignColumns(that, createColumnsFromOptions(that, columns))\r\n        }\r\n    }\r\n    updateColumns(dataSource, forceApplying, isApplyingUserState) {\r\n        if (!forceApplying) {\r\n            this.updateSortingGrouping(dataSource)\r\n        }\r\n        if (!dataSource || dataSource.isLoaded()) {\r\n            const sortParameters = dataSource ? dataSource.sort() || [] : this.getSortDataSourceParameters();\r\n            const groupParameters = dataSource ? dataSource.group() || [] : this.getGroupDataSourceParameters();\r\n            const filterParameters = null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().filter;\r\n            if (!isApplyingUserState) {\r\n                this._customizeColumns(this._columns)\r\n            }\r\n            updateIndexes(this);\r\n            const columns = this._columns;\r\n            return when(this.refresh(true)).always((() => {\r\n                if (this._columns !== columns) {\r\n                    return\r\n                }\r\n                this._updateChanges(dataSource, {\r\n                    sorting: sortParameters,\r\n                    grouping: groupParameters,\r\n                    filtering: filterParameters\r\n                });\r\n                fireColumnsChanged(this)\r\n            }))\r\n        }\r\n    }\r\n    _updateChanges(dataSource, parameters) {\r\n        var _dataSource$loadOptio;\r\n        const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;\r\n        if (dataSource) {\r\n            this.updateColumnDataTypes(dataSource);\r\n            this._dataSourceApplied = true\r\n        }\r\n        if (!gridCoreUtils.equalSortParameters(parameters.sorting, this.getSortDataSourceParameters())) {\r\n            updateColumnChanges(this, \"sorting\")\r\n        }\r\n        if (!gridCoreUtils.equalSortParameters(parameters.grouping, this.getGroupDataSourceParameters())) {\r\n            updateColumnChanges(this, \"grouping\")\r\n        }\r\n        if (this._dataController && !gridCoreUtils.equalFilterParameters(parameters.filtering, this._dataController.getCombinedFilter(), langParams)) {\r\n            updateColumnChanges(this, \"filtering\")\r\n        }\r\n        updateColumnChanges(this, \"columns\")\r\n    }\r\n    updateSortingGrouping(dataSource, fromDataSource) {\r\n        const that = this;\r\n        let isColumnsChanged;\r\n        const updateSortGroupParameterIndexes = function(columns, sortParameters, indexParameterName) {\r\n            each(columns, ((index, column) => {\r\n                delete column[indexParameterName];\r\n                if (sortParameters) {\r\n                    for (let i = 0; i < sortParameters.length; i++) {\r\n                        const {\r\n                            selector: selector\r\n                        } = sortParameters[i];\r\n                        const {\r\n                            isExpanded: isExpanded\r\n                        } = sortParameters[i];\r\n                        if (selector === column.dataField || selector === column.name || selector === column.displayField || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue || selector === column.calculateDisplayValue) {\r\n                            if (fromDataSource) {\r\n                                column.sortOrder = \"sortOrder\" in column ? column.sortOrder : sortParameters[i].desc ? \"desc\" : \"asc\"\r\n                            } else {\r\n                                column.sortOrder = column.sortOrder || (sortParameters[i].desc ? \"desc\" : \"asc\")\r\n                            }\r\n                            if (void 0 !== isExpanded) {\r\n                                column.autoExpandGroup = isExpanded\r\n                            }\r\n                            column[indexParameterName] = i;\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }))\r\n        };\r\n        if (dataSource) {\r\n            var _this$_columnChanges;\r\n            const sortParameters = gridCoreUtils.normalizeSortingInfo(dataSource.sort());\r\n            const groupParameters = gridCoreUtils.normalizeSortingInfo(dataSource.group());\r\n            const columnsGroupParameters = that.getGroupDataSourceParameters();\r\n            const columnsSortParameters = that.getSortDataSourceParameters();\r\n            const changeTypes = null === (_this$_columnChanges = this._columnChanges) || void 0 === _this$_columnChanges ? void 0 : _this$_columnChanges.changeTypes;\r\n            const sortingChanged = !gridCoreUtils.equalSortParameters(sortParameters, columnsSortParameters);\r\n            const needToApplySortingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.sorting);\r\n            const needToApplyGroupingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.grouping);\r\n            const groupingChanged = !gridCoreUtils.equalSortParameters(groupParameters, columnsGroupParameters, true);\r\n            const groupExpandingChanged = !groupingChanged && !gridCoreUtils.equalSortParameters(groupParameters, columnsGroupParameters);\r\n            if (!that._columns.length) {\r\n                each(groupParameters, ((index, group) => {\r\n                    that._columns.push(group.selector)\r\n                }));\r\n                each(sortParameters, ((index, sort) => {\r\n                    if (!isFunction(sort.selector)) {\r\n                        that._columns.push(sort.selector)\r\n                    }\r\n                }));\r\n                assignColumns(that, createColumnsFromOptions(that, that._columns))\r\n            }\r\n            if ((needToApplyGroupingFromDataSource || !columnsGroupParameters && !that._hasUserState) && (groupingChanged || groupExpandingChanged)) {\r\n                updateSortGroupParameterIndexes(that._columns, groupParameters, \"groupIndex\");\r\n                if (fromDataSource) {\r\n                    groupingChanged && updateColumnChanges(that, \"grouping\");\r\n                    groupExpandingChanged && updateColumnChanges(that, \"groupExpanding\");\r\n                    isColumnsChanged = true\r\n                }\r\n            }\r\n            if ((needToApplySortingFromDataSource || !columnsSortParameters && !that._hasUserState) && sortingChanged) {\r\n                updateSortGroupParameterIndexes(that._columns, sortParameters, \"sortIndex\");\r\n                if (fromDataSource) {\r\n                    updateColumnChanges(that, \"sorting\");\r\n                    isColumnsChanged = true\r\n                }\r\n            }\r\n            if (isColumnsChanged) {\r\n                fireColumnsChanged(that)\r\n            }\r\n        }\r\n    }\r\n    updateFilter(filter, remoteFiltering, columnIndex, filterValue) {\r\n        const that = this;\r\n        if (!Array.isArray(filter)) {\r\n            return filter\r\n        }\r\n        filter = extend([], filter);\r\n        columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;\r\n        filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;\r\n        if (isString(filter[0]) && \"!\" !== filter[0]) {\r\n            const column = that.columnOption(filter[0]);\r\n            if (remoteFiltering) {\r\n                if (config().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {\r\n                    filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], \"filter\")\r\n                }\r\n            } else if (column && column.selector) {\r\n                filter[0] = column.selector;\r\n                filter[0].columnIndex = column.index\r\n            }\r\n        } else if (isFunction(filter[0])) {\r\n            filter[0].columnIndex = columnIndex;\r\n            filter[0].filterValue = filterValue;\r\n            filter[0].selectedFilterOperation = filter.selectedFilterOperation\r\n        }\r\n        for (let i = 0; i < filter.length; i++) {\r\n            filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue)\r\n        }\r\n        return filter\r\n    }\r\n    columnCount() {\r\n        return this._columns ? this._columns.length : 0\r\n    }\r\n    columnOption(identifier, option, value, notFireEvent) {\r\n        const that = this;\r\n        const columns = that._columns.concat(that._commandColumns);\r\n        const column = findColumn(columns, identifier);\r\n        if (column) {\r\n            if (1 === arguments.length) {\r\n                return extend({}, column)\r\n            }\r\n            if (isString(option)) {\r\n                if (2 === arguments.length) {\r\n                    return columnOptionCore(that, column, option)\r\n                }\r\n                columnOptionCore(that, column, option, value, notFireEvent)\r\n            } else if (isObject(option)) {\r\n                each(option, ((optionName, value) => {\r\n                    columnOptionCore(that, column, optionName, value, notFireEvent)\r\n                }))\r\n            }\r\n            fireColumnsChanged(that)\r\n        }\r\n    }\r\n    clearSorting() {\r\n        const that = this;\r\n        const columnCount = this.columnCount();\r\n        that.beginUpdate();\r\n        for (let i = 0; i < columnCount; i++) {\r\n            that.columnOption(i, \"sortOrder\", void 0);\r\n            delete findColumn(that._columns, i).sortOrder\r\n        }\r\n        that.endUpdate()\r\n    }\r\n    clearGrouping() {\r\n        const that = this;\r\n        const columnCount = this.columnCount();\r\n        that.beginUpdate();\r\n        for (let i = 0; i < columnCount; i++) {\r\n            that.columnOption(i, \"groupIndex\", void 0)\r\n        }\r\n        that.endUpdate()\r\n    }\r\n    getVisibleIndex(index, rowIndex) {\r\n        const columns = this.getVisibleColumns(rowIndex);\r\n        for (let i = columns.length - 1; i >= 0; i--) {\r\n            if (columns[i].index === index) {\r\n                return i\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n    getVisibleIndexByColumn(column, rowIndex) {\r\n        const visibleColumns = this.getVisibleColumns(rowIndex);\r\n        const visibleColumn = visibleColumns.filter((col => col.index === column.index && col.command === column.command))[0];\r\n        return visibleColumns.indexOf(visibleColumn)\r\n    }\r\n    getVisibleColumnIndex(id, rowIndex) {\r\n        const index = this.columnOption(id, \"index\");\r\n        return this.getVisibleIndex(index, rowIndex)\r\n    }\r\n    addColumn(options) {\r\n        const that = this;\r\n        let column = createColumn(that, options);\r\n        const index = that._columns.length;\r\n        that._columns.push(column);\r\n        if (column.isBand) {\r\n            that._columns = createColumnsFromOptions(that, that._columns);\r\n            column = that._columns[index]\r\n        }\r\n        column.added = options;\r\n        updateIndexes(that, column);\r\n        that.updateColumns(that._dataSource);\r\n        that._checkColumns()\r\n    }\r\n    deleteColumn(id) {\r\n        const that = this;\r\n        const column = that.columnOption(id);\r\n        if (column && column.index >= 0) {\r\n            convertOwnerBandToColumnReference(that._columns);\r\n            that._columns.splice(column.index, 1);\r\n            if (column.isBand) {\r\n                const childIndexes = that.getChildrenByBandColumn(column.index).map((column => column.index));\r\n                that._columns = that._columns.filter((column => childIndexes.indexOf(column.index) < 0))\r\n            }\r\n            updateIndexes(that);\r\n            that.updateColumns(that._dataSource)\r\n        }\r\n    }\r\n    addCommandColumn(options) {\r\n        let commandColumn = this._commandColumns.filter((column => column.command === options.command))[0];\r\n        if (!commandColumn) {\r\n            commandColumn = options;\r\n            this._commandColumns.push(commandColumn)\r\n        }\r\n    }\r\n    getUserState() {\r\n        const columns = this._columns;\r\n        const result = [];\r\n        let i;\r\n\r\n        function handleStateField(index, value) {\r\n            if (void 0 !== columns[i][value]) {\r\n                result[i][value] = columns[i][value]\r\n            }\r\n        }\r\n        for (i = 0; i < columns.length; i++) {\r\n            result[i] = {};\r\n            each(USER_STATE_FIELD_NAMES, handleStateField)\r\n        }\r\n        return result\r\n    }\r\n    setName(column) {\r\n        column.name = column.name || column.dataField || column.type\r\n    }\r\n    setUserState(state) {\r\n        const that = this;\r\n        const dataSource = that._dataSource;\r\n        let ignoreColumnOptionNames = that.option(\"stateStoring.ignoreColumnOptionNames\");\r\n        null === state || void 0 === state || state.forEach(this.setName);\r\n        if (!ignoreColumnOptionNames) {\r\n            ignoreColumnOptionNames = [];\r\n            const commonColumnSettings = that.getCommonSettings();\r\n            if (!that.option(\"columnChooser.enabled\")) {\r\n                ignoreColumnOptionNames.push(\"visible\")\r\n            }\r\n            if (\"none\" === that.option(\"sorting.mode\")) {\r\n                ignoreColumnOptionNames.push(\"sortIndex\", \"sortOrder\")\r\n            }\r\n            if (!commonColumnSettings.allowGrouping) {\r\n                ignoreColumnOptionNames.push(\"groupIndex\")\r\n            }\r\n            if (!commonColumnSettings.allowFixing) {\r\n                ignoreColumnOptionNames.push(\"fixed\", \"fixedPosition\")\r\n            }\r\n            if (!commonColumnSettings.allowResizing) {\r\n                ignoreColumnOptionNames.push(\"width\", \"visibleWidth\")\r\n            }\r\n            const isFilterPanelHidden = !that.option(\"filterPanel.visible\");\r\n            if (!that.option(\"filterRow.visible\") && isFilterPanelHidden) {\r\n                ignoreColumnOptionNames.push(\"filterValue\", \"selectedFilterOperation\")\r\n            }\r\n            if (!that.option(\"headerFilter.visible\") && isFilterPanelHidden) {\r\n                ignoreColumnOptionNames.push(\"filterValues\", \"filterType\")\r\n            }\r\n        }\r\n        that._columnsUserState = state;\r\n        that._ignoreColumnOptionNames = ignoreColumnOptionNames;\r\n        that._hasUserState = !!state;\r\n        updateColumnChanges(that, \"filtering\");\r\n        that.init(true);\r\n        if (dataSource) {\r\n            dataSource.sort(that.getSortDataSourceParameters());\r\n            dataSource.group(that.getGroupDataSourceParameters())\r\n        }\r\n    }\r\n    _checkColumns() {\r\n        const usedNames = {};\r\n        let hasEditableColumnWithoutName = false;\r\n        const duplicatedNames = [];\r\n        this._columns.forEach((column => {\r\n            var _column$columns;\r\n            const {\r\n                name: name\r\n            } = column;\r\n            const isBand = null === (_column$columns = column.columns) || void 0 === _column$columns ? void 0 : _column$columns.length;\r\n            const isEditable = column.allowEditing && (column.dataField || column.setCellValue) && !isBand;\r\n            if (name) {\r\n                if (usedNames[name]) {\r\n                    duplicatedNames.push(`\"${name}\"`)\r\n                }\r\n                usedNames[name] = true\r\n            } else if (isEditable) {\r\n                hasEditableColumnWithoutName = true\r\n            }\r\n        }));\r\n        if (duplicatedNames.length) {\r\n            errors.log(\"E1059\", duplicatedNames.join(\", \"))\r\n        }\r\n        if (hasEditableColumnWithoutName) {\r\n            errors.log(\"E1060\")\r\n        }\r\n    }\r\n    _createCalculatedColumnOptions(columnOptions, bandColumn) {\r\n        let calculatedColumnOptions = {};\r\n        let {\r\n            dataField: dataField\r\n        } = columnOptions;\r\n        if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {\r\n            calculatedColumnOptions.isBand = true;\r\n            dataField = null\r\n        }\r\n        if (dataField) {\r\n            if (isString(dataField)) {\r\n                const getter = compileGetter(dataField);\r\n                calculatedColumnOptions = {\r\n                    caption: inflector.captionize(dataField),\r\n                    calculateCellValue(data, skipDeserialization) {\r\n                        const value = getter(data);\r\n                        return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value\r\n                    },\r\n                    setCellValue: defaultSetCellValue,\r\n                    parseValue(text) {\r\n                        const column = this;\r\n                        let result;\r\n                        let parsedValue;\r\n                        if (\"number\" === column.dataType) {\r\n                            if (isString(text) && column.format) {\r\n                                result = strictParseNumber(text.trim(), column.format)\r\n                            } else if (isDefined(text) && isNumeric(text)) {\r\n                                result = Number(text)\r\n                            }\r\n                        } else if (\"boolean\" === column.dataType) {\r\n                            if (text === column.trueText) {\r\n                                result = true\r\n                            } else if (text === column.falseText) {\r\n                                result = false\r\n                            }\r\n                        } else if (gridCoreUtils.isDateType(column.dataType)) {\r\n                            parsedValue = dateLocalization.parse(text, column.format);\r\n                            if (parsedValue) {\r\n                                result = parsedValue\r\n                            }\r\n                        } else {\r\n                            result = text\r\n                        }\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n            calculatedColumnOptions.allowFiltering = true\r\n        } else {\r\n            calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression\r\n        }\r\n        calculatedColumnOptions.calculateFilterExpression = function() {\r\n            return filterUtils.defaultCalculateFilterExpression.apply(this, arguments)\r\n        };\r\n        calculatedColumnOptions.defaultFilterOperation = \"=\";\r\n        calculatedColumnOptions.createFilterExpression = function(filterValue, selectedFilterOperation) {\r\n            let result;\r\n            if (this.calculateFilterExpression) {\r\n                result = this.calculateFilterExpression.apply(this, arguments)\r\n            }\r\n            if (isFunction(result)) {\r\n                result = [result, \"=\", true]\r\n            }\r\n            if (result) {\r\n                result.columnIndex = this.index;\r\n                result.filterValue = filterValue;\r\n                result.selectedFilterOperation = selectedFilterOperation\r\n            }\r\n            return result\r\n        };\r\n        if (!dataField || !isString(dataField)) {\r\n            extend(true, calculatedColumnOptions, {\r\n                allowSorting: false,\r\n                allowGrouping: false,\r\n                calculateCellValue: () => null\r\n            })\r\n        }\r\n        if (bandColumn) {\r\n            calculatedColumnOptions.allowFixing = false\r\n        }\r\n        if (columnOptions.dataType) {\r\n            calculatedColumnOptions.userDataType = columnOptions.dataType\r\n        }\r\n        if (columnOptions.selectedFilterOperation && !(\"defaultSelectedFilterOperation\" in calculatedColumnOptions)) {\r\n            calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation\r\n        }\r\n        if (columnOptions.lookup) {\r\n            calculatedColumnOptions.lookup = {\r\n                calculateCellValue(value, skipDeserialization) {\r\n                    if (this.valueExpr) {\r\n                        value = this.valueMap && this.valueMap[value]\r\n                    }\r\n                    return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value\r\n                },\r\n                updateValueMap() {\r\n                    this.valueMap = {};\r\n                    if (this.items) {\r\n                        const calculateValue = compileGetter(this.valueExpr);\r\n                        const calculateDisplayValue = compileGetter(this.displayExpr);\r\n                        for (let i = 0; i < this.items.length; i++) {\r\n                            const item = this.items[i];\r\n                            const displayValue = calculateDisplayValue(item);\r\n                            this.valueMap[calculateValue(item)] = displayValue;\r\n                            this.dataType = this.dataType || getValueDataType(displayValue)\r\n                        }\r\n                    }\r\n                },\r\n                update() {\r\n                    const that = this;\r\n                    let {\r\n                        dataSource: dataSource\r\n                    } = that;\r\n                    if (dataSource) {\r\n                        if (isFunction(dataSource) && !variableWrapper.isWrapped(dataSource)) {\r\n                            dataSource = dataSource({})\r\n                        }\r\n                        if (isPlainObject(dataSource) || dataSource instanceof Store || Array.isArray(dataSource)) {\r\n                            if (that.valueExpr) {\r\n                                const dataSourceOptions = normalizeDataSourceOptions(dataSource);\r\n                                dataSourceOptions.paginate = false;\r\n                                dataSource = new DataSource(dataSourceOptions);\r\n                                return dataSource.load().done((data => {\r\n                                    that.items = data;\r\n                                    that.updateValueMap && that.updateValueMap()\r\n                                }))\r\n                            }\r\n                        } else {\r\n                            errors.log(\"E1016\")\r\n                        }\r\n                    } else {\r\n                        that.updateValueMap && that.updateValueMap()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        calculatedColumnOptions.resizedCallbacks = Callbacks();\r\n        if (columnOptions.resized) {\r\n            calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions))\r\n        }\r\n        each(calculatedColumnOptions, (optionName => {\r\n            if (isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf(\"default\")) {\r\n                const defaultOptionName = `default${optionName.charAt(0).toUpperCase()}${optionName.substr(1)}`;\r\n                calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName]\r\n            }\r\n        }));\r\n        return calculatedColumnOptions\r\n    }\r\n    getRowCount() {\r\n        this._rowCount = this._rowCount || getRowCount(this);\r\n        return this._rowCount\r\n    }\r\n    getRowIndex(columnIndex, alwaysGetRowIndex) {\r\n        const column = this._columns[columnIndex];\r\n        const bandColumnsCache = this.getBandColumnsCache();\r\n        return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0\r\n    }\r\n    getChildrenByBandColumn(bandColumnIndex, onlyVisibleDirectChildren) {\r\n        const bandColumnsCache = this.getBandColumnsCache();\r\n        const result = getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);\r\n        if (onlyVisibleDirectChildren) {\r\n            return result.filter((column => column.visible && !column.command)).sort(((column1, column2) => column1.visibleIndex - column2.visibleIndex))\r\n        }\r\n        return result\r\n    }\r\n    getVisibleDataColumnsByBandColumn(bandColumnIndex) {\r\n        const bandColumnsCache = this.getBandColumnsCache();\r\n        const result = this.getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex);\r\n        return result.filter((column => !column.isBand && column.visible))\r\n    }\r\n    isParentBandColumn(columnIndex, bandColumnIndex) {\r\n        let result = false;\r\n        const column = this._columns[columnIndex];\r\n        const bandColumnsCache = this.getBandColumnsCache();\r\n        const parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\r\n        if (parentBandColumns) {\r\n            each(parentBandColumns, ((_, bandColumn) => {\r\n                if (bandColumn.index === bandColumnIndex) {\r\n                    result = true;\r\n                    return false\r\n                }\r\n            }))\r\n        }\r\n        return result\r\n    }\r\n    isParentColumnVisible(columnIndex) {\r\n        let result = true;\r\n        const bandColumnsCache = this.getBandColumnsCache();\r\n        const bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\r\n        bandColumns && each(bandColumns, ((_, bandColumn) => {\r\n            result = result && bandColumn.visible;\r\n            return result\r\n        }));\r\n        return result\r\n    }\r\n    getParentColumn(column) {\r\n        const bandColumnsCache = this.getBandColumnsCache();\r\n        const bandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);\r\n        return bandColumns[0]\r\n    }\r\n    isFirstColumn(column, rowIndex) {\r\n        let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\r\n        let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;\r\n        return isFirstOrLastColumn(this, column, rowIndex, onlyWithinBandColumn, false, fixedPosition)\r\n    }\r\n    isLastColumn(column, rowIndex) {\r\n        let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\r\n        let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;\r\n        return isFirstOrLastColumn(this, column, rowIndex, onlyWithinBandColumn, true, fixedPosition)\r\n    }\r\n    getColumnId(column) {\r\n        if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {\r\n            if (gridCoreUtils.isCustomCommandColumn(this._columns, column)) {\r\n                return `type:${column.type}`\r\n            }\r\n            return `command:${column.command}`\r\n        }\r\n        return column.index\r\n    }\r\n    getCustomizeTextByDataType(dataType) {\r\n        return getCustomizeTextByDataType(dataType)\r\n    }\r\n    getHeaderContentAlignment(columnAlignment) {\r\n        const rtlEnabled = this.option(\"rtlEnabled\");\r\n        if (rtlEnabled) {\r\n            return \"left\" === columnAlignment ? \"right\" : \"left\"\r\n        }\r\n        return columnAlignment\r\n    }\r\n    isVirtualMode() {\r\n        return false\r\n    }\r\n}\r\nexport const columnsControllerModule = {\r\n    defaultOptions: () => ({\r\n        commonColumnSettings: {\r\n            allowFiltering: true,\r\n            allowHiding: true,\r\n            allowSorting: true,\r\n            allowEditing: true,\r\n            encodeHtml: true,\r\n            trueText: messageLocalization.format(\"dxDataGrid-trueText\"),\r\n            falseText: messageLocalization.format(\"dxDataGrid-falseText\")\r\n        },\r\n        allowColumnReordering: false,\r\n        allowColumnResizing: false,\r\n        columnResizingMode: \"nextColumn\",\r\n        columnMinWidth: void 0,\r\n        columnWidth: void 0,\r\n        adaptColumnWidthByRatio: true,\r\n        columns: void 0,\r\n        regenerateColumnsByVisibleItems: false,\r\n        customizeColumns: null,\r\n        dateSerializationFormat: void 0\r\n    }),\r\n    controllers: {\r\n        columns: ColumnsController\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}