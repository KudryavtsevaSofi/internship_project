{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/m_grouping_core.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { normalizeSortingInfo } from \"../../../../common/data/utils\";\nimport $ from \"../../../../core/renderer\";\nimport { when } from \"../../../../core/utils/deferred\";\nimport gridCore from \"../m_core\";\nexport function createOffsetFilter(path, storeLoadOptions, lastLevelOnly) {\n  const groups = normalizeSortingInfo(storeLoadOptions.group);\n  let filter = [];\n  for (let i = lastLevelOnly ? path.length - 1 : 0; i < path.length; i++) {\n    const filterElement = [];\n    for (let j = 0; j <= i; j++) {\n      const {\n        selector: selector\n      } = groups[j];\n      if (i === j && (null === path[j] || false === path[j] || true === path[j])) {\n        if (false === path[j]) {\n          filterElement.push([selector, \"=\", groups[j].desc ? true : null]);\n        } else if (path[j] ? !groups[j].desc : groups[j].desc) {\n          filterElement.push([selector, \"<>\", path[j]]);\n        } else {\n          filterElement.push([selector, \"<>\", null]);\n          filterElement.push([selector, \"=\", null]);\n        }\n      } else {\n        const currentFilter = [selector, i === j ? groups[j].desc ? \">\" : \"<\" : \"=\", path[j]];\n        if (\"<\" === currentFilter[1]) {\n          filterElement.push([currentFilter, \"or\", [selector, \"=\", null]]);\n        } else {\n          filterElement.push(currentFilter);\n        }\n      }\n    }\n    filter.push(gridCore.combineFilters(filterElement));\n  }\n  filter = gridCore.combineFilters(filter, \"or\");\n  return gridCore.combineFilters([filter, storeLoadOptions.filter]);\n}\nconst findGroupInfoByKey = function (groupsInfo, key) {\n  const {\n    hash: hash\n  } = groupsInfo;\n  return hash && hash[JSON.stringify(key)];\n};\nconst getGroupInfoIndexByOffset = function (groupsInfo, offset) {\n  let leftIndex = 0;\n  let rightIndex = groupsInfo.length - 1;\n  if (!groupsInfo.length) {\n    return 0;\n  }\n  do {\n    const middleIndex = rightIndex + leftIndex >> 1;\n    if (groupsInfo[middleIndex].offset > offset) {\n      rightIndex = middleIndex;\n    } else {\n      leftIndex = middleIndex;\n    }\n  } while (rightIndex - leftIndex > 1);\n  let index;\n  for (index = leftIndex; index <= rightIndex; index++) {\n    if (groupsInfo[index].offset > offset) {\n      break;\n    }\n  }\n  return index;\n};\nconst cleanGroupsInfo = function (groupsInfo, groupIndex, groupsCount) {\n  for (let i = 0; i < groupsInfo.length; i++) {\n    if (groupIndex + 1 >= groupsCount) {\n      groupsInfo[i].children = [];\n    } else {\n      cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount);\n    }\n  }\n};\nconst calculateItemsCount = function (that, items, groupsCount) {\n  let result = 0;\n  if (items) {\n    if (!groupsCount) {\n      result = items.length;\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        if (that.isGroupItemCountable(items[i])) {\n          result++;\n        }\n        result += calculateItemsCount(that, items[i].items, groupsCount - 1);\n      }\n    }\n  }\n  return result;\n};\nexport class GroupingHelper {\n  constructor(dataSourceAdapter) {\n    this._dataSource = dataSourceAdapter;\n    this.reset();\n  }\n  reset() {\n    this._groupsInfo = [];\n    this._totalCountCorrection = 0;\n  }\n  totalCountCorrection() {\n    return this._totalCountCorrection;\n  }\n  updateTotalItemsCount(totalCountCorrection) {\n    this._totalCountCorrection = totalCountCorrection || 0;\n  }\n  isGroupItemCountable(item) {\n    return !this._isVirtualPaging() || !item.isContinuation;\n  }\n  _isVirtualPaging() {\n    const scrollingMode = this._dataSource.option(\"scrolling.mode\");\n    return \"virtual\" === scrollingMode || \"infinite\" === scrollingMode;\n  }\n  itemsCount() {\n    const dataSourceAdapter = this._dataSource;\n    const dataSource = dataSourceAdapter._dataSource;\n    const groupCount = gridCore.normalizeSortingInfo(dataSource.group() || []).length;\n    const itemsCount = calculateItemsCount(this, dataSource.items(), groupCount);\n    return itemsCount;\n  }\n  foreachGroups(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets, updateParentOffsets) {\n    const that = this;\n    return function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {\n      const callbackResults = [];\n      function executeCallback(callback, data, parents, callbackResults) {\n        const callbackResult = data && callback(data, parents);\n        callbackResult && callbackResults.push(callbackResult);\n        return callbackResult;\n      }\n      for (let i = 0; i < groupsInfo.length; i++) {\n        parents.push(groupsInfo[i].data);\n        if (!childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\n          return false;\n        }\n        if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {\n          const {\n            children: children\n          } = groupsInfo[i];\n          const callbackResult = children.length && foreachGroupsCore(children, callback, childrenAtFirst, parents);\n          callbackResult && callbackResults.push(callbackResult);\n          if (false === callbackResult) {\n            return false;\n          }\n        }\n        if (childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\n          return false;\n        }\n        if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {\n          updateOffsets = true;\n        }\n        parents.pop();\n      }\n      const currentParents = updateParentOffsets && parents.slice(0);\n      return updateOffsets && when.apply($, callbackResults).always(() => {\n        that._updateGroupInfoOffsets(groupsInfo, currentParents);\n      });\n    }(that._groupsInfo, callback, childrenAtFirst, []);\n  }\n  _updateGroupInfoOffsets(groupsInfo, parents) {\n    parents = parents || [];\n    for (let index = 0; index < groupsInfo.length; index++) {\n      const groupInfo = groupsInfo[index];\n      if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {\n        groupInfo.offset = groupInfo.data.offset;\n        for (let parentIndex = 0; parentIndex < parents.length; parentIndex++) {\n          parents[parentIndex].offset = groupInfo.offset;\n        }\n      }\n    }\n    groupsInfo.sort((a, b) => a.offset - b.offset);\n  }\n  findGroupInfo(path) {\n    let groupInfo;\n    let groupsInfo = this._groupsInfo;\n    for (let pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {\n      groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\n      groupsInfo = groupInfo && groupInfo.children;\n    }\n    return groupInfo && groupInfo.data;\n  }\n  addGroupInfo(groupInfoData) {\n    const that = this;\n    let groupInfo;\n    const {\n      path: path\n    } = groupInfoData;\n    let groupsInfo = that._groupsInfo;\n    for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {\n      groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\n      if (!groupInfo) {\n        groupInfo = {\n          key: path[pathIndex],\n          offset: groupInfoData.offset,\n          data: {\n            offset: groupInfoData.offset,\n            isExpanded: true,\n            path: path.slice(0, pathIndex + 1)\n          },\n          children: []\n        };\n        const index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);\n        groupsInfo.splice(index, 0, groupInfo);\n        groupsInfo.hash = groupsInfo.hash || {};\n        groupsInfo.hash[JSON.stringify(groupInfo.key)] = groupInfo;\n      }\n      if (pathIndex === path.length - 1) {\n        groupInfo.data = groupInfoData;\n        if (groupInfo.offset !== groupInfoData.offset) {\n          that._updateGroupInfoOffsets(groupsInfo);\n        }\n      }\n      groupsInfo = groupInfo.children;\n    }\n  }\n  allowCollapseAll() {\n    return true;\n  }\n  refresh(options) {\n    const that = this;\n    const {\n      storeLoadOptions: storeLoadOptions\n    } = options;\n    const groups = normalizeSortingInfo(storeLoadOptions.group || []);\n    const oldGroups = \"_group\" in that ? normalizeSortingInfo(that._group || []) : groups;\n    let groupsCount = Math.min(oldGroups.length, groups.length);\n    that._group = storeLoadOptions.group;\n    for (let groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n      if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {\n        groupsCount = groupIndex;\n        break;\n      }\n    }\n    if (!groupsCount) {\n      that.reset();\n    } else {\n      cleanGroupsInfo(that._groupsInfo, 0, groupsCount);\n    }\n  }\n  handleDataLoading() {}\n  handleDataLoaded(options, callBase) {\n    callBase(options);\n  }\n  handleDataLoadedCore(options, callBase) {\n    callBase(options);\n  }\n}","map":{"version":3,"names":["normalizeSortingInfo","$","when","gridCore","createOffsetFilter","path","storeLoadOptions","lastLevelOnly","groups","group","filter","i","length","filterElement","j","selector","push","desc","currentFilter","combineFilters","findGroupInfoByKey","groupsInfo","key","hash","JSON","stringify","getGroupInfoIndexByOffset","offset","leftIndex","rightIndex","middleIndex","index","cleanGroupsInfo","groupIndex","groupsCount","children","calculateItemsCount","that","items","result","isGroupItemCountable","GroupingHelper","constructor","dataSourceAdapter","_dataSource","reset","_groupsInfo","_totalCountCorrection","totalCountCorrection","updateTotalItemsCount","item","_isVirtualPaging","isContinuation","scrollingMode","option","itemsCount","dataSource","groupCount","foreachGroups","callback","childrenAtFirst","foreachCollapsedGroups","updateOffsets","updateParentOffsets","foreachGroupsCore","parents","callbackResults","executeCallback","data","callbackResult","isExpanded","pop","currentParents","slice","apply","always","_updateGroupInfoOffsets","groupInfo","parentIndex","sort","a","b","findGroupInfo","pathIndex","addGroupInfo","groupInfoData","splice","allowCollapseAll","refresh","options","oldGroups","_group","Math","min","handleDataLoading","handleDataLoaded","callBase","handleDataLoadedCore"],"sources":["C:/Users/Sofia/Desktop/Репозиторий ЦК/internship_project/client/node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_core.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/m_grouping_core.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    normalizeSortingInfo\r\n} from \"../../../../common/data/utils\";\r\nimport $ from \"../../../../core/renderer\";\r\nimport {\r\n    when\r\n} from \"../../../../core/utils/deferred\";\r\nimport gridCore from \"../m_core\";\r\nexport function createOffsetFilter(path, storeLoadOptions, lastLevelOnly) {\r\n    const groups = normalizeSortingInfo(storeLoadOptions.group);\r\n    let filter = [];\r\n    for (let i = lastLevelOnly ? path.length - 1 : 0; i < path.length; i++) {\r\n        const filterElement = [];\r\n        for (let j = 0; j <= i; j++) {\r\n            const {\r\n                selector: selector\r\n            } = groups[j];\r\n            if (i === j && (null === path[j] || false === path[j] || true === path[j])) {\r\n                if (false === path[j]) {\r\n                    filterElement.push([selector, \"=\", groups[j].desc ? true : null])\r\n                } else if (path[j] ? !groups[j].desc : groups[j].desc) {\r\n                    filterElement.push([selector, \"<>\", path[j]])\r\n                } else {\r\n                    filterElement.push([selector, \"<>\", null]);\r\n                    filterElement.push([selector, \"=\", null])\r\n                }\r\n            } else {\r\n                const currentFilter = [selector, i === j ? groups[j].desc ? \">\" : \"<\" : \"=\", path[j]];\r\n                if (\"<\" === currentFilter[1]) {\r\n                    filterElement.push([currentFilter, \"or\", [selector, \"=\", null]])\r\n                } else {\r\n                    filterElement.push(currentFilter)\r\n                }\r\n            }\r\n        }\r\n        filter.push(gridCore.combineFilters(filterElement))\r\n    }\r\n    filter = gridCore.combineFilters(filter, \"or\");\r\n    return gridCore.combineFilters([filter, storeLoadOptions.filter])\r\n}\r\nconst findGroupInfoByKey = function(groupsInfo, key) {\r\n    const {\r\n        hash: hash\r\n    } = groupsInfo;\r\n    return hash && hash[JSON.stringify(key)]\r\n};\r\nconst getGroupInfoIndexByOffset = function(groupsInfo, offset) {\r\n    let leftIndex = 0;\r\n    let rightIndex = groupsInfo.length - 1;\r\n    if (!groupsInfo.length) {\r\n        return 0\r\n    }\r\n    do {\r\n        const middleIndex = rightIndex + leftIndex >> 1;\r\n        if (groupsInfo[middleIndex].offset > offset) {\r\n            rightIndex = middleIndex\r\n        } else {\r\n            leftIndex = middleIndex\r\n        }\r\n    } while (rightIndex - leftIndex > 1);\r\n    let index;\r\n    for (index = leftIndex; index <= rightIndex; index++) {\r\n        if (groupsInfo[index].offset > offset) {\r\n            break\r\n        }\r\n    }\r\n    return index\r\n};\r\nconst cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {\r\n    for (let i = 0; i < groupsInfo.length; i++) {\r\n        if (groupIndex + 1 >= groupsCount) {\r\n            groupsInfo[i].children = []\r\n        } else {\r\n            cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount)\r\n        }\r\n    }\r\n};\r\nconst calculateItemsCount = function(that, items, groupsCount) {\r\n    let result = 0;\r\n    if (items) {\r\n        if (!groupsCount) {\r\n            result = items.length\r\n        } else {\r\n            for (let i = 0; i < items.length; i++) {\r\n                if (that.isGroupItemCountable(items[i])) {\r\n                    result++\r\n                }\r\n                result += calculateItemsCount(that, items[i].items, groupsCount - 1)\r\n            }\r\n        }\r\n    }\r\n    return result\r\n};\r\nexport class GroupingHelper {\r\n    constructor(dataSourceAdapter) {\r\n        this._dataSource = dataSourceAdapter;\r\n        this.reset()\r\n    }\r\n    reset() {\r\n        this._groupsInfo = [];\r\n        this._totalCountCorrection = 0\r\n    }\r\n    totalCountCorrection() {\r\n        return this._totalCountCorrection\r\n    }\r\n    updateTotalItemsCount(totalCountCorrection) {\r\n        this._totalCountCorrection = totalCountCorrection || 0\r\n    }\r\n    isGroupItemCountable(item) {\r\n        return !this._isVirtualPaging() || !item.isContinuation\r\n    }\r\n    _isVirtualPaging() {\r\n        const scrollingMode = this._dataSource.option(\"scrolling.mode\");\r\n        return \"virtual\" === scrollingMode || \"infinite\" === scrollingMode\r\n    }\r\n    itemsCount() {\r\n        const dataSourceAdapter = this._dataSource;\r\n        const dataSource = dataSourceAdapter._dataSource;\r\n        const groupCount = gridCore.normalizeSortingInfo(dataSource.group() || []).length;\r\n        const itemsCount = calculateItemsCount(this, dataSource.items(), groupCount);\r\n        return itemsCount\r\n    }\r\n    foreachGroups(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets, updateParentOffsets) {\r\n        const that = this;\r\n        return function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {\r\n            const callbackResults = [];\r\n\r\n            function executeCallback(callback, data, parents, callbackResults) {\r\n                const callbackResult = data && callback(data, parents);\r\n                callbackResult && callbackResults.push(callbackResult);\r\n                return callbackResult\r\n            }\r\n            for (let i = 0; i < groupsInfo.length; i++) {\r\n                parents.push(groupsInfo[i].data);\r\n                if (!childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\r\n                    return false\r\n                }\r\n                if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {\r\n                    const {\r\n                        children: children\r\n                    } = groupsInfo[i];\r\n                    const callbackResult = children.length && foreachGroupsCore(children, callback, childrenAtFirst, parents);\r\n                    callbackResult && callbackResults.push(callbackResult);\r\n                    if (false === callbackResult) {\r\n                        return false\r\n                    }\r\n                }\r\n                if (childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\r\n                    return false\r\n                }\r\n                if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {\r\n                    updateOffsets = true\r\n                }\r\n                parents.pop()\r\n            }\r\n            const currentParents = updateParentOffsets && parents.slice(0);\r\n            return updateOffsets && when.apply($, callbackResults).always((() => {\r\n                that._updateGroupInfoOffsets(groupsInfo, currentParents)\r\n            }))\r\n        }(that._groupsInfo, callback, childrenAtFirst, [])\r\n    }\r\n    _updateGroupInfoOffsets(groupsInfo, parents) {\r\n        parents = parents || [];\r\n        for (let index = 0; index < groupsInfo.length; index++) {\r\n            const groupInfo = groupsInfo[index];\r\n            if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {\r\n                groupInfo.offset = groupInfo.data.offset;\r\n                for (let parentIndex = 0; parentIndex < parents.length; parentIndex++) {\r\n                    parents[parentIndex].offset = groupInfo.offset\r\n                }\r\n            }\r\n        }\r\n        groupsInfo.sort(((a, b) => a.offset - b.offset))\r\n    }\r\n    findGroupInfo(path) {\r\n        let groupInfo;\r\n        let groupsInfo = this._groupsInfo;\r\n        for (let pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {\r\n            groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\r\n            groupsInfo = groupInfo && groupInfo.children\r\n        }\r\n        return groupInfo && groupInfo.data\r\n    }\r\n    addGroupInfo(groupInfoData) {\r\n        const that = this;\r\n        let groupInfo;\r\n        const {\r\n            path: path\r\n        } = groupInfoData;\r\n        let groupsInfo = that._groupsInfo;\r\n        for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {\r\n            groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\r\n            if (!groupInfo) {\r\n                groupInfo = {\r\n                    key: path[pathIndex],\r\n                    offset: groupInfoData.offset,\r\n                    data: {\r\n                        offset: groupInfoData.offset,\r\n                        isExpanded: true,\r\n                        path: path.slice(0, pathIndex + 1)\r\n                    },\r\n                    children: []\r\n                };\r\n                const index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);\r\n                groupsInfo.splice(index, 0, groupInfo);\r\n                groupsInfo.hash = groupsInfo.hash || {};\r\n                groupsInfo.hash[JSON.stringify(groupInfo.key)] = groupInfo\r\n            }\r\n            if (pathIndex === path.length - 1) {\r\n                groupInfo.data = groupInfoData;\r\n                if (groupInfo.offset !== groupInfoData.offset) {\r\n                    that._updateGroupInfoOffsets(groupsInfo)\r\n                }\r\n            }\r\n            groupsInfo = groupInfo.children\r\n        }\r\n    }\r\n    allowCollapseAll() {\r\n        return true\r\n    }\r\n    refresh(options) {\r\n        const that = this;\r\n        const {\r\n            storeLoadOptions: storeLoadOptions\r\n        } = options;\r\n        const groups = normalizeSortingInfo(storeLoadOptions.group || []);\r\n        const oldGroups = \"_group\" in that ? normalizeSortingInfo(that._group || []) : groups;\r\n        let groupsCount = Math.min(oldGroups.length, groups.length);\r\n        that._group = storeLoadOptions.group;\r\n        for (let groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\r\n            if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {\r\n                groupsCount = groupIndex;\r\n                break\r\n            }\r\n        }\r\n        if (!groupsCount) {\r\n            that.reset()\r\n        } else {\r\n            cleanGroupsInfo(that._groupsInfo, 0, groupsCount)\r\n        }\r\n    }\r\n    handleDataLoading() {}\r\n    handleDataLoaded(options, callBase) {\r\n        callBase(options)\r\n    }\r\n    handleDataLoadedCore(options, callBase) {\r\n        callBase(options)\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}