{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/data_grid/m_aggregate_calculator.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { errors } from \"../../../common/data/errors\";\nimport { aggregators } from \"../../../common/data/utils\";\nimport { compileGetter } from \"../../../core/utils/data\";\nimport { isFunction } from \"../../../core/utils/type\";\nfunction depthFirstSearch(i, depth, root, callback) {\n  let j = 0;\n  if (i < depth) {\n    for (; j < root.items.length; j++) {\n      depthFirstSearch(i + 1, depth, root.items[j], callback);\n    }\n  }\n  if (i === depth) {\n    callback(root);\n  }\n}\nfunction map(array, callback) {\n  let i;\n  if (\"map\" in array) {\n    return array.map(callback);\n  }\n  const result = new Array(array.length);\n  for (i in array) {\n    result[i] = callback(array[i], i);\n  }\n  return result;\n}\nfunction isEmpty(x) {\n  return x !== x || \"\" === x || null === x || void 0 === x;\n}\nfunction isCount(aggregator) {\n  return aggregator === aggregators.count;\n}\nfunction normalizeAggregate(aggregate) {\n  const selector = compileGetter(aggregate.selector);\n  const skipEmptyValues = \"skipEmptyValues\" in aggregate ? aggregate.skipEmptyValues : true;\n  let {\n    aggregator: aggregator\n  } = aggregate;\n  if (\"string\" === typeof aggregator) {\n    aggregator = aggregators[aggregator];\n    if (!aggregator) {\n      throw errors.Error(\"E4001\", aggregate.aggregator);\n    }\n  }\n  return {\n    selector: selector,\n    aggregator: aggregator,\n    skipEmptyValues: skipEmptyValues\n  };\n}\nexport default class AggregateCalculator {\n  constructor(options) {\n    this._data = options.data;\n    this._groupLevel = options.groupLevel || 0;\n    this._totalAggregates = map(options.totalAggregates || [], normalizeAggregate);\n    this._groupAggregates = map(options.groupAggregates || [], normalizeAggregate);\n    this._totals = [];\n  }\n  calculate() {\n    if (this._totalAggregates.length) {\n      this._calculateTotals(0, {\n        items: this._data\n      });\n    }\n    if (this._groupAggregates.length && this._groupLevel > 0) {\n      this._calculateGroups({\n        items: this._data\n      });\n    }\n  }\n  totalAggregates() {\n    return this._totals;\n  }\n  _aggregate(aggregates, data, container) {\n    const length = data.items ? data.items.length : 0;\n    for (let i = 0; i < aggregates.length; i++) {\n      if (isCount(aggregates[i].aggregator)) {\n        container[i] = (container[i] || 0) + length;\n        continue;\n      }\n      for (let j = 0; j < length; j++) {\n        this._accumulate(i, aggregates[i], container, data.items[j]);\n      }\n    }\n  }\n  _calculateTotals(level, data) {\n    if (0 === level) {\n      this._totals = this._seed(this._totalAggregates);\n    }\n    if (level === this._groupLevel) {\n      this._aggregate(this._totalAggregates, data, this._totals);\n    } else {\n      for (let i = 0; i < data.items.length; i++) {\n        this._calculateTotals(level + 1, data.items[i]);\n      }\n    }\n    if (0 === level) {\n      this._totals = this._finalize(this._totalAggregates, this._totals);\n    }\n  }\n  _calculateGroups(root) {\n    const maxLevel = this._groupLevel;\n    let currentLevel = maxLevel + 1;\n    const seedFn = this._seed.bind(this, this._groupAggregates);\n    const stepFn = this._aggregate.bind(this, this._groupAggregates);\n    const finalizeFn = this._finalize.bind(this, this._groupAggregates);\n    function aggregator(node) {\n      node.aggregates = seedFn(currentLevel - 1);\n      if (currentLevel === maxLevel) {\n        stepFn(node, node.aggregates);\n      } else {\n        depthFirstSearch(currentLevel, maxLevel, node, innerNode => {\n          stepFn(innerNode, node.aggregates);\n        });\n      }\n      node.aggregates = finalizeFn(node.aggregates);\n    }\n    while (--currentLevel > 0) {\n      depthFirstSearch(0, currentLevel, root, aggregator);\n    }\n  }\n  _seed(aggregates, groupIndex) {\n    return map(aggregates, aggregate => {\n      const {\n        aggregator: aggregator\n      } = aggregate;\n      const seed = \"seed\" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;\n      return seed;\n    });\n  }\n  _accumulate(aggregateIndex, aggregate, results, item) {\n    const value = aggregate.selector(item);\n    const {\n      aggregator: aggregator\n    } = aggregate;\n    const {\n      skipEmptyValues: skipEmptyValues\n    } = aggregate;\n    if (skipEmptyValues && isEmpty(value)) {\n      return;\n    }\n    if (results[aggregateIndex] !== results[aggregateIndex]) {\n      results[aggregateIndex] = value;\n    } else {\n      results[aggregateIndex] = aggregator.step(results[aggregateIndex], value);\n    }\n  }\n  _finalize(aggregates, results) {\n    return map(aggregates, (aggregate, index) => {\n      const fin = aggregate.aggregator.finalize;\n      return fin ? fin(results[index]) : results[index];\n    });\n  }\n}","map":{"version":3,"names":["errors","aggregators","compileGetter","isFunction","depthFirstSearch","i","depth","root","callback","j","items","length","map","array","result","Array","isEmpty","x","isCount","aggregator","count","normalizeAggregate","aggregate","selector","skipEmptyValues","Error","AggregateCalculator","constructor","options","_data","data","_groupLevel","groupLevel","_totalAggregates","totalAggregates","_groupAggregates","groupAggregates","_totals","calculate","_calculateTotals","_calculateGroups","_aggregate","aggregates","container","_accumulate","level","_seed","_finalize","maxLevel","currentLevel","seedFn","bind","stepFn","finalizeFn","node","innerNode","groupIndex","seed","NaN","aggregateIndex","results","item","value","step","index","fin","finalize"],"sources":["C:/Users/Sofia/Desktop/Репозиторий ЦК/internship_project/client/node_modules/devextreme/esm/__internal/grids/data_grid/m_aggregate_calculator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/data_grid/m_aggregate_calculator.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    errors\r\n} from \"../../../common/data/errors\";\r\nimport {\r\n    aggregators\r\n} from \"../../../common/data/utils\";\r\nimport {\r\n    compileGetter\r\n} from \"../../../core/utils/data\";\r\nimport {\r\n    isFunction\r\n} from \"../../../core/utils/type\";\r\n\r\nfunction depthFirstSearch(i, depth, root, callback) {\r\n    let j = 0;\r\n    if (i < depth) {\r\n        for (; j < root.items.length; j++) {\r\n            depthFirstSearch(i + 1, depth, root.items[j], callback)\r\n        }\r\n    }\r\n    if (i === depth) {\r\n        callback(root)\r\n    }\r\n}\r\n\r\nfunction map(array, callback) {\r\n    let i;\r\n    if (\"map\" in array) {\r\n        return array.map(callback)\r\n    }\r\n    const result = new Array(array.length);\r\n    for (i in array) {\r\n        result[i] = callback(array[i], i)\r\n    }\r\n    return result\r\n}\r\n\r\nfunction isEmpty(x) {\r\n    return x !== x || \"\" === x || null === x || void 0 === x\r\n}\r\n\r\nfunction isCount(aggregator) {\r\n    return aggregator === aggregators.count\r\n}\r\n\r\nfunction normalizeAggregate(aggregate) {\r\n    const selector = compileGetter(aggregate.selector);\r\n    const skipEmptyValues = \"skipEmptyValues\" in aggregate ? aggregate.skipEmptyValues : true;\r\n    let {\r\n        aggregator: aggregator\r\n    } = aggregate;\r\n    if (\"string\" === typeof aggregator) {\r\n        aggregator = aggregators[aggregator];\r\n        if (!aggregator) {\r\n            throw errors.Error(\"E4001\", aggregate.aggregator)\r\n        }\r\n    }\r\n    return {\r\n        selector: selector,\r\n        aggregator: aggregator,\r\n        skipEmptyValues: skipEmptyValues\r\n    }\r\n}\r\nexport default class AggregateCalculator {\r\n    constructor(options) {\r\n        this._data = options.data;\r\n        this._groupLevel = options.groupLevel || 0;\r\n        this._totalAggregates = map(options.totalAggregates || [], normalizeAggregate);\r\n        this._groupAggregates = map(options.groupAggregates || [], normalizeAggregate);\r\n        this._totals = []\r\n    }\r\n    calculate() {\r\n        if (this._totalAggregates.length) {\r\n            this._calculateTotals(0, {\r\n                items: this._data\r\n            })\r\n        }\r\n        if (this._groupAggregates.length && this._groupLevel > 0) {\r\n            this._calculateGroups({\r\n                items: this._data\r\n            })\r\n        }\r\n    }\r\n    totalAggregates() {\r\n        return this._totals\r\n    }\r\n    _aggregate(aggregates, data, container) {\r\n        const length = data.items ? data.items.length : 0;\r\n        for (let i = 0; i < aggregates.length; i++) {\r\n            if (isCount(aggregates[i].aggregator)) {\r\n                container[i] = (container[i] || 0) + length;\r\n                continue\r\n            }\r\n            for (let j = 0; j < length; j++) {\r\n                this._accumulate(i, aggregates[i], container, data.items[j])\r\n            }\r\n        }\r\n    }\r\n    _calculateTotals(level, data) {\r\n        if (0 === level) {\r\n            this._totals = this._seed(this._totalAggregates)\r\n        }\r\n        if (level === this._groupLevel) {\r\n            this._aggregate(this._totalAggregates, data, this._totals)\r\n        } else {\r\n            for (let i = 0; i < data.items.length; i++) {\r\n                this._calculateTotals(level + 1, data.items[i])\r\n            }\r\n        }\r\n        if (0 === level) {\r\n            this._totals = this._finalize(this._totalAggregates, this._totals)\r\n        }\r\n    }\r\n    _calculateGroups(root) {\r\n        const maxLevel = this._groupLevel;\r\n        let currentLevel = maxLevel + 1;\r\n        const seedFn = this._seed.bind(this, this._groupAggregates);\r\n        const stepFn = this._aggregate.bind(this, this._groupAggregates);\r\n        const finalizeFn = this._finalize.bind(this, this._groupAggregates);\r\n\r\n        function aggregator(node) {\r\n            node.aggregates = seedFn(currentLevel - 1);\r\n            if (currentLevel === maxLevel) {\r\n                stepFn(node, node.aggregates)\r\n            } else {\r\n                depthFirstSearch(currentLevel, maxLevel, node, (innerNode => {\r\n                    stepFn(innerNode, node.aggregates)\r\n                }))\r\n            }\r\n            node.aggregates = finalizeFn(node.aggregates)\r\n        }\r\n        while (--currentLevel > 0) {\r\n            depthFirstSearch(0, currentLevel, root, aggregator)\r\n        }\r\n    }\r\n    _seed(aggregates, groupIndex) {\r\n        return map(aggregates, (aggregate => {\r\n            const {\r\n                aggregator: aggregator\r\n            } = aggregate;\r\n            const seed = \"seed\" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;\r\n            return seed\r\n        }))\r\n    }\r\n    _accumulate(aggregateIndex, aggregate, results, item) {\r\n        const value = aggregate.selector(item);\r\n        const {\r\n            aggregator: aggregator\r\n        } = aggregate;\r\n        const {\r\n            skipEmptyValues: skipEmptyValues\r\n        } = aggregate;\r\n        if (skipEmptyValues && isEmpty(value)) {\r\n            return\r\n        }\r\n        if (results[aggregateIndex] !== results[aggregateIndex]) {\r\n            results[aggregateIndex] = value\r\n        } else {\r\n            results[aggregateIndex] = aggregator.step(results[aggregateIndex], value)\r\n        }\r\n    }\r\n    _finalize(aggregates, results) {\r\n        return map(aggregates, ((aggregate, index) => {\r\n            const fin = aggregate.aggregator.finalize;\r\n            return fin ? fin(results[index]) : results[index]\r\n        }))\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}