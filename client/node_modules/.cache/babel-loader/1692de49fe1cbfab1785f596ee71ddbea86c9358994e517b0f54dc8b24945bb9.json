{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/m_grouping_expanded.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dataQuery from \"../../../../common/data/query\";\nimport storeHelper from \"../../../../common/data/store_helper\";\nimport { keysEqual } from \"../../../../common/data/utils\";\nimport { toComparable } from \"../../../../core/utils/data\";\nimport { Deferred, when } from \"../../../../core/utils/deferred\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport { each } from \"../../../../core/utils/iterator\";\nimport dataGridCore from \"../m_core\";\nimport { createGroupFilter } from \"../m_utils\";\nimport { createOffsetFilter, GroupingHelper as GroupingHelperCore } from \"./m_grouping_core\";\nconst loadTotalCount = function (dataSource, options) {\n  const d = new Deferred();\n  const loadOptions = extend({\n    skip: 0,\n    take: 1,\n    requireTotalCount: true\n  }, options);\n  dataSource.load(loadOptions).done((data, extra) => {\n    d.resolve(extra && extra.totalCount);\n  }).fail(d.reject.bind(d));\n  return d;\n};\nconst foreachCollapsedGroups = function (that, callback, updateOffsets) {\n  return that.foreachGroups(groupInfo => {\n    if (!groupInfo.isExpanded) {\n      return callback(groupInfo);\n    }\n  }, false, false, updateOffsets, true);\n};\nconst correctSkipLoadOption = function (that, skip) {\n  let skipCorrection = 0;\n  let resultSkip = skip || 0;\n  if (skip) {\n    foreachCollapsedGroups(that, groupInfo => {\n      if (groupInfo.offset - skipCorrection >= skip) {\n        return false;\n      }\n      skipCorrection += groupInfo.count - 1;\n    });\n    resultSkip += skipCorrection;\n  }\n  return resultSkip;\n};\nconst processGroupItems = function (that, items, path, offset, skipFirstItem, take) {\n  let removeLastItemsCount = 0;\n  let needRemoveFirstItem = false;\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    if (void 0 !== item.items) {\n      path.push(item.key);\n      const groupInfo = that.findGroupInfo(path);\n      if (groupInfo && !groupInfo.isExpanded) {\n        item.collapsedItems = item.items;\n        item.items = null;\n        offset += groupInfo.count;\n        take--;\n        if (take < 0) {\n          removeLastItemsCount++;\n        }\n        if (skipFirstItem) {\n          needRemoveFirstItem = true;\n        }\n      } else if (item.items) {\n        const offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);\n        if (skipFirstItem) {\n          if (offsetInfo.offset - offset > 1) {\n            item.isContinuation = true;\n          } else {\n            needRemoveFirstItem = true;\n          }\n        }\n        offset = offsetInfo.offset;\n        take = offsetInfo.take;\n        if (take < 0) {\n          if (item.items.length) {\n            item.isContinuationOnNextPage = true;\n          } else {\n            removeLastItemsCount++;\n          }\n        }\n      }\n      path.pop();\n    } else {\n      if (skipFirstItem) {\n        needRemoveFirstItem = true;\n      }\n      offset++;\n      take--;\n      if (take < 0) {\n        removeLastItemsCount++;\n      }\n    }\n    skipFirstItem = false;\n  }\n  if (needRemoveFirstItem) {\n    items.splice(0, 1);\n  }\n  if (removeLastItemsCount) {\n    items.splice(-removeLastItemsCount, removeLastItemsCount);\n  }\n  return {\n    offset: offset,\n    take: take\n  };\n};\nconst pathEquals = function (path1, path2) {\n  if (path1.length !== path2.length) {\n    return false;\n  }\n  for (let i = 0; i < path1.length; i++) {\n    if (!keysEqual(null, path1[i], path2[i])) {\n      return false;\n    }\n  }\n  return true;\n};\nconst updateGroupOffsets = function (that, items, path, offset, additionalGroupInfo) {\n  if (!items) {\n    return;\n  }\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    if (\"key\" in item && void 0 !== item.items) {\n      path.push(item.key);\n      if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {\n        additionalGroupInfo.offset = offset;\n      }\n      const groupInfo = that.findGroupInfo(path);\n      if (groupInfo && !item.isContinuation) {\n        groupInfo.offset = offset;\n      }\n      if (groupInfo && !groupInfo.isExpanded) {\n        offset += groupInfo.count;\n      } else {\n        offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);\n      }\n      path.pop();\n    } else {\n      offset++;\n    }\n  }\n  return offset;\n};\nconst removeGroupLoadOption = function (storeLoadOptions, loadOptions) {\n  if (loadOptions.group) {\n    const groups = dataGridCore.normalizeSortingInfo(loadOptions.group);\n    const sorts = dataGridCore.normalizeSortingInfo(storeLoadOptions.sort);\n    storeLoadOptions.sort = storeHelper.arrangeSortingInfo(groups, sorts);\n    delete loadOptions.group;\n  }\n};\nconst createNotGroupFilter = function (path, storeLoadOptions, group) {\n  const groups = dataGridCore.normalizeSortingInfo(group || storeLoadOptions.group);\n  let filter = [];\n  for (let i = 0; i < path.length; i++) {\n    const filterElement = [];\n    for (let j = 0; j <= i; j++) {\n      filterElement.push([groups[j].selector, i === j ? \"<>\" : \"=\", path[j]]);\n    }\n    filter.push(dataGridCore.combineFilters(filterElement));\n  }\n  filter = dataGridCore.combineFilters(filter, \"or\");\n  return dataGridCore.combineFilters([filter, storeLoadOptions.filter]);\n};\nconst getGroupCount = function (item, groupCount) {\n  let count = item.count || item.items.length;\n  if (!item.count && groupCount > 1) {\n    count = 0;\n    for (let i = 0; i < item.items.length; i++) {\n      count += getGroupCount(item.items[i], groupCount - 1);\n    }\n  }\n  return count;\n};\nexport class GroupingHelper extends GroupingHelperCore {\n  handleDataLoading(options) {\n    const {\n      storeLoadOptions: storeLoadOptions\n    } = options;\n    const collapsedGroups = [];\n    let collapsedItemsCount = 0;\n    let skipFirstItem = false;\n    let take;\n    const {\n      group: group\n    } = options.loadOptions;\n    let skipCorrection = 0;\n    removeGroupLoadOption(storeLoadOptions, options.loadOptions);\n    options.group = options.group || group;\n    if (options.isCustomLoading) {\n      return;\n    }\n    const loadOptions = extend({}, storeLoadOptions);\n    loadOptions.skip = correctSkipLoadOption(this, storeLoadOptions.skip);\n    if (loadOptions.skip && loadOptions.take && group) {\n      loadOptions.skip--;\n      loadOptions.take++;\n      skipFirstItem = true;\n    }\n    if (loadOptions.take && group) {\n      take = loadOptions.take;\n      loadOptions.take++;\n    }\n    foreachCollapsedGroups(this, groupInfo => {\n      if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {\n        return false;\n      }\n      if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {\n        skipCorrection += groupInfo.count - 1;\n        collapsedGroups.push(groupInfo);\n        collapsedItemsCount += groupInfo.count;\n      }\n    });\n    each(collapsedGroups, function () {\n      loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group);\n    });\n    options.storeLoadOptions = loadOptions;\n    options.collapsedGroups = collapsedGroups;\n    options.collapsedItemsCount = collapsedItemsCount;\n    options.skip = loadOptions.skip || 0;\n    options.skipFirstItem = skipFirstItem;\n    options.take = take;\n  }\n  handleDataLoaded(options, callBase) {\n    const that = this;\n    const {\n      collapsedGroups: collapsedGroups\n    } = options;\n    const groups = dataGridCore.normalizeSortingInfo(options.group);\n    const groupCount = groups.length;\n    function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {\n      if (!data || !path.length || !groups.length) {\n        return;\n      }\n      let keyValue;\n      let i;\n      const pathValue = toComparable(path[0], true);\n      for (i = 0; i < data.length; i++) {\n        keyValue = toComparable(data[i].key, true);\n        if (offset >= collapsedGroup.offset || pathValue === keyValue) {\n          break;\n        } else {\n          offset += getGroupCount(data[i], groups.length);\n        }\n      }\n      if (!data.length || pathValue !== keyValue) {\n        data.splice(i, 0, {\n          key: path[0],\n          items: [],\n          count: 1 === path.length ? collapsedGroup.count : void 0\n        });\n      }\n      appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset);\n    }\n    if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {\n      if (!options.extra._totalCountWasIncreasedByCollapsedItems) {\n        options.extra.totalCount += options.collapsedItemsCount;\n        options.extra._totalCountWasIncreasedByCollapsedItems = true;\n      }\n    }\n    callBase(options);\n    if (groupCount) {\n      let {\n        data: data\n      } = options;\n      const query = dataQuery(data);\n      storeHelper.multiLevelGroup(query, groups).enumerate().done(groupedData => {\n        data = groupedData;\n      });\n      if (collapsedGroups) {\n        for (let pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {\n          appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip);\n        }\n      }\n      if (!options.isCustomLoading) {\n        processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);\n      }\n      options.data = data;\n    }\n  }\n  isGroupItemCountable(item) {\n    return null === item.items;\n  }\n  updateTotalItemsCount() {\n    let itemsCountCorrection = 0;\n    foreachCollapsedGroups(this, groupInfo => {\n      if (groupInfo.count) {\n        itemsCountCorrection -= groupInfo.count - 1;\n      }\n    });\n    super.updateTotalItemsCount(itemsCountCorrection);\n  }\n  changeRowExpand(path) {\n    const that = this;\n    const dataSource = that._dataSource;\n    const beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();\n    const dataSourceItems = dataSource.items();\n    const offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());\n    let groupInfo = that.findGroupInfo(path);\n    let groupCountQuery;\n    if (groupInfo && !groupInfo.isExpanded) {\n      groupCountQuery = new Deferred().resolve(groupInfo.count);\n    } else {\n      groupCountQuery = loadTotalCount(dataSource, {\n        filter: createGroupFilter(path, {\n          filter: dataSource.filter(),\n          group: dataSource.group()\n        })\n      });\n    }\n    return when(groupCountQuery).done(count => {\n      count = parseInt(count.length ? count[0] : count);\n      if (groupInfo) {\n        updateGroupOffsets(that, dataSourceItems, [], offset);\n        groupInfo.isExpanded = !groupInfo.isExpanded;\n        groupInfo.count = count;\n      } else {\n        groupInfo = {\n          offset: -1,\n          count: count,\n          path: path,\n          isExpanded: false\n        };\n        updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);\n        if (groupInfo.offset >= 0) {\n          that.addGroupInfo(groupInfo);\n        }\n      }\n      that.updateTotalItemsCount();\n    }).fail(function () {\n      dataSource._eventsStrategy.fireEvent(\"loadError\", arguments);\n    });\n  }\n  allowCollapseAll() {\n    return false;\n  }\n  refresh(options, operationTypes) {\n    const that = this;\n    const {\n      storeLoadOptions: storeLoadOptions\n    } = options;\n    const dataSource = that._dataSource;\n    super.refresh.apply(this, arguments);\n    if (operationTypes.reload) {\n      return foreachCollapsedGroups(that, groupInfo => {\n        const groupCountQuery = loadTotalCount(dataSource, {\n          filter: createGroupFilter(groupInfo.path, storeLoadOptions)\n        });\n        const groupOffsetQuery = loadTotalCount(dataSource, {\n          filter: createOffsetFilter(groupInfo.path, storeLoadOptions)\n        });\n        return when(groupOffsetQuery, groupCountQuery).done((offset, count) => {\n          offset = parseInt(offset.length ? offset[0] : offset);\n          count = parseInt(count.length ? count[0] : count);\n          groupInfo.offset = offset;\n          if (groupInfo.count !== count) {\n            groupInfo.count = count;\n            that.updateTotalItemsCount();\n          }\n        });\n      }, true);\n    }\n  }\n}","map":{"version":3,"names":["dataQuery","storeHelper","keysEqual","toComparable","Deferred","when","extend","each","dataGridCore","createGroupFilter","createOffsetFilter","GroupingHelper","GroupingHelperCore","loadTotalCount","dataSource","options","d","loadOptions","skip","take","requireTotalCount","load","done","data","extra","resolve","totalCount","fail","reject","bind","foreachCollapsedGroups","that","callback","updateOffsets","foreachGroups","groupInfo","isExpanded","correctSkipLoadOption","skipCorrection","resultSkip","offset","count","processGroupItems","items","path","skipFirstItem","removeLastItemsCount","needRemoveFirstItem","i","length","item","push","key","findGroupInfo","collapsedItems","offsetInfo","isContinuation","isContinuationOnNextPage","pop","splice","pathEquals","path1","path2","updateGroupOffsets","additionalGroupInfo","removeGroupLoadOption","storeLoadOptions","group","groups","normalizeSortingInfo","sorts","sort","arrangeSortingInfo","createNotGroupFilter","filter","filterElement","j","selector","combineFilters","getGroupCount","groupCount","handleDataLoading","collapsedGroups","collapsedItemsCount","isCustomLoading","handleDataLoaded","callBase","appendCollapsedPath","collapsedGroup","keyValue","pathValue","slice","_totalCountWasIncreasedByCollapsedItems","query","multiLevelGroup","enumerate","groupedData","pathIndex","isGroupItemCountable","updateTotalItemsCount","itemsCountCorrection","changeRowExpand","_dataSource","beginPageIndex","pageIndex","dataSourceItems","pageSize","groupCountQuery","parseInt","addGroupInfo","_eventsStrategy","fireEvent","arguments","allowCollapseAll","refresh","operationTypes","apply","reload","groupOffsetQuery"],"sources":["C:/Users/Sofia/Desktop/Репозиторий ЦК/internship_project/client/node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_expanded.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/data_grid/grouping/m_grouping_expanded.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport dataQuery from \"../../../../common/data/query\";\r\nimport storeHelper from \"../../../../common/data/store_helper\";\r\nimport {\r\n    keysEqual\r\n} from \"../../../../common/data/utils\";\r\nimport {\r\n    toComparable\r\n} from \"../../../../core/utils/data\";\r\nimport {\r\n    Deferred,\r\n    when\r\n} from \"../../../../core/utils/deferred\";\r\nimport {\r\n    extend\r\n} from \"../../../../core/utils/extend\";\r\nimport {\r\n    each\r\n} from \"../../../../core/utils/iterator\";\r\nimport dataGridCore from \"../m_core\";\r\nimport {\r\n    createGroupFilter\r\n} from \"../m_utils\";\r\nimport {\r\n    createOffsetFilter,\r\n    GroupingHelper as GroupingHelperCore\r\n} from \"./m_grouping_core\";\r\nconst loadTotalCount = function(dataSource, options) {\r\n    const d = new Deferred;\r\n    const loadOptions = extend({\r\n        skip: 0,\r\n        take: 1,\r\n        requireTotalCount: true\r\n    }, options);\r\n    dataSource.load(loadOptions).done(((data, extra) => {\r\n        d.resolve(extra && extra.totalCount)\r\n    })).fail(d.reject.bind(d));\r\n    return d\r\n};\r\nconst foreachCollapsedGroups = function(that, callback, updateOffsets) {\r\n    return that.foreachGroups((groupInfo => {\r\n        if (!groupInfo.isExpanded) {\r\n            return callback(groupInfo)\r\n        }\r\n    }), false, false, updateOffsets, true)\r\n};\r\nconst correctSkipLoadOption = function(that, skip) {\r\n    let skipCorrection = 0;\r\n    let resultSkip = skip || 0;\r\n    if (skip) {\r\n        foreachCollapsedGroups(that, (groupInfo => {\r\n            if (groupInfo.offset - skipCorrection >= skip) {\r\n                return false\r\n            }\r\n            skipCorrection += groupInfo.count - 1\r\n        }));\r\n        resultSkip += skipCorrection\r\n    }\r\n    return resultSkip\r\n};\r\nconst processGroupItems = function(that, items, path, offset, skipFirstItem, take) {\r\n    let removeLastItemsCount = 0;\r\n    let needRemoveFirstItem = false;\r\n    for (let i = 0; i < items.length; i++) {\r\n        const item = items[i];\r\n        if (void 0 !== item.items) {\r\n            path.push(item.key);\r\n            const groupInfo = that.findGroupInfo(path);\r\n            if (groupInfo && !groupInfo.isExpanded) {\r\n                item.collapsedItems = item.items;\r\n                item.items = null;\r\n                offset += groupInfo.count;\r\n                take--;\r\n                if (take < 0) {\r\n                    removeLastItemsCount++\r\n                }\r\n                if (skipFirstItem) {\r\n                    needRemoveFirstItem = true\r\n                }\r\n            } else if (item.items) {\r\n                const offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);\r\n                if (skipFirstItem) {\r\n                    if (offsetInfo.offset - offset > 1) {\r\n                        item.isContinuation = true\r\n                    } else {\r\n                        needRemoveFirstItem = true\r\n                    }\r\n                }\r\n                offset = offsetInfo.offset;\r\n                take = offsetInfo.take;\r\n                if (take < 0) {\r\n                    if (item.items.length) {\r\n                        item.isContinuationOnNextPage = true\r\n                    } else {\r\n                        removeLastItemsCount++\r\n                    }\r\n                }\r\n            }\r\n            path.pop()\r\n        } else {\r\n            if (skipFirstItem) {\r\n                needRemoveFirstItem = true\r\n            }\r\n            offset++;\r\n            take--;\r\n            if (take < 0) {\r\n                removeLastItemsCount++\r\n            }\r\n        }\r\n        skipFirstItem = false\r\n    }\r\n    if (needRemoveFirstItem) {\r\n        items.splice(0, 1)\r\n    }\r\n    if (removeLastItemsCount) {\r\n        items.splice(-removeLastItemsCount, removeLastItemsCount)\r\n    }\r\n    return {\r\n        offset: offset,\r\n        take: take\r\n    }\r\n};\r\nconst pathEquals = function(path1, path2) {\r\n    if (path1.length !== path2.length) {\r\n        return false\r\n    }\r\n    for (let i = 0; i < path1.length; i++) {\r\n        if (!keysEqual(null, path1[i], path2[i])) {\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n};\r\nconst updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {\r\n    if (!items) {\r\n        return\r\n    }\r\n    for (let i = 0; i < items.length; i++) {\r\n        const item = items[i];\r\n        if (\"key\" in item && void 0 !== item.items) {\r\n            path.push(item.key);\r\n            if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {\r\n                additionalGroupInfo.offset = offset\r\n            }\r\n            const groupInfo = that.findGroupInfo(path);\r\n            if (groupInfo && !item.isContinuation) {\r\n                groupInfo.offset = offset\r\n            }\r\n            if (groupInfo && !groupInfo.isExpanded) {\r\n                offset += groupInfo.count\r\n            } else {\r\n                offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo)\r\n            }\r\n            path.pop()\r\n        } else {\r\n            offset++\r\n        }\r\n    }\r\n    return offset\r\n};\r\nconst removeGroupLoadOption = function(storeLoadOptions, loadOptions) {\r\n    if (loadOptions.group) {\r\n        const groups = dataGridCore.normalizeSortingInfo(loadOptions.group);\r\n        const sorts = dataGridCore.normalizeSortingInfo(storeLoadOptions.sort);\r\n        storeLoadOptions.sort = storeHelper.arrangeSortingInfo(groups, sorts);\r\n        delete loadOptions.group\r\n    }\r\n};\r\nconst createNotGroupFilter = function(path, storeLoadOptions, group) {\r\n    const groups = dataGridCore.normalizeSortingInfo(group || storeLoadOptions.group);\r\n    let filter = [];\r\n    for (let i = 0; i < path.length; i++) {\r\n        const filterElement = [];\r\n        for (let j = 0; j <= i; j++) {\r\n            filterElement.push([groups[j].selector, i === j ? \"<>\" : \"=\", path[j]])\r\n        }\r\n        filter.push(dataGridCore.combineFilters(filterElement))\r\n    }\r\n    filter = dataGridCore.combineFilters(filter, \"or\");\r\n    return dataGridCore.combineFilters([filter, storeLoadOptions.filter])\r\n};\r\nconst getGroupCount = function(item, groupCount) {\r\n    let count = item.count || item.items.length;\r\n    if (!item.count && groupCount > 1) {\r\n        count = 0;\r\n        for (let i = 0; i < item.items.length; i++) {\r\n            count += getGroupCount(item.items[i], groupCount - 1)\r\n        }\r\n    }\r\n    return count\r\n};\r\nexport class GroupingHelper extends GroupingHelperCore {\r\n    handleDataLoading(options) {\r\n        const {\r\n            storeLoadOptions: storeLoadOptions\r\n        } = options;\r\n        const collapsedGroups = [];\r\n        let collapsedItemsCount = 0;\r\n        let skipFirstItem = false;\r\n        let take;\r\n        const {\r\n            group: group\r\n        } = options.loadOptions;\r\n        let skipCorrection = 0;\r\n        removeGroupLoadOption(storeLoadOptions, options.loadOptions);\r\n        options.group = options.group || group;\r\n        if (options.isCustomLoading) {\r\n            return\r\n        }\r\n        const loadOptions = extend({}, storeLoadOptions);\r\n        loadOptions.skip = correctSkipLoadOption(this, storeLoadOptions.skip);\r\n        if (loadOptions.skip && loadOptions.take && group) {\r\n            loadOptions.skip--;\r\n            loadOptions.take++;\r\n            skipFirstItem = true\r\n        }\r\n        if (loadOptions.take && group) {\r\n            take = loadOptions.take;\r\n            loadOptions.take++\r\n        }\r\n        foreachCollapsedGroups(this, (groupInfo => {\r\n            if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {\r\n                return false\r\n            }\r\n            if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {\r\n                skipCorrection += groupInfo.count - 1;\r\n                collapsedGroups.push(groupInfo);\r\n                collapsedItemsCount += groupInfo.count\r\n            }\r\n        }));\r\n        each(collapsedGroups, (function() {\r\n            loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group)\r\n        }));\r\n        options.storeLoadOptions = loadOptions;\r\n        options.collapsedGroups = collapsedGroups;\r\n        options.collapsedItemsCount = collapsedItemsCount;\r\n        options.skip = loadOptions.skip || 0;\r\n        options.skipFirstItem = skipFirstItem;\r\n        options.take = take\r\n    }\r\n    handleDataLoaded(options, callBase) {\r\n        const that = this;\r\n        const {\r\n            collapsedGroups: collapsedGroups\r\n        } = options;\r\n        const groups = dataGridCore.normalizeSortingInfo(options.group);\r\n        const groupCount = groups.length;\r\n\r\n        function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {\r\n            if (!data || !path.length || !groups.length) {\r\n                return\r\n            }\r\n            let keyValue;\r\n            let i;\r\n            const pathValue = toComparable(path[0], true);\r\n            for (i = 0; i < data.length; i++) {\r\n                keyValue = toComparable(data[i].key, true);\r\n                if (offset >= collapsedGroup.offset || pathValue === keyValue) {\r\n                    break\r\n                } else {\r\n                    offset += getGroupCount(data[i], groups.length)\r\n                }\r\n            }\r\n            if (!data.length || pathValue !== keyValue) {\r\n                data.splice(i, 0, {\r\n                    key: path[0],\r\n                    items: [],\r\n                    count: 1 === path.length ? collapsedGroup.count : void 0\r\n                })\r\n            }\r\n            appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset)\r\n        }\r\n        if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {\r\n            if (!options.extra._totalCountWasIncreasedByCollapsedItems) {\r\n                options.extra.totalCount += options.collapsedItemsCount;\r\n                options.extra._totalCountWasIncreasedByCollapsedItems = true\r\n            }\r\n        }\r\n        callBase(options);\r\n        if (groupCount) {\r\n            let {\r\n                data: data\r\n            } = options;\r\n            const query = dataQuery(data);\r\n            storeHelper.multiLevelGroup(query, groups).enumerate().done((groupedData => {\r\n                data = groupedData\r\n            }));\r\n            if (collapsedGroups) {\r\n                for (let pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {\r\n                    appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip)\r\n                }\r\n            }\r\n            if (!options.isCustomLoading) {\r\n                processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take)\r\n            }\r\n            options.data = data\r\n        }\r\n    }\r\n    isGroupItemCountable(item) {\r\n        return null === item.items\r\n    }\r\n    updateTotalItemsCount() {\r\n        let itemsCountCorrection = 0;\r\n        foreachCollapsedGroups(this, (groupInfo => {\r\n            if (groupInfo.count) {\r\n                itemsCountCorrection -= groupInfo.count - 1\r\n            }\r\n        }));\r\n        super.updateTotalItemsCount(itemsCountCorrection)\r\n    }\r\n    changeRowExpand(path) {\r\n        const that = this;\r\n        const dataSource = that._dataSource;\r\n        const beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();\r\n        const dataSourceItems = dataSource.items();\r\n        const offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());\r\n        let groupInfo = that.findGroupInfo(path);\r\n        let groupCountQuery;\r\n        if (groupInfo && !groupInfo.isExpanded) {\r\n            groupCountQuery = (new Deferred).resolve(groupInfo.count)\r\n        } else {\r\n            groupCountQuery = loadTotalCount(dataSource, {\r\n                filter: createGroupFilter(path, {\r\n                    filter: dataSource.filter(),\r\n                    group: dataSource.group()\r\n                })\r\n            })\r\n        }\r\n        return when(groupCountQuery).done((count => {\r\n            count = parseInt(count.length ? count[0] : count);\r\n            if (groupInfo) {\r\n                updateGroupOffsets(that, dataSourceItems, [], offset);\r\n                groupInfo.isExpanded = !groupInfo.isExpanded;\r\n                groupInfo.count = count\r\n            } else {\r\n                groupInfo = {\r\n                    offset: -1,\r\n                    count: count,\r\n                    path: path,\r\n                    isExpanded: false\r\n                };\r\n                updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);\r\n                if (groupInfo.offset >= 0) {\r\n                    that.addGroupInfo(groupInfo)\r\n                }\r\n            }\r\n            that.updateTotalItemsCount()\r\n        })).fail((function() {\r\n            dataSource._eventsStrategy.fireEvent(\"loadError\", arguments)\r\n        }))\r\n    }\r\n    allowCollapseAll() {\r\n        return false\r\n    }\r\n    refresh(options, operationTypes) {\r\n        const that = this;\r\n        const {\r\n            storeLoadOptions: storeLoadOptions\r\n        } = options;\r\n        const dataSource = that._dataSource;\r\n        super.refresh.apply(this, arguments);\r\n        if (operationTypes.reload) {\r\n            return foreachCollapsedGroups(that, (groupInfo => {\r\n                const groupCountQuery = loadTotalCount(dataSource, {\r\n                    filter: createGroupFilter(groupInfo.path, storeLoadOptions)\r\n                });\r\n                const groupOffsetQuery = loadTotalCount(dataSource, {\r\n                    filter: createOffsetFilter(groupInfo.path, storeLoadOptions)\r\n                });\r\n                return when(groupOffsetQuery, groupCountQuery).done(((offset, count) => {\r\n                    offset = parseInt(offset.length ? offset[0] : offset);\r\n                    count = parseInt(count.length ? count[0] : count);\r\n                    groupInfo.offset = offset;\r\n                    if (groupInfo.count !== count) {\r\n                        groupInfo.count = count;\r\n                        that.updateTotalItemsCount()\r\n                    }\r\n                }))\r\n            }), true)\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}