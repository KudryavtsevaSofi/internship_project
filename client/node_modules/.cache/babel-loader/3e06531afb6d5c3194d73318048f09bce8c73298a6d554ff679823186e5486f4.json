{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/grid_core/columns_controller/m_columns_controller_utils.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport numberLocalization from \"../../../../common/core/localization/number\";\nimport { normalizeIndexes } from \"../../../../core/utils/array\";\nimport { equalByValue } from \"../../../../core/utils/common\";\nimport { compileGetter, compileSetter } from \"../../../../core/utils/data\";\nimport dateSerialization from \"../../../../core/utils/date_serialization\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport { each, map } from \"../../../../core/utils/iterator\";\nimport { deepExtendArraySafe } from \"../../../../core/utils/object\";\nimport { getDefaultAlignment } from \"../../../../core/utils/position\";\nimport { isDefined, isFunction, isNumeric, isObject, isString, type } from \"../../../../core/utils/type\";\nimport variableWrapper from \"../../../../core/utils/variable_wrapper\";\nimport { HIDDEN_COLUMNS_WIDTH } from \"../adaptivity/const\";\nimport gridCoreUtils from \"../m_utils\";\nimport { StickyPosition } from \"../sticky_columns/const\";\nimport { getColumnFixedPosition } from \"../sticky_columns/utils\";\nimport { COLUMN_CHOOSER_LOCATION, COLUMN_INDEX_OPTIONS, DEFAULT_COLUMN_OPTIONS, GROUP_COMMAND_COLUMN_NAME, GROUP_LOCATION, IGNORE_COLUMN_OPTION_NAMES, USER_STATE_FIELD_NAMES, USER_STATE_FIELD_NAMES_15_1 } from \"./const\";\nexport const setFilterOperationsAsDefaultValues = function (column) {\n  column.filterOperations = column.defaultFilterOperations;\n};\nlet globalColumnId = 1;\nexport const createColumn = function (that, columnOptions, userStateColumnOptions, bandColumn) {\n  let commonColumnOptions = {};\n  if (columnOptions) {\n    if (isString(columnOptions)) {\n      columnOptions = {\n        dataField: columnOptions\n      };\n    }\n    that.setName(columnOptions);\n    let result = {};\n    if (columnOptions.command) {\n      result = deepExtendArraySafe(commonColumnOptions, columnOptions);\n    } else {\n      commonColumnOptions = that.getCommonSettings(columnOptions);\n      if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {\n        columnOptions = extend({}, columnOptions, {\n          dataField: userStateColumnOptions.dataField\n        });\n      }\n      const calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);\n      if (!columnOptions.type) {\n        result = {\n          headerId: \"dx-col-\" + globalColumnId++\n        };\n      }\n      result = deepExtendArraySafe(result, DEFAULT_COLUMN_OPTIONS, false, true);\n      deepExtendArraySafe(result, commonColumnOptions, false, true);\n      deepExtendArraySafe(result, calculatedColumnOptions, false, true);\n      deepExtendArraySafe(result, columnOptions, false, true);\n      deepExtendArraySafe(result, {\n        selector: null\n      }, false, true);\n    }\n    if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {\n      setFilterOperationsAsDefaultValues(result);\n    }\n    return result;\n  }\n};\nexport const createColumnsFromOptions = function (that, columnsOptions, bandColumn, createdColumnCount) {\n  let result = [];\n  if (columnsOptions) {\n    each(columnsOptions, (index, columnOptions) => {\n      const currentIndex = (createdColumnCount ?? 0) + result.length;\n      const userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[currentIndex]) && that._columnsUserState[currentIndex];\n      const column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);\n      if (column) {\n        if (bandColumn) {\n          column.ownerBand = bandColumn;\n        }\n        result.push(column);\n        if (column.columns) {\n          result = result.concat(createColumnsFromOptions(that, column.columns, column, result.length));\n          delete column.columns;\n          column.hasColumns = true;\n        }\n      }\n    });\n  }\n  return result;\n};\nexport const getParentBandColumns = function (columnIndex, columnParentByIndex) {\n  const result = [];\n  let parent = columnParentByIndex[columnIndex];\n  while (parent) {\n    result.unshift(parent);\n    columnIndex = parent.index;\n    parent = columnParentByIndex[columnIndex];\n  }\n  return result;\n};\nexport const getChildrenByBandColumn = function (columnIndex, columnChildrenByIndex, recursive) {\n  let result = [];\n  const children = columnChildrenByIndex[columnIndex];\n  if (children) {\n    for (let i = 0; i < children.length; i++) {\n      const column = children[i];\n      if (!isDefined(column.groupIndex) || column.showWhenGrouped) {\n        result.push(column);\n        if (recursive && column.isBand) {\n          result = result.concat(getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive));\n        }\n      }\n    }\n  }\n  return result;\n};\nexport const getColumnByIndexes = function (that, columnIndexes) {\n  let result;\n  let columns;\n  const bandColumnsCache = that.getBandColumnsCache();\n  const callbackFilter = function (column) {\n    const ownerBand = result ? result.index : void 0;\n    return column.ownerBand === ownerBand;\n  };\n  if (bandColumnsCache.isPlain) {\n    result = that._columns[columnIndexes[0]];\n  } else {\n    columns = that._columns.filter(callbackFilter);\n    for (let i = 0; i < columnIndexes.length; i++) {\n      result = columns[columnIndexes[i]];\n      if (result) {\n        columns = that._columns.filter(callbackFilter);\n      }\n    }\n  }\n  return result;\n};\nexport const getColumnFullPath = function (that, column) {\n  let result = [];\n  let columns;\n  const bandColumnsCache = that.getBandColumnsCache();\n  const callbackFilter = function (item) {\n    return item.ownerBand === column.ownerBand;\n  };\n  if (bandColumnsCache.isPlain) {\n    const columnIndex = that._columns.indexOf(column);\n    if (columnIndex >= 0) {\n      result = [`columns[${columnIndex}]`];\n    }\n  } else {\n    columns = that._columns.filter(callbackFilter);\n    while (columns.length && -1 !== columns.indexOf(column)) {\n      result.unshift(`columns[${columns.indexOf(column)}]`);\n      column = bandColumnsCache.columnParentByIndex[column.index];\n      columns = column ? that._columns.filter(callbackFilter) : [];\n    }\n  }\n  return result.join(\".\");\n};\nexport const calculateColspan = function (that, columnID) {\n  let colspan = 0;\n  const columns = that.getChildrenByBandColumn(columnID, true);\n  each(columns, (_, column) => {\n    if (column.isBand) {\n      column.colspan = column.colspan || calculateColspan(that, column.index);\n      colspan += column.colspan || 1;\n    } else {\n      colspan += 1;\n    }\n  });\n  return colspan;\n};\nexport const processBandColumns = function (that, columns, bandColumnsCache) {\n  let rowspan;\n  for (let i = 0; i < columns.length; i++) {\n    const column = columns[i];\n    if (column.visible || column.command) {\n      if (column.isBand) {\n        column.colspan = column.colspan || calculateColspan(that, column.index);\n      }\n      if (!column.isBand || !column.colspan) {\n        rowspan = that.getRowCount();\n        if (!column.command && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {\n          rowspan -= getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length;\n        }\n        if (rowspan > 1) {\n          column.rowspan = rowspan;\n        }\n      }\n    }\n  }\n};\nexport const getValueDataType = function (value) {\n  let dataType = type(value);\n  if (\"string\" !== dataType && \"boolean\" !== dataType && \"number\" !== dataType && \"date\" !== dataType && \"object\" !== dataType) {\n    dataType = void 0;\n  }\n  return dataType;\n};\nexport const getSerializationFormat = function (dataType, value) {\n  switch (dataType) {\n    case \"date\":\n    case \"datetime\":\n      return dateSerialization.getDateSerializationFormat(value);\n    case \"number\":\n      if (isString(value)) {\n        return \"string\";\n      }\n      if (isNumeric(value)) {\n        return null;\n      }\n  }\n};\nexport const updateSerializers = function (options, dataType) {\n  if (!options.deserializeValue) {\n    if (gridCoreUtils.isDateType(dataType)) {\n      options.deserializeValue = function (value) {\n        return dateSerialization.deserializeDate(value);\n      };\n      options.serializeValue = function (value) {\n        return isString(value) ? value : dateSerialization.serializeDate(value, this.serializationFormat);\n      };\n    }\n    if (\"number\" === dataType) {\n      options.deserializeValue = function (value) {\n        const parsedValue = parseFloat(value);\n        return isNaN(parsedValue) ? value : parsedValue;\n      };\n      options.serializeValue = function (value, target) {\n        if (\"filter\" === target) {\n          return value;\n        }\n        return isDefined(value) && \"string\" === this.serializationFormat ? value.toString() : value;\n      };\n    }\n  }\n};\nexport const getAlignmentByDataType = function (dataType, isRTL) {\n  switch (dataType) {\n    case \"number\":\n      return \"right\";\n    case \"boolean\":\n      return \"center\";\n    default:\n      return getDefaultAlignment(isRTL);\n  }\n};\nexport const customizeTextForBooleanDataType = function (e) {\n  if (true === e.value) {\n    return this.trueText || \"true\";\n  }\n  if (false === e.value) {\n    return this.falseText || \"false\";\n  }\n  return e.valueText || \"\";\n};\nexport const getCustomizeTextByDataType = function (dataType) {\n  if (\"boolean\" === dataType) {\n    return customizeTextForBooleanDataType;\n  }\n};\nexport const createColumnsFromDataSource = function (that, dataSource) {\n  const firstItems = that._getFirstItems(dataSource);\n  let fieldName;\n  const processedFields = {};\n  const result = [];\n  for (let i = 0; i < firstItems.length; i++) {\n    if (firstItems[i]) {\n      for (fieldName in firstItems[i]) {\n        if (!isFunction(firstItems[i][fieldName]) || variableWrapper.isWrapped(firstItems[i][fieldName])) {\n          processedFields[fieldName] = true;\n        }\n      }\n    }\n  }\n  for (fieldName in processedFields) {\n    if (0 !== fieldName.indexOf(\"__\")) {\n      const column = createColumn(that, fieldName);\n      result.push(column);\n    }\n  }\n  return result;\n};\nexport const updateColumnIndexes = function (that) {\n  each(that._columns, (index, column) => {\n    column.index = index;\n  });\n  each(that._columns, (index, column) => {\n    if (isObject(column.ownerBand)) {\n      column.ownerBand = column.ownerBand.index;\n    }\n  });\n  each(that._commandColumns, (index, column) => {\n    column.index = -(index + 1);\n  });\n};\nexport const updateColumnGroupIndexes = function (that, currentColumn) {\n  normalizeIndexes(that._columns, \"groupIndex\", currentColumn, column => {\n    const {\n      grouped: grouped\n    } = column;\n    delete column.grouped;\n    return grouped;\n  });\n};\nexport const updateColumnSortIndexes = function (that, currentColumn) {\n  each(that._columns, (index, column) => {\n    if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {\n      delete column.sortIndex;\n    }\n  });\n  normalizeIndexes(that._columns, \"sortIndex\", currentColumn, column => !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder));\n};\nexport const updateColumnVisibleIndexes = function (that, currentColumn) {\n  let column;\n  const result = [];\n  const bandColumnsCache = that.getBandColumnsCache();\n  const bandedColumns = [];\n  const columns = that._columns.filter(column => !column.command);\n  for (let i = 0; i < columns.length; i++) {\n    column = columns[i];\n    const parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);\n    if (parentBandColumns.length) {\n      bandedColumns.push(column);\n    } else {\n      result.push(column);\n    }\n  }\n  normalizeIndexes(bandedColumns, \"visibleIndex\", currentColumn);\n  normalizeIndexes(result, \"visibleIndex\", currentColumn);\n};\nexport const getColumnIndexByVisibleIndex = function (that, visibleIndex, location) {\n  const rowIndex = isObject(visibleIndex) ? visibleIndex.rowIndex : null;\n  const columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);\n  let column;\n  visibleIndex = isObject(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;\n  column = columns[visibleIndex];\n  if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {\n    column = that._columns.filter(col => column.type === col.type)[0] || column;\n  }\n  return column && isDefined(column.index) ? column.index : -1;\n};\nexport const moveColumnToGroup = function (that, column, groupIndex) {\n  const groupColumns = that.getGroupColumns();\n  let i;\n  if (groupIndex >= 0) {\n    for (i = 0; i < groupColumns.length; i++) {\n      if (groupColumns[i].groupIndex >= groupIndex) {\n        groupColumns[i].groupIndex++;\n      }\n    }\n  } else {\n    groupIndex = 0;\n    for (i = 0; i < groupColumns.length; i++) {\n      groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1);\n    }\n  }\n  return groupIndex;\n};\nfunction checkUserStateColumn(column, userStateColumn) {\n  return column && userStateColumn && userStateColumn.name === (column.name || column.dataField) && (userStateColumn.dataField === column.dataField || column.name);\n}\nexport const applyUserState = function (that) {\n  const columnsUserState = that._columnsUserState;\n  const ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];\n  const columns = that._columns;\n  const columnCountById = {};\n  let resultColumns = [];\n  let allColumnsHaveState = true;\n  const userStateColumnIndexes = [];\n  let column;\n  let userStateColumnIndex;\n  let i;\n  function applyFieldsState(column, userStateColumn) {\n    if (!userStateColumn) {\n      return;\n    }\n    for (let index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {\n      const fieldName = USER_STATE_FIELD_NAMES[index];\n      if (ignoreColumnOptionNames.includes(fieldName)) {\n        continue;\n      }\n      if (\"dataType\" === fieldName) {\n        column[fieldName] = column[fieldName] || userStateColumn[fieldName];\n      } else if (USER_STATE_FIELD_NAMES_15_1.includes(fieldName)) {\n        if (fieldName in userStateColumn) {\n          column[fieldName] = userStateColumn[fieldName];\n        }\n      } else {\n        if (\"selectedFilterOperation\" === fieldName && userStateColumn[fieldName]) {\n          column.defaultSelectedFilterOperation = column[fieldName] || null;\n        }\n        column[fieldName] = userStateColumn[fieldName];\n      }\n    }\n  }\n  function findUserStateColumn(columnsUserState, column) {\n    const id = column.name || column.dataField;\n    let count = columnCountById[id] || 0;\n    for (let j = 0; j < columnsUserState.length; j++) {\n      if (checkUserStateColumn(column, columnsUserState[j])) {\n        if (count) {\n          count--;\n        } else {\n          columnCountById[id] = columnCountById[id] || 0;\n          columnCountById[id]++;\n          return j;\n        }\n      }\n    }\n    return -1;\n  }\n  if (columnsUserState) {\n    for (i = 0; i < columns.length; i++) {\n      userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);\n      allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;\n      userStateColumnIndexes.push(userStateColumnIndex);\n    }\n    for (i = 0; i < columns.length; i++) {\n      column = columns[i];\n      userStateColumnIndex = userStateColumnIndexes[i];\n      if (that._hasUserState || allColumnsHaveState) {\n        applyFieldsState(column, columnsUserState[userStateColumnIndex]);\n      }\n      if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {\n        resultColumns[userStateColumnIndex] = column;\n      } else {\n        resultColumns.push(column);\n      }\n    }\n    let hasAddedBands = false;\n    for (i = 0; i < columnsUserState.length; i++) {\n      const columnUserState = columnsUserState[i];\n      if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {\n        column = createColumn(that, columnUserState.added);\n        applyFieldsState(column, columnUserState);\n        resultColumns.push(column);\n        if (columnUserState.added.columns) {\n          hasAddedBands = true;\n        }\n      }\n    }\n    if (hasAddedBands) {\n      updateColumnIndexes(that);\n      resultColumns = createColumnsFromOptions(that, resultColumns);\n    }\n    assignColumns(that, resultColumns);\n  }\n};\nexport const updateIndexes = function (that, column) {\n  updateColumnIndexes(that);\n  updateColumnGroupIndexes(that, column);\n  updateColumnSortIndexes(that, column);\n  resetBandColumnsCache(that);\n  updateColumnVisibleIndexes(that, column);\n};\nexport const resetColumnsCache = function (that) {\n  that.resetColumnsCache();\n};\nexport function assignColumns(that, columns) {\n  that._previousColumns = that._columns;\n  that._columns = columns;\n  resetColumnsCache(that);\n  that.updateColumnDataTypes();\n}\nexport const updateColumnChanges = function (that, changeType, optionName, columnIndex) {\n  const columnChanges = that._columnChanges || {\n    optionNames: {\n      length: 0\n    },\n    changeTypes: {\n      length: 0\n    },\n    columnIndex: columnIndex\n  };\n  optionName = optionName || \"all\";\n  optionName = optionName.split(\".\")[0];\n  const {\n    changeTypes: changeTypes\n  } = columnChanges;\n  if (changeType && !changeTypes[changeType]) {\n    changeTypes[changeType] = true;\n    changeTypes.length++;\n  }\n  const {\n    optionNames: optionNames\n  } = columnChanges;\n  if (optionName && !optionNames[optionName]) {\n    optionNames[optionName] = true;\n    optionNames.length++;\n  }\n  if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {\n    if (isDefined(columnIndex)) {\n      columnChanges.columnIndices ?? (columnChanges.columnIndices = []);\n      if (isDefined(columnChanges.columnIndex)) {\n        columnChanges.columnIndices.push(columnChanges.columnIndex);\n      }\n      columnChanges.columnIndices.push(columnIndex);\n    }\n    delete columnChanges.columnIndex;\n  }\n  that._columnChanges = columnChanges;\n  resetColumnsCache(that);\n};\nexport const fireColumnsChanged = function (that) {\n  const onColumnsChanging = that.option(\"onColumnsChanging\");\n  const columnChanges = that._columnChanges;\n  const reinitOptionNames = [\"dataField\", \"lookup\", \"dataType\", \"columns\"];\n  if (that.isInitialized() && !that._updateLockCount && columnChanges) {\n    if (onColumnsChanging) {\n      that._updateLockCount++;\n      onColumnsChanging(extend({\n        component: that.component\n      }, columnChanges));\n      that._updateLockCount--;\n    }\n    that._columnChanges = void 0;\n    if (options = columnChanges.optionNames, options && reinitOptionNames.some(name => options[name])) {\n      that._reinitAfterLookupChanges = null === columnChanges || void 0 === columnChanges ? void 0 : columnChanges.optionNames.lookup;\n      that.reinit();\n      that._reinitAfterLookupChanges = void 0;\n    } else {\n      that.columnsChanged.fire(columnChanges);\n    }\n  }\n  var options;\n};\nexport const updateSortOrderWhenGrouping = function (that, column, groupIndex, prevGroupIndex) {\n  const columnWasGrouped = prevGroupIndex >= 0;\n  if (groupIndex >= 0) {\n    if (!columnWasGrouped) {\n      column.lastSortOrder = column.sortOrder;\n    }\n  } else {\n    const sortMode = that.option(\"sorting.mode\");\n    let sortOrder = column.lastSortOrder;\n    if (\"single\" === sortMode) {\n      const sortedByAnotherColumn = that._columns.some(col => col !== column && isDefined(col.sortIndex));\n      if (sortedByAnotherColumn) {\n        sortOrder = void 0;\n      }\n    }\n    column.sortOrder = sortOrder;\n  }\n};\nexport const fireOptionChanged = function (that, options) {\n  const {\n    value: value\n  } = options;\n  const {\n    optionName: optionName\n  } = options;\n  const {\n    prevValue: prevValue\n  } = options;\n  const {\n    fullOptionName: fullOptionName\n  } = options;\n  const fullOptionPath = `${fullOptionName}.${optionName}`;\n  if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {\n    that._skipProcessingColumnsChange = fullOptionPath;\n    that.component._notifyOptionChanged(fullOptionPath, value, prevValue);\n    that._skipProcessingColumnsChange = false;\n  }\n};\nexport const columnOptionCore = function (that, column, optionName, value, notFireEvent) {\n  const optionGetter = compileGetter(optionName);\n  const columnIndex = column.index;\n  let columns;\n  let changeType;\n  let initialColumn;\n  if (3 === arguments.length) {\n    return optionGetter(column, {\n      functionsAsIs: true\n    });\n  }\n  const prevValue = optionGetter(column, {\n    functionsAsIs: true\n  });\n  if (!equalByValue(prevValue, value, {\n    maxDepth: 5\n  })) {\n    if (\"groupIndex\" === optionName || \"calculateGroupValue\" === optionName) {\n      changeType = \"grouping\";\n      updateSortOrderWhenGrouping(that, column, value, prevValue);\n    } else if (\"sortIndex\" === optionName || \"sortOrder\" === optionName || \"calculateSortValue\" === optionName) {\n      changeType = \"sorting\";\n    } else {\n      changeType = \"columns\";\n    }\n    const optionSetter = compileSetter(optionName);\n    optionSetter(column, value, {\n      functionsAsIs: true\n    });\n    const fullOptionName = getColumnFullPath(that, column);\n    if (COLUMN_INDEX_OPTIONS[optionName]) {\n      updateIndexes(that, column);\n      value = optionGetter(column);\n    }\n    if (\"name\" === optionName || \"allowEditing\" === optionName) {\n      that._checkColumns();\n    }\n    if (!isDefined(prevValue) && !isDefined(value) && 0 !== optionName.indexOf(\"buffer\") && false !== notFireEvent) {\n      notFireEvent = true;\n    }\n    if (!notFireEvent) {\n      if (!USER_STATE_FIELD_NAMES.includes(optionName) && \"visibleWidth\" !== optionName) {\n        columns = that.option(\"columns\");\n        initialColumn = that.getColumnByPath(fullOptionName, columns);\n        if (isString(initialColumn)) {\n          initialColumn = columns[columnIndex] = {\n            dataField: initialColumn\n          };\n        }\n        if (initialColumn && checkUserStateColumn(initialColumn, column)) {\n          optionSetter(initialColumn, value, {\n            functionsAsIs: true\n          });\n        }\n      }\n      updateColumnChanges(that, changeType, optionName, columnIndex);\n    } else {\n      resetColumnsCache(that);\n    }\n    fullOptionName && fireOptionChanged(that, {\n      fullOptionName: fullOptionName,\n      optionName: optionName,\n      value: value,\n      prevValue: prevValue\n    });\n  }\n};\nexport function isSortOrderValid(sortOrder) {\n  return \"asc\" === sortOrder || \"desc\" === sortOrder;\n}\nexport const addExpandColumn = function (that) {\n  const options = that._getExpandColumnOptions();\n  that.addCommandColumn(options);\n};\nexport const defaultSetCellValue = function (data, value) {\n  if (!this.dataField) {\n    return;\n  }\n  const path = this.dataField.split(\".\");\n  const dotCount = path.length - 1;\n  if (this.serializeValue) {\n    value = this.serializeValue(value);\n  }\n  for (let i = 0; i < dotCount; i++) {\n    const name = path[i];\n    data = data[name] = data[name] || {};\n  }\n  data[path[dotCount]] = value;\n};\nexport const getDataColumns = function (columns, rowIndex, bandColumnID) {\n  const result = [];\n  rowIndex = rowIndex || 0;\n  columns[rowIndex] && each(columns[rowIndex], (_, column) => {\n    if (column.ownerBand === bandColumnID || column.type === GROUP_COMMAND_COLUMN_NAME) {\n      if (!column.isBand || !column.colspan) {\n        if (!column.command || rowIndex < 1) {\n          result.push(column);\n        }\n      } else {\n        result.push.apply(result, getDataColumns(columns, rowIndex + 1, column.index));\n      }\n    }\n  });\n  return result;\n};\nexport const getRowCount = function (that) {\n  let rowCount = 1;\n  const bandColumnsCache = that.getBandColumnsCache();\n  const {\n    columnParentByIndex: columnParentByIndex\n  } = bandColumnsCache;\n  that._columns.forEach(column => {\n    const parents = getParentBandColumns(column.index, columnParentByIndex);\n    const invisibleParents = parents.filter(column => !column.visible);\n    if (column.visible && !invisibleParents.length) {\n      rowCount = Math.max(rowCount, parents.length + 1);\n    }\n  });\n  return rowCount;\n};\nexport const getFixedPosition = function (that, column) {\n  const rtlEnabled = that.option(\"rtlEnabled\");\n  if (column.command && !gridCoreUtils.isCustomCommandColumn(that._columns, column) || !column.fixedPosition) {\n    return rtlEnabled ? \"right\" : \"left\";\n  }\n  return column.fixedPosition;\n};\nexport const processExpandColumns = function (columns, expandColumns, type, columnIndex) {\n  let customColumnIndex;\n  const rowCount = this.getRowCount();\n  let rowspan = columns[columnIndex] && columns[columnIndex].rowspan;\n  let expandColumnsByType = expandColumns.filter(column => column.type === type);\n  columns.forEach((column, index) => {\n    if (column.type === type) {\n      customColumnIndex = index;\n      rowspan = columns[index + 1] ? columns[index + 1].rowspan : rowCount;\n    }\n  });\n  if (rowspan > 1) {\n    expandColumnsByType = map(expandColumnsByType, expandColumn => extend({}, expandColumn, {\n      rowspan: rowspan\n    }));\n  }\n  expandColumnsByType.unshift.apply(expandColumnsByType, isDefined(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);\n  columns.splice.apply(columns, expandColumnsByType);\n  return rowspan || 1;\n};\nexport const digitsCount = function (number) {\n  let i;\n  for (i = 0; number > 1; i++) {\n    number /= 10;\n  }\n  return i;\n};\nexport const numberToString = function (number, digitsCount) {\n  let str = number ? number.toString() : \"0\";\n  while (str.length < digitsCount) {\n    str = `0${str}`;\n  }\n  return str;\n};\nexport const mergeColumns = (that, columns, commandColumns, needToExtend) => {\n  let column;\n  let commandColumnIndex;\n  let result = columns.slice().map(column => extend({}, column));\n  const isColumnFixing = that._isColumnFixing();\n  let defaultCommandColumns = commandColumns.slice().map(column => extend({\n    fixed: isColumnFixing\n  }, column));\n  const getCommandColumnIndex = column => commandColumns.reduce((result, commandColumn, index) => {\n    const columnType = needToExtend && column.type === GROUP_COMMAND_COLUMN_NAME ? \"expand\" : column.type;\n    return commandColumn.type === columnType || commandColumn.command === column.command ? index : result;\n  }, -1);\n  const callbackFilter = commandColumn => commandColumn.command !== commandColumns[commandColumnIndex].command;\n  for (let i = 0; i < columns.length; i++) {\n    column = columns[i];\n    commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;\n    if (commandColumnIndex >= 0) {\n      if (needToExtend) {\n        result[i] = extend({\n          fixed: isColumnFixing\n        }, commandColumns[commandColumnIndex], column);\n        if (column.type !== GROUP_COMMAND_COLUMN_NAME) {\n          defaultCommandColumns = defaultCommandColumns.filter(callbackFilter);\n        }\n      } else {\n        const columnOptions = {\n          visibleIndex: column.visibleIndex,\n          index: column.index,\n          headerId: column.headerId,\n          allowFixing: 0 === column.groupIndex,\n          allowReordering: 0 === column.groupIndex,\n          groupIndex: column.groupIndex\n        };\n        result[i] = extend({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions);\n      }\n    }\n  }\n  if (columns.length && needToExtend && defaultCommandColumns.length) {\n    result = result.concat(defaultCommandColumns);\n  }\n  return result;\n};\nexport const isColumnFixed = (that, column) => isDefined(column.fixed) || !column.type ? column.fixed && column.fixedPosition !== StickyPosition.Sticky : that._isColumnFixing();\nexport const convertOwnerBandToColumnReference = columns => {\n  columns.forEach(column => {\n    if (isDefined(column.ownerBand)) {\n      column.ownerBand = columns[column.ownerBand];\n    }\n  });\n};\nexport const resetBandColumnsCache = that => {\n  that._bandColumnsCache = void 0;\n};\nexport const findColumn = (columns, identifier) => {\n  const identifierOptionName = isString(identifier) && identifier.substr(0, identifier.indexOf(\":\"));\n  let column;\n  if (void 0 === identifier) {\n    return;\n  }\n  if (identifierOptionName) {\n    identifier = identifier.substr(identifierOptionName.length + 1);\n  }\n  if (identifierOptionName) {\n    column = columns.filter(column => `${column[identifierOptionName]}` === identifier)[0];\n  } else {\n    [\"index\", \"name\", \"dataField\", \"caption\"].some(optionName => {\n      column = columns.filter(column => column[optionName] === identifier)[0];\n      return !!column;\n    });\n  }\n  return column;\n};\nexport const sortColumns = (columns, sortOrder) => {\n  if (\"asc\" !== sortOrder && \"desc\" !== sortOrder) {\n    return columns;\n  }\n  const sign = \"asc\" === sortOrder ? 1 : -1;\n  columns.sort((column1, column2) => {\n    const caption1 = column1.caption || \"\";\n    const caption2 = column2.caption || \"\";\n    return sign * caption1.localeCompare(caption2);\n  });\n  return columns;\n};\nexport const strictParseNumber = function (text, format) {\n  const parsedValue = numberLocalization.parse(text);\n  if (isNumeric(parsedValue)) {\n    const formattedValue = numberLocalization.format(parsedValue, format);\n    const formattedValueWithDefaultFormat = numberLocalization.format(parsedValue, \"decimal\");\n    if (formattedValue === text || formattedValueWithDefaultFormat === text) {\n      return parsedValue;\n    }\n  }\n};\nconst isFirstOrLastBandColumn = function (that, bandColumns) {\n  let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n  let isLast = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;\n  return bandColumns.every((column, index) => onlyWithinBandColumn && 0 === index || isFirstOrLastColumnCore(that, column, index, onlyWithinBandColumn, isLast, fixedPosition));\n};\nconst isFirstOrLastColumnCore = function (that, column, rowIndex) {\n  var _columns, _columns$;\n  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\n  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;\n  const columnIndex = column.index;\n  const columns = (index = rowIndex, that.getVisibleColumns(index).filter(col => {\n    let res = true;\n    if (col.visibleWidth === HIDDEN_COLUMNS_WIDTH) {\n      return false;\n    }\n    if (onlyWithinBandColumn && column) {\n      res && (res = col.ownerBand === column.ownerBand);\n    } else if (fixedPosition) {\n      res && (res = col.fixed && getColumnFixedPosition(that, col) === fixedPosition);\n    }\n    return res;\n  }));\n  var index;\n  const visibleColumnIndex = that.getVisibleIndex(columnIndex, rowIndex);\n  return isLast ? visibleColumnIndex === that.getVisibleIndex(null === (_columns = columns[columns.length - 1]) || void 0 === _columns ? void 0 : _columns.index, rowIndex) : visibleColumnIndex === that.getVisibleIndex(null === (_columns$ = columns[0]) || void 0 === _columns$ ? void 0 : _columns$.index, rowIndex);\n};\nexport const isFirstOrLastColumn = function (that, targetColumn, rowIndex) {\n  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\n  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;\n  const targetColumnIndex = targetColumn.index;\n  const bandColumnsCache = that.getBandColumnsCache();\n  const parentBandColumns = getParentBandColumns(targetColumnIndex, bandColumnsCache.columnParentByIndex);\n  if (null !== parentBandColumns && void 0 !== parentBandColumns && parentBandColumns.length) {\n    return isFirstOrLastBandColumn(that, parentBandColumns.concat([targetColumn]), onlyWithinBandColumn, isLast, fixedPosition);\n  }\n  return onlyWithinBandColumn || isFirstOrLastColumnCore(that, targetColumn, rowIndex, onlyWithinBandColumn, isLast, fixedPosition);\n};","map":{"version":3,"names":["numberLocalization","normalizeIndexes","equalByValue","compileGetter","compileSetter","dateSerialization","extend","each","map","deepExtendArraySafe","getDefaultAlignment","isDefined","isFunction","isNumeric","isObject","isString","type","variableWrapper","HIDDEN_COLUMNS_WIDTH","gridCoreUtils","StickyPosition","getColumnFixedPosition","COLUMN_CHOOSER_LOCATION","COLUMN_INDEX_OPTIONS","DEFAULT_COLUMN_OPTIONS","GROUP_COMMAND_COLUMN_NAME","GROUP_LOCATION","IGNORE_COLUMN_OPTION_NAMES","USER_STATE_FIELD_NAMES","USER_STATE_FIELD_NAMES_15_1","setFilterOperationsAsDefaultValues","column","filterOperations","defaultFilterOperations","globalColumnId","createColumn","that","columnOptions","userStateColumnOptions","bandColumn","commonColumnOptions","dataField","setName","result","command","getCommonSettings","name","calculatedColumnOptions","_createCalculatedColumnOptions","headerId","selector","createColumnsFromOptions","columnsOptions","createdColumnCount","index","currentIndex","length","_columnsUserState","checkUserStateColumn","ownerBand","push","columns","concat","hasColumns","getParentBandColumns","columnIndex","columnParentByIndex","parent","unshift","getChildrenByBandColumn","columnChildrenByIndex","recursive","children","i","groupIndex","showWhenGrouped","isBand","getColumnByIndexes","columnIndexes","bandColumnsCache","getBandColumnsCache","callbackFilter","isPlain","_columns","filter","getColumnFullPath","item","indexOf","join","calculateColspan","columnID","colspan","_","processBandColumns","rowspan","visible","getRowCount","getValueDataType","value","dataType","getSerializationFormat","getDateSerializationFormat","updateSerializers","options","deserializeValue","isDateType","deserializeDate","serializeValue","serializeDate","serializationFormat","parsedValue","parseFloat","isNaN","target","toString","getAlignmentByDataType","isRTL","customizeTextForBooleanDataType","e","trueText","falseText","valueText","getCustomizeTextByDataType","createColumnsFromDataSource","dataSource","firstItems","_getFirstItems","fieldName","processedFields","isWrapped","updateColumnIndexes","_commandColumns","updateColumnGroupIndexes","currentColumn","grouped","updateColumnSortIndexes","sortIndex","isSortOrderValid","sortOrder","updateColumnVisibleIndexes","bandedColumns","parentBandColumns","getColumnIndexByVisibleIndex","visibleIndex","location","rowIndex","getGroupColumns","getChooserColumns","getVisibleColumns","col","moveColumnToGroup","groupColumns","Math","max","userStateColumn","applyUserState","columnsUserState","ignoreColumnOptionNames","_ignoreColumnOptionNames","columnCountById","resultColumns","allColumnsHaveState","userStateColumnIndexes","userStateColumnIndex","applyFieldsState","includes","defaultSelectedFilterOperation","findUserStateColumn","id","count","j","_hasUserState","initialIndex","hasAddedBands","columnUserState","added","assignColumns","updateIndexes","resetBandColumnsCache","resetColumnsCache","_previousColumns","updateColumnDataTypes","updateColumnChanges","changeType","optionName","columnChanges","_columnChanges","optionNames","changeTypes","split","columnIndices","fireColumnsChanged","onColumnsChanging","option","reinitOptionNames","isInitialized","_updateLockCount","component","some","_reinitAfterLookupChanges","lookup","reinit","columnsChanged","fire","updateSortOrderWhenGrouping","prevGroupIndex","columnWasGrouped","lastSortOrder","sortMode","sortedByAnotherColumn","fireOptionChanged","prevValue","fullOptionName","fullOptionPath","_skipProcessingColumnsChange","_notifyOptionChanged","columnOptionCore","notFireEvent","optionGetter","initialColumn","arguments","functionsAsIs","maxDepth","optionSetter","_checkColumns","getColumnByPath","addExpandColumn","_getExpandColumnOptions","addCommandColumn","defaultSetCellValue","data","path","dotCount","getDataColumns","bandColumnID","apply","rowCount","forEach","parents","invisibleParents","getFixedPosition","rtlEnabled","isCustomCommandColumn","fixedPosition","processExpandColumns","expandColumns","customColumnIndex","expandColumnsByType","expandColumn","splice","digitsCount","number","numberToString","str","mergeColumns","commandColumns","needToExtend","commandColumnIndex","slice","isColumnFixing","_isColumnFixing","defaultCommandColumns","fixed","getCommandColumnIndex","reduce","commandColumn","columnType","allowFixing","allowReordering","isColumnFixed","Sticky","convertOwnerBandToColumnReference","_bandColumnsCache","findColumn","identifier","identifierOptionName","substr","sortColumns","sign","sort","column1","column2","caption1","caption","caption2","localeCompare","strictParseNumber","text","format","parse","formattedValue","formattedValueWithDefaultFormat","isFirstOrLastBandColumn","bandColumns","onlyWithinBandColumn","isLast","every","isFirstOrLastColumnCore","_columns$","res","visibleWidth","visibleColumnIndex","getVisibleIndex","isFirstOrLastColumn","targetColumn","targetColumnIndex"],"sources":["C:/Users/Sofia/Desktop/Репозиторий ЦК/internship_project/client/node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/m_columns_controller_utils.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/grid_core/columns_controller/m_columns_controller_utils.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport numberLocalization from \"../../../../common/core/localization/number\";\r\nimport {\r\n    normalizeIndexes\r\n} from \"../../../../core/utils/array\";\r\nimport {\r\n    equalByValue\r\n} from \"../../../../core/utils/common\";\r\nimport {\r\n    compileGetter,\r\n    compileSetter\r\n} from \"../../../../core/utils/data\";\r\nimport dateSerialization from \"../../../../core/utils/date_serialization\";\r\nimport {\r\n    extend\r\n} from \"../../../../core/utils/extend\";\r\nimport {\r\n    each,\r\n    map\r\n} from \"../../../../core/utils/iterator\";\r\nimport {\r\n    deepExtendArraySafe\r\n} from \"../../../../core/utils/object\";\r\nimport {\r\n    getDefaultAlignment\r\n} from \"../../../../core/utils/position\";\r\nimport {\r\n    isDefined,\r\n    isFunction,\r\n    isNumeric,\r\n    isObject,\r\n    isString,\r\n    type\r\n} from \"../../../../core/utils/type\";\r\nimport variableWrapper from \"../../../../core/utils/variable_wrapper\";\r\nimport {\r\n    HIDDEN_COLUMNS_WIDTH\r\n} from \"../adaptivity/const\";\r\nimport gridCoreUtils from \"../m_utils\";\r\nimport {\r\n    StickyPosition\r\n} from \"../sticky_columns/const\";\r\nimport {\r\n    getColumnFixedPosition\r\n} from \"../sticky_columns/utils\";\r\nimport {\r\n    COLUMN_CHOOSER_LOCATION,\r\n    COLUMN_INDEX_OPTIONS,\r\n    DEFAULT_COLUMN_OPTIONS,\r\n    GROUP_COMMAND_COLUMN_NAME,\r\n    GROUP_LOCATION,\r\n    IGNORE_COLUMN_OPTION_NAMES,\r\n    USER_STATE_FIELD_NAMES,\r\n    USER_STATE_FIELD_NAMES_15_1\r\n} from \"./const\";\r\nexport const setFilterOperationsAsDefaultValues = function(column) {\r\n    column.filterOperations = column.defaultFilterOperations\r\n};\r\nlet globalColumnId = 1;\r\nexport const createColumn = function(that, columnOptions, userStateColumnOptions, bandColumn) {\r\n    let commonColumnOptions = {};\r\n    if (columnOptions) {\r\n        if (isString(columnOptions)) {\r\n            columnOptions = {\r\n                dataField: columnOptions\r\n            }\r\n        }\r\n        that.setName(columnOptions);\r\n        let result = {};\r\n        if (columnOptions.command) {\r\n            result = deepExtendArraySafe(commonColumnOptions, columnOptions)\r\n        } else {\r\n            commonColumnOptions = that.getCommonSettings(columnOptions);\r\n            if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {\r\n                columnOptions = extend({}, columnOptions, {\r\n                    dataField: userStateColumnOptions.dataField\r\n                })\r\n            }\r\n            const calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);\r\n            if (!columnOptions.type) {\r\n                result = {\r\n                    headerId: \"dx-col-\" + globalColumnId++\r\n                }\r\n            }\r\n            result = deepExtendArraySafe(result, DEFAULT_COLUMN_OPTIONS, false, true);\r\n            deepExtendArraySafe(result, commonColumnOptions, false, true);\r\n            deepExtendArraySafe(result, calculatedColumnOptions, false, true);\r\n            deepExtendArraySafe(result, columnOptions, false, true);\r\n            deepExtendArraySafe(result, {\r\n                selector: null\r\n            }, false, true)\r\n        }\r\n        if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {\r\n            setFilterOperationsAsDefaultValues(result)\r\n        }\r\n        return result\r\n    }\r\n};\r\nexport const createColumnsFromOptions = function(that, columnsOptions, bandColumn, createdColumnCount) {\r\n    let result = [];\r\n    if (columnsOptions) {\r\n        each(columnsOptions, ((index, columnOptions) => {\r\n            const currentIndex = (createdColumnCount ?? 0) + result.length;\r\n            const userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[currentIndex]) && that._columnsUserState[currentIndex];\r\n            const column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);\r\n            if (column) {\r\n                if (bandColumn) {\r\n                    column.ownerBand = bandColumn\r\n                }\r\n                result.push(column);\r\n                if (column.columns) {\r\n                    result = result.concat(createColumnsFromOptions(that, column.columns, column, result.length));\r\n                    delete column.columns;\r\n                    column.hasColumns = true\r\n                }\r\n            }\r\n        }))\r\n    }\r\n    return result\r\n};\r\nexport const getParentBandColumns = function(columnIndex, columnParentByIndex) {\r\n    const result = [];\r\n    let parent = columnParentByIndex[columnIndex];\r\n    while (parent) {\r\n        result.unshift(parent);\r\n        columnIndex = parent.index;\r\n        parent = columnParentByIndex[columnIndex]\r\n    }\r\n    return result\r\n};\r\nexport const getChildrenByBandColumn = function(columnIndex, columnChildrenByIndex, recursive) {\r\n    let result = [];\r\n    const children = columnChildrenByIndex[columnIndex];\r\n    if (children) {\r\n        for (let i = 0; i < children.length; i++) {\r\n            const column = children[i];\r\n            if (!isDefined(column.groupIndex) || column.showWhenGrouped) {\r\n                result.push(column);\r\n                if (recursive && column.isBand) {\r\n                    result = result.concat(getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive))\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result\r\n};\r\nexport const getColumnByIndexes = function(that, columnIndexes) {\r\n    let result;\r\n    let columns;\r\n    const bandColumnsCache = that.getBandColumnsCache();\r\n    const callbackFilter = function(column) {\r\n        const ownerBand = result ? result.index : void 0;\r\n        return column.ownerBand === ownerBand\r\n    };\r\n    if (bandColumnsCache.isPlain) {\r\n        result = that._columns[columnIndexes[0]]\r\n    } else {\r\n        columns = that._columns.filter(callbackFilter);\r\n        for (let i = 0; i < columnIndexes.length; i++) {\r\n            result = columns[columnIndexes[i]];\r\n            if (result) {\r\n                columns = that._columns.filter(callbackFilter)\r\n            }\r\n        }\r\n    }\r\n    return result\r\n};\r\nexport const getColumnFullPath = function(that, column) {\r\n    let result = [];\r\n    let columns;\r\n    const bandColumnsCache = that.getBandColumnsCache();\r\n    const callbackFilter = function(item) {\r\n        return item.ownerBand === column.ownerBand\r\n    };\r\n    if (bandColumnsCache.isPlain) {\r\n        const columnIndex = that._columns.indexOf(column);\r\n        if (columnIndex >= 0) {\r\n            result = [`columns[${columnIndex}]`]\r\n        }\r\n    } else {\r\n        columns = that._columns.filter(callbackFilter);\r\n        while (columns.length && -1 !== columns.indexOf(column)) {\r\n            result.unshift(`columns[${columns.indexOf(column)}]`);\r\n            column = bandColumnsCache.columnParentByIndex[column.index];\r\n            columns = column ? that._columns.filter(callbackFilter) : []\r\n        }\r\n    }\r\n    return result.join(\".\")\r\n};\r\nexport const calculateColspan = function(that, columnID) {\r\n    let colspan = 0;\r\n    const columns = that.getChildrenByBandColumn(columnID, true);\r\n    each(columns, ((_, column) => {\r\n        if (column.isBand) {\r\n            column.colspan = column.colspan || calculateColspan(that, column.index);\r\n            colspan += column.colspan || 1\r\n        } else {\r\n            colspan += 1\r\n        }\r\n    }));\r\n    return colspan\r\n};\r\nexport const processBandColumns = function(that, columns, bandColumnsCache) {\r\n    let rowspan;\r\n    for (let i = 0; i < columns.length; i++) {\r\n        const column = columns[i];\r\n        if (column.visible || column.command) {\r\n            if (column.isBand) {\r\n                column.colspan = column.colspan || calculateColspan(that, column.index)\r\n            }\r\n            if (!column.isBand || !column.colspan) {\r\n                rowspan = that.getRowCount();\r\n                if (!column.command && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {\r\n                    rowspan -= getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length\r\n                }\r\n                if (rowspan > 1) {\r\n                    column.rowspan = rowspan\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nexport const getValueDataType = function(value) {\r\n    let dataType = type(value);\r\n    if (\"string\" !== dataType && \"boolean\" !== dataType && \"number\" !== dataType && \"date\" !== dataType && \"object\" !== dataType) {\r\n        dataType = void 0\r\n    }\r\n    return dataType\r\n};\r\nexport const getSerializationFormat = function(dataType, value) {\r\n    switch (dataType) {\r\n        case \"date\":\r\n        case \"datetime\":\r\n            return dateSerialization.getDateSerializationFormat(value);\r\n        case \"number\":\r\n            if (isString(value)) {\r\n                return \"string\"\r\n            }\r\n            if (isNumeric(value)) {\r\n                return null\r\n            }\r\n    }\r\n};\r\nexport const updateSerializers = function(options, dataType) {\r\n    if (!options.deserializeValue) {\r\n        if (gridCoreUtils.isDateType(dataType)) {\r\n            options.deserializeValue = function(value) {\r\n                return dateSerialization.deserializeDate(value)\r\n            };\r\n            options.serializeValue = function(value) {\r\n                return isString(value) ? value : dateSerialization.serializeDate(value, this.serializationFormat)\r\n            }\r\n        }\r\n        if (\"number\" === dataType) {\r\n            options.deserializeValue = function(value) {\r\n                const parsedValue = parseFloat(value);\r\n                return isNaN(parsedValue) ? value : parsedValue\r\n            };\r\n            options.serializeValue = function(value, target) {\r\n                if (\"filter\" === target) {\r\n                    return value\r\n                }\r\n                return isDefined(value) && \"string\" === this.serializationFormat ? value.toString() : value\r\n            }\r\n        }\r\n    }\r\n};\r\nexport const getAlignmentByDataType = function(dataType, isRTL) {\r\n    switch (dataType) {\r\n        case \"number\":\r\n            return \"right\";\r\n        case \"boolean\":\r\n            return \"center\";\r\n        default:\r\n            return getDefaultAlignment(isRTL)\r\n    }\r\n};\r\nexport const customizeTextForBooleanDataType = function(e) {\r\n    if (true === e.value) {\r\n        return this.trueText || \"true\"\r\n    }\r\n    if (false === e.value) {\r\n        return this.falseText || \"false\"\r\n    }\r\n    return e.valueText || \"\"\r\n};\r\nexport const getCustomizeTextByDataType = function(dataType) {\r\n    if (\"boolean\" === dataType) {\r\n        return customizeTextForBooleanDataType\r\n    }\r\n};\r\nexport const createColumnsFromDataSource = function(that, dataSource) {\r\n    const firstItems = that._getFirstItems(dataSource);\r\n    let fieldName;\r\n    const processedFields = {};\r\n    const result = [];\r\n    for (let i = 0; i < firstItems.length; i++) {\r\n        if (firstItems[i]) {\r\n            for (fieldName in firstItems[i]) {\r\n                if (!isFunction(firstItems[i][fieldName]) || variableWrapper.isWrapped(firstItems[i][fieldName])) {\r\n                    processedFields[fieldName] = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (fieldName in processedFields) {\r\n        if (0 !== fieldName.indexOf(\"__\")) {\r\n            const column = createColumn(that, fieldName);\r\n            result.push(column)\r\n        }\r\n    }\r\n    return result\r\n};\r\nexport const updateColumnIndexes = function(that) {\r\n    each(that._columns, ((index, column) => {\r\n        column.index = index\r\n    }));\r\n    each(that._columns, ((index, column) => {\r\n        if (isObject(column.ownerBand)) {\r\n            column.ownerBand = column.ownerBand.index\r\n        }\r\n    }));\r\n    each(that._commandColumns, ((index, column) => {\r\n        column.index = -(index + 1)\r\n    }))\r\n};\r\nexport const updateColumnGroupIndexes = function(that, currentColumn) {\r\n    normalizeIndexes(that._columns, \"groupIndex\", currentColumn, (column => {\r\n        const {\r\n            grouped: grouped\r\n        } = column;\r\n        delete column.grouped;\r\n        return grouped\r\n    }))\r\n};\r\nexport const updateColumnSortIndexes = function(that, currentColumn) {\r\n    each(that._columns, ((index, column) => {\r\n        if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {\r\n            delete column.sortIndex\r\n        }\r\n    }));\r\n    normalizeIndexes(that._columns, \"sortIndex\", currentColumn, (column => !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder)))\r\n};\r\nexport const updateColumnVisibleIndexes = function(that, currentColumn) {\r\n    let column;\r\n    const result = [];\r\n    const bandColumnsCache = that.getBandColumnsCache();\r\n    const bandedColumns = [];\r\n    const columns = that._columns.filter((column => !column.command));\r\n    for (let i = 0; i < columns.length; i++) {\r\n        column = columns[i];\r\n        const parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);\r\n        if (parentBandColumns.length) {\r\n            bandedColumns.push(column)\r\n        } else {\r\n            result.push(column)\r\n        }\r\n    }\r\n    normalizeIndexes(bandedColumns, \"visibleIndex\", currentColumn);\r\n    normalizeIndexes(result, \"visibleIndex\", currentColumn)\r\n};\r\nexport const getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {\r\n    const rowIndex = isObject(visibleIndex) ? visibleIndex.rowIndex : null;\r\n    const columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);\r\n    let column;\r\n    visibleIndex = isObject(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;\r\n    column = columns[visibleIndex];\r\n    if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {\r\n        column = that._columns.filter((col => column.type === col.type))[0] || column\r\n    }\r\n    return column && isDefined(column.index) ? column.index : -1\r\n};\r\nexport const moveColumnToGroup = function(that, column, groupIndex) {\r\n    const groupColumns = that.getGroupColumns();\r\n    let i;\r\n    if (groupIndex >= 0) {\r\n        for (i = 0; i < groupColumns.length; i++) {\r\n            if (groupColumns[i].groupIndex >= groupIndex) {\r\n                groupColumns[i].groupIndex++\r\n            }\r\n        }\r\n    } else {\r\n        groupIndex = 0;\r\n        for (i = 0; i < groupColumns.length; i++) {\r\n            groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1)\r\n        }\r\n    }\r\n    return groupIndex\r\n};\r\n\r\nfunction checkUserStateColumn(column, userStateColumn) {\r\n    return column && userStateColumn && userStateColumn.name === (column.name || column.dataField) && (userStateColumn.dataField === column.dataField || column.name)\r\n}\r\nexport const applyUserState = function(that) {\r\n    const columnsUserState = that._columnsUserState;\r\n    const ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];\r\n    const columns = that._columns;\r\n    const columnCountById = {};\r\n    let resultColumns = [];\r\n    let allColumnsHaveState = true;\r\n    const userStateColumnIndexes = [];\r\n    let column;\r\n    let userStateColumnIndex;\r\n    let i;\r\n\r\n    function applyFieldsState(column, userStateColumn) {\r\n        if (!userStateColumn) {\r\n            return\r\n        }\r\n        for (let index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {\r\n            const fieldName = USER_STATE_FIELD_NAMES[index];\r\n            if (ignoreColumnOptionNames.includes(fieldName)) {\r\n                continue\r\n            }\r\n            if (\"dataType\" === fieldName) {\r\n                column[fieldName] = column[fieldName] || userStateColumn[fieldName]\r\n            } else if (USER_STATE_FIELD_NAMES_15_1.includes(fieldName)) {\r\n                if (fieldName in userStateColumn) {\r\n                    column[fieldName] = userStateColumn[fieldName]\r\n                }\r\n            } else {\r\n                if (\"selectedFilterOperation\" === fieldName && userStateColumn[fieldName]) {\r\n                    column.defaultSelectedFilterOperation = column[fieldName] || null\r\n                }\r\n                column[fieldName] = userStateColumn[fieldName]\r\n            }\r\n        }\r\n    }\r\n\r\n    function findUserStateColumn(columnsUserState, column) {\r\n        const id = column.name || column.dataField;\r\n        let count = columnCountById[id] || 0;\r\n        for (let j = 0; j < columnsUserState.length; j++) {\r\n            if (checkUserStateColumn(column, columnsUserState[j])) {\r\n                if (count) {\r\n                    count--\r\n                } else {\r\n                    columnCountById[id] = columnCountById[id] || 0;\r\n                    columnCountById[id]++;\r\n                    return j\r\n                }\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n    if (columnsUserState) {\r\n        for (i = 0; i < columns.length; i++) {\r\n            userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);\r\n            allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;\r\n            userStateColumnIndexes.push(userStateColumnIndex)\r\n        }\r\n        for (i = 0; i < columns.length; i++) {\r\n            column = columns[i];\r\n            userStateColumnIndex = userStateColumnIndexes[i];\r\n            if (that._hasUserState || allColumnsHaveState) {\r\n                applyFieldsState(column, columnsUserState[userStateColumnIndex])\r\n            }\r\n            if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {\r\n                resultColumns[userStateColumnIndex] = column\r\n            } else {\r\n                resultColumns.push(column)\r\n            }\r\n        }\r\n        let hasAddedBands = false;\r\n        for (i = 0; i < columnsUserState.length; i++) {\r\n            const columnUserState = columnsUserState[i];\r\n            if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {\r\n                column = createColumn(that, columnUserState.added);\r\n                applyFieldsState(column, columnUserState);\r\n                resultColumns.push(column);\r\n                if (columnUserState.added.columns) {\r\n                    hasAddedBands = true\r\n                }\r\n            }\r\n        }\r\n        if (hasAddedBands) {\r\n            updateColumnIndexes(that);\r\n            resultColumns = createColumnsFromOptions(that, resultColumns)\r\n        }\r\n        assignColumns(that, resultColumns)\r\n    }\r\n};\r\nexport const updateIndexes = function(that, column) {\r\n    updateColumnIndexes(that);\r\n    updateColumnGroupIndexes(that, column);\r\n    updateColumnSortIndexes(that, column);\r\n    resetBandColumnsCache(that);\r\n    updateColumnVisibleIndexes(that, column)\r\n};\r\nexport const resetColumnsCache = function(that) {\r\n    that.resetColumnsCache()\r\n};\r\nexport function assignColumns(that, columns) {\r\n    that._previousColumns = that._columns;\r\n    that._columns = columns;\r\n    resetColumnsCache(that);\r\n    that.updateColumnDataTypes()\r\n}\r\nexport const updateColumnChanges = function(that, changeType, optionName, columnIndex) {\r\n    const columnChanges = that._columnChanges || {\r\n        optionNames: {\r\n            length: 0\r\n        },\r\n        changeTypes: {\r\n            length: 0\r\n        },\r\n        columnIndex: columnIndex\r\n    };\r\n    optionName = optionName || \"all\";\r\n    optionName = optionName.split(\".\")[0];\r\n    const {\r\n        changeTypes: changeTypes\r\n    } = columnChanges;\r\n    if (changeType && !changeTypes[changeType]) {\r\n        changeTypes[changeType] = true;\r\n        changeTypes.length++\r\n    }\r\n    const {\r\n        optionNames: optionNames\r\n    } = columnChanges;\r\n    if (optionName && !optionNames[optionName]) {\r\n        optionNames[optionName] = true;\r\n        optionNames.length++\r\n    }\r\n    if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {\r\n        if (isDefined(columnIndex)) {\r\n            columnChanges.columnIndices ?? (columnChanges.columnIndices = []);\r\n            if (isDefined(columnChanges.columnIndex)) {\r\n                columnChanges.columnIndices.push(columnChanges.columnIndex)\r\n            }\r\n            columnChanges.columnIndices.push(columnIndex)\r\n        }\r\n        delete columnChanges.columnIndex\r\n    }\r\n    that._columnChanges = columnChanges;\r\n    resetColumnsCache(that)\r\n};\r\nexport const fireColumnsChanged = function(that) {\r\n    const onColumnsChanging = that.option(\"onColumnsChanging\");\r\n    const columnChanges = that._columnChanges;\r\n    const reinitOptionNames = [\"dataField\", \"lookup\", \"dataType\", \"columns\"];\r\n    if (that.isInitialized() && !that._updateLockCount && columnChanges) {\r\n        if (onColumnsChanging) {\r\n            that._updateLockCount++;\r\n            onColumnsChanging(extend({\r\n                component: that.component\r\n            }, columnChanges));\r\n            that._updateLockCount--\r\n        }\r\n        that._columnChanges = void 0;\r\n        if (options = columnChanges.optionNames, options && reinitOptionNames.some((name => options[name]))) {\r\n            that._reinitAfterLookupChanges = null === columnChanges || void 0 === columnChanges ? void 0 : columnChanges.optionNames.lookup;\r\n            that.reinit();\r\n            that._reinitAfterLookupChanges = void 0\r\n        } else {\r\n            that.columnsChanged.fire(columnChanges)\r\n        }\r\n    }\r\n    var options\r\n};\r\nexport const updateSortOrderWhenGrouping = function(that, column, groupIndex, prevGroupIndex) {\r\n    const columnWasGrouped = prevGroupIndex >= 0;\r\n    if (groupIndex >= 0) {\r\n        if (!columnWasGrouped) {\r\n            column.lastSortOrder = column.sortOrder\r\n        }\r\n    } else {\r\n        const sortMode = that.option(\"sorting.mode\");\r\n        let sortOrder = column.lastSortOrder;\r\n        if (\"single\" === sortMode) {\r\n            const sortedByAnotherColumn = that._columns.some((col => col !== column && isDefined(col.sortIndex)));\r\n            if (sortedByAnotherColumn) {\r\n                sortOrder = void 0\r\n            }\r\n        }\r\n        column.sortOrder = sortOrder\r\n    }\r\n};\r\nexport const fireOptionChanged = function(that, options) {\r\n    const {\r\n        value: value\r\n    } = options;\r\n    const {\r\n        optionName: optionName\r\n    } = options;\r\n    const {\r\n        prevValue: prevValue\r\n    } = options;\r\n    const {\r\n        fullOptionName: fullOptionName\r\n    } = options;\r\n    const fullOptionPath = `${fullOptionName}.${optionName}`;\r\n    if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {\r\n        that._skipProcessingColumnsChange = fullOptionPath;\r\n        that.component._notifyOptionChanged(fullOptionPath, value, prevValue);\r\n        that._skipProcessingColumnsChange = false\r\n    }\r\n};\r\nexport const columnOptionCore = function(that, column, optionName, value, notFireEvent) {\r\n    const optionGetter = compileGetter(optionName);\r\n    const columnIndex = column.index;\r\n    let columns;\r\n    let changeType;\r\n    let initialColumn;\r\n    if (3 === arguments.length) {\r\n        return optionGetter(column, {\r\n            functionsAsIs: true\r\n        })\r\n    }\r\n    const prevValue = optionGetter(column, {\r\n        functionsAsIs: true\r\n    });\r\n    if (!equalByValue(prevValue, value, {\r\n            maxDepth: 5\r\n        })) {\r\n        if (\"groupIndex\" === optionName || \"calculateGroupValue\" === optionName) {\r\n            changeType = \"grouping\";\r\n            updateSortOrderWhenGrouping(that, column, value, prevValue)\r\n        } else if (\"sortIndex\" === optionName || \"sortOrder\" === optionName || \"calculateSortValue\" === optionName) {\r\n            changeType = \"sorting\"\r\n        } else {\r\n            changeType = \"columns\"\r\n        }\r\n        const optionSetter = compileSetter(optionName);\r\n        optionSetter(column, value, {\r\n            functionsAsIs: true\r\n        });\r\n        const fullOptionName = getColumnFullPath(that, column);\r\n        if (COLUMN_INDEX_OPTIONS[optionName]) {\r\n            updateIndexes(that, column);\r\n            value = optionGetter(column)\r\n        }\r\n        if (\"name\" === optionName || \"allowEditing\" === optionName) {\r\n            that._checkColumns()\r\n        }\r\n        if (!isDefined(prevValue) && !isDefined(value) && 0 !== optionName.indexOf(\"buffer\") && false !== notFireEvent) {\r\n            notFireEvent = true\r\n        }\r\n        if (!notFireEvent) {\r\n            if (!USER_STATE_FIELD_NAMES.includes(optionName) && \"visibleWidth\" !== optionName) {\r\n                columns = that.option(\"columns\");\r\n                initialColumn = that.getColumnByPath(fullOptionName, columns);\r\n                if (isString(initialColumn)) {\r\n                    initialColumn = columns[columnIndex] = {\r\n                        dataField: initialColumn\r\n                    }\r\n                }\r\n                if (initialColumn && checkUserStateColumn(initialColumn, column)) {\r\n                    optionSetter(initialColumn, value, {\r\n                        functionsAsIs: true\r\n                    })\r\n                }\r\n            }\r\n            updateColumnChanges(that, changeType, optionName, columnIndex)\r\n        } else {\r\n            resetColumnsCache(that)\r\n        }\r\n        fullOptionName && fireOptionChanged(that, {\r\n            fullOptionName: fullOptionName,\r\n            optionName: optionName,\r\n            value: value,\r\n            prevValue: prevValue\r\n        })\r\n    }\r\n};\r\nexport function isSortOrderValid(sortOrder) {\r\n    return \"asc\" === sortOrder || \"desc\" === sortOrder\r\n}\r\nexport const addExpandColumn = function(that) {\r\n    const options = that._getExpandColumnOptions();\r\n    that.addCommandColumn(options)\r\n};\r\nexport const defaultSetCellValue = function(data, value) {\r\n    if (!this.dataField) {\r\n        return\r\n    }\r\n    const path = this.dataField.split(\".\");\r\n    const dotCount = path.length - 1;\r\n    if (this.serializeValue) {\r\n        value = this.serializeValue(value)\r\n    }\r\n    for (let i = 0; i < dotCount; i++) {\r\n        const name = path[i];\r\n        data = data[name] = data[name] || {}\r\n    }\r\n    data[path[dotCount]] = value\r\n};\r\nexport const getDataColumns = function(columns, rowIndex, bandColumnID) {\r\n    const result = [];\r\n    rowIndex = rowIndex || 0;\r\n    columns[rowIndex] && each(columns[rowIndex], ((_, column) => {\r\n        if (column.ownerBand === bandColumnID || column.type === GROUP_COMMAND_COLUMN_NAME) {\r\n            if (!column.isBand || !column.colspan) {\r\n                if (!column.command || rowIndex < 1) {\r\n                    result.push(column)\r\n                }\r\n            } else {\r\n                result.push.apply(result, getDataColumns(columns, rowIndex + 1, column.index))\r\n            }\r\n        }\r\n    }));\r\n    return result\r\n};\r\nexport const getRowCount = function(that) {\r\n    let rowCount = 1;\r\n    const bandColumnsCache = that.getBandColumnsCache();\r\n    const {\r\n        columnParentByIndex: columnParentByIndex\r\n    } = bandColumnsCache;\r\n    that._columns.forEach((column => {\r\n        const parents = getParentBandColumns(column.index, columnParentByIndex);\r\n        const invisibleParents = parents.filter((column => !column.visible));\r\n        if (column.visible && !invisibleParents.length) {\r\n            rowCount = Math.max(rowCount, parents.length + 1)\r\n        }\r\n    }));\r\n    return rowCount\r\n};\r\nexport const getFixedPosition = function(that, column) {\r\n    const rtlEnabled = that.option(\"rtlEnabled\");\r\n    if (column.command && !gridCoreUtils.isCustomCommandColumn(that._columns, column) || !column.fixedPosition) {\r\n        return rtlEnabled ? \"right\" : \"left\"\r\n    }\r\n    return column.fixedPosition\r\n};\r\nexport const processExpandColumns = function(columns, expandColumns, type, columnIndex) {\r\n    let customColumnIndex;\r\n    const rowCount = this.getRowCount();\r\n    let rowspan = columns[columnIndex] && columns[columnIndex].rowspan;\r\n    let expandColumnsByType = expandColumns.filter((column => column.type === type));\r\n    columns.forEach(((column, index) => {\r\n        if (column.type === type) {\r\n            customColumnIndex = index;\r\n            rowspan = columns[index + 1] ? columns[index + 1].rowspan : rowCount\r\n        }\r\n    }));\r\n    if (rowspan > 1) {\r\n        expandColumnsByType = map(expandColumnsByType, (expandColumn => extend({}, expandColumn, {\r\n            rowspan: rowspan\r\n        })))\r\n    }\r\n    expandColumnsByType.unshift.apply(expandColumnsByType, isDefined(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);\r\n    columns.splice.apply(columns, expandColumnsByType);\r\n    return rowspan || 1\r\n};\r\nexport const digitsCount = function(number) {\r\n    let i;\r\n    for (i = 0; number > 1; i++) {\r\n        number /= 10\r\n    }\r\n    return i\r\n};\r\nexport const numberToString = function(number, digitsCount) {\r\n    let str = number ? number.toString() : \"0\";\r\n    while (str.length < digitsCount) {\r\n        str = `0${str}`\r\n    }\r\n    return str\r\n};\r\nexport const mergeColumns = (that, columns, commandColumns, needToExtend) => {\r\n    let column;\r\n    let commandColumnIndex;\r\n    let result = columns.slice().map((column => extend({}, column)));\r\n    const isColumnFixing = that._isColumnFixing();\r\n    let defaultCommandColumns = commandColumns.slice().map((column => extend({\r\n        fixed: isColumnFixing\r\n    }, column)));\r\n    const getCommandColumnIndex = column => commandColumns.reduce(((result, commandColumn, index) => {\r\n        const columnType = needToExtend && column.type === GROUP_COMMAND_COLUMN_NAME ? \"expand\" : column.type;\r\n        return commandColumn.type === columnType || commandColumn.command === column.command ? index : result\r\n    }), -1);\r\n    const callbackFilter = commandColumn => commandColumn.command !== commandColumns[commandColumnIndex].command;\r\n    for (let i = 0; i < columns.length; i++) {\r\n        column = columns[i];\r\n        commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;\r\n        if (commandColumnIndex >= 0) {\r\n            if (needToExtend) {\r\n                result[i] = extend({\r\n                    fixed: isColumnFixing\r\n                }, commandColumns[commandColumnIndex], column);\r\n                if (column.type !== GROUP_COMMAND_COLUMN_NAME) {\r\n                    defaultCommandColumns = defaultCommandColumns.filter(callbackFilter)\r\n                }\r\n            } else {\r\n                const columnOptions = {\r\n                    visibleIndex: column.visibleIndex,\r\n                    index: column.index,\r\n                    headerId: column.headerId,\r\n                    allowFixing: 0 === column.groupIndex,\r\n                    allowReordering: 0 === column.groupIndex,\r\n                    groupIndex: column.groupIndex\r\n                };\r\n                result[i] = extend({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions)\r\n            }\r\n        }\r\n    }\r\n    if (columns.length && needToExtend && defaultCommandColumns.length) {\r\n        result = result.concat(defaultCommandColumns)\r\n    }\r\n    return result\r\n};\r\nexport const isColumnFixed = (that, column) => isDefined(column.fixed) || !column.type ? column.fixed && column.fixedPosition !== StickyPosition.Sticky : that._isColumnFixing();\r\nexport const convertOwnerBandToColumnReference = columns => {\r\n    columns.forEach((column => {\r\n        if (isDefined(column.ownerBand)) {\r\n            column.ownerBand = columns[column.ownerBand]\r\n        }\r\n    }))\r\n};\r\nexport const resetBandColumnsCache = that => {\r\n    that._bandColumnsCache = void 0\r\n};\r\nexport const findColumn = (columns, identifier) => {\r\n    const identifierOptionName = isString(identifier) && identifier.substr(0, identifier.indexOf(\":\"));\r\n    let column;\r\n    if (void 0 === identifier) {\r\n        return\r\n    }\r\n    if (identifierOptionName) {\r\n        identifier = identifier.substr(identifierOptionName.length + 1)\r\n    }\r\n    if (identifierOptionName) {\r\n        column = columns.filter((column => `${column[identifierOptionName]}` === identifier))[0]\r\n    } else {\r\n        [\"index\", \"name\", \"dataField\", \"caption\"].some((optionName => {\r\n            column = columns.filter((column => column[optionName] === identifier))[0];\r\n            return !!column\r\n        }))\r\n    }\r\n    return column\r\n};\r\nexport const sortColumns = (columns, sortOrder) => {\r\n    if (\"asc\" !== sortOrder && \"desc\" !== sortOrder) {\r\n        return columns\r\n    }\r\n    const sign = \"asc\" === sortOrder ? 1 : -1;\r\n    columns.sort(((column1, column2) => {\r\n        const caption1 = column1.caption || \"\";\r\n        const caption2 = column2.caption || \"\";\r\n        return sign * caption1.localeCompare(caption2)\r\n    }));\r\n    return columns\r\n};\r\nexport const strictParseNumber = function(text, format) {\r\n    const parsedValue = numberLocalization.parse(text);\r\n    if (isNumeric(parsedValue)) {\r\n        const formattedValue = numberLocalization.format(parsedValue, format);\r\n        const formattedValueWithDefaultFormat = numberLocalization.format(parsedValue, \"decimal\");\r\n        if (formattedValue === text || formattedValueWithDefaultFormat === text) {\r\n            return parsedValue\r\n        }\r\n    }\r\n};\r\nconst isFirstOrLastBandColumn = function(that, bandColumns) {\r\n    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\r\n    let isLast = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\r\n    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;\r\n    return bandColumns.every(((column, index) => onlyWithinBandColumn && 0 === index || isFirstOrLastColumnCore(that, column, index, onlyWithinBandColumn, isLast, fixedPosition)))\r\n};\r\nconst isFirstOrLastColumnCore = function(that, column, rowIndex) {\r\n    var _columns, _columns$;\r\n    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\r\n    let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\r\n    let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;\r\n    const columnIndex = column.index;\r\n    const columns = (index = rowIndex, that.getVisibleColumns(index).filter((col => {\r\n        let res = true;\r\n        if (col.visibleWidth === HIDDEN_COLUMNS_WIDTH) {\r\n            return false\r\n        }\r\n        if (onlyWithinBandColumn && column) {\r\n            res && (res = col.ownerBand === column.ownerBand)\r\n        } else if (fixedPosition) {\r\n            res && (res = col.fixed && getColumnFixedPosition(that, col) === fixedPosition)\r\n        }\r\n        return res\r\n    })));\r\n    var index;\r\n    const visibleColumnIndex = that.getVisibleIndex(columnIndex, rowIndex);\r\n    return isLast ? visibleColumnIndex === that.getVisibleIndex(null === (_columns = columns[columns.length - 1]) || void 0 === _columns ? void 0 : _columns.index, rowIndex) : visibleColumnIndex === that.getVisibleIndex(null === (_columns$ = columns[0]) || void 0 === _columns$ ? void 0 : _columns$.index, rowIndex)\r\n};\r\nexport const isFirstOrLastColumn = function(that, targetColumn, rowIndex) {\r\n    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\r\n    let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\r\n    let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;\r\n    const targetColumnIndex = targetColumn.index;\r\n    const bandColumnsCache = that.getBandColumnsCache();\r\n    const parentBandColumns = getParentBandColumns(targetColumnIndex, bandColumnsCache.columnParentByIndex);\r\n    if (null !== parentBandColumns && void 0 !== parentBandColumns && parentBandColumns.length) {\r\n        return isFirstOrLastBandColumn(that, parentBandColumns.concat([targetColumn]), onlyWithinBandColumn, isLast, fixedPosition)\r\n    }\r\n    return onlyWithinBandColumn || isFirstOrLastColumnCore(that, targetColumn, rowIndex, onlyWithinBandColumn, isLast, fixedPosition)\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}