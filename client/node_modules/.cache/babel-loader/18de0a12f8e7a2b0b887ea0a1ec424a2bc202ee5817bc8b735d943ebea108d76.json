{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/grid_core/sticky_columns/dom.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../../../core/renderer\";\nimport { getBoundingRect } from \"../../../../core/utils/position\";\nimport { isDefined } from \"../../../../core/utils/type\";\nimport { CLASSES, StickyPosition } from \"./const\";\nimport { isFixedEdge } from \"./utils\";\nconst addStickyColumnBorderLeftClass = ($cell, addWidgetPrefix) => {\n  $cell.addClass(addWidgetPrefix(CLASSES.stickyColumnBorderLeft));\n};\nconst addStickyColumnBorderRightClass = ($cell, addWidgetPrefix) => {\n  $cell.addClass(addWidgetPrefix(CLASSES.stickyColumnBorderRight));\n};\nconst addStickyColumnClass = ($cell, fixedPosition, addWidgetPrefix) => {\n  switch (fixedPosition) {\n    case StickyPosition.Right:\n      $cell.addClass(addWidgetPrefix(CLASSES.stickyColumnRight));\n      break;\n    case StickyPosition.Sticky:\n      $cell.addClass(addWidgetPrefix(CLASSES.stickyColumn));\n      break;\n    default:\n      $cell.addClass(addWidgetPrefix(CLASSES.stickyColumnLeft));\n  }\n};\nconst toggleFirstHeaderClass = ($cell, value, addWidgetPrefix) => {\n  $cell.toggleClass(addWidgetPrefix(CLASSES.firstHeader), value);\n};\nconst toggleColumnNoBorderClass = ($cell, value, addWidgetPrefix) => {\n  $cell.toggleClass(addWidgetPrefix(CLASSES.columnNoBorder), value);\n};\nconst toggleStickyColumnsClass = ($element, hasStickyColumns, addWidgetPrefix) => {\n  $element.toggleClass(addWidgetPrefix(CLASSES.stickyColumns), hasStickyColumns);\n};\nconst isStickyCellPinnedToLeft = ($cell, $container, addWidgetPrefix) => {\n  const isStickyCell = $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumn));\n  if (!isStickyCell) {\n    return false;\n  }\n  const cellLeft = parseFloat($cell[0].style.left);\n  const cellRect = getBoundingRect($cell[0]);\n  const containerRect = getBoundingRect($container[0]);\n  const calculatedCellLeft = cellRect.left - containerRect.left;\n  return Math.round(cellLeft) >= Math.round(calculatedCellLeft);\n};\nconst isStickyCellPinnedToRight = ($cell, $container, addWidgetPrefix) => {\n  const isStickyCell = $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumn));\n  if (!isStickyCell) {\n    return false;\n  }\n  const cellRight = parseFloat($cell[0].style.right);\n  const cellRect = getBoundingRect($cell[0]);\n  const containerRect = getBoundingRect($container[0]);\n  const calculatedCellRight = containerRect.right - cellRect.right;\n  return Math.round(cellRight) >= Math.round(calculatedCellRight);\n};\nconst isStickyCellPinned = ($cell, $container, addWidgetPrefix) => isStickyCellPinnedToLeft($cell, $container, addWidgetPrefix) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);\nconst isFixedCellPinnedToRight = ($cell, $container, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnRight)) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);\nconst isLastLeftFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnLeft)) && $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnBorderRight));\nconst isFirstRightFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnRight)) && $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnBorderLeft));\nconst isStickyCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumn));\nconst isFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnLeft)) || $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnRight)) || $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumn));\nconst getLeftFixedCells = ($cells, addWidgetPrefix) => $cells.filter((_, cell) => $(cell).hasClass(addWidgetPrefix(CLASSES.stickyColumnLeft)));\nconst getRightFixedCells = ($cells, addWidgetPrefix) => $cells.filter((_, cell) => $(cell).hasClass(addWidgetPrefix(CLASSES.stickyColumnRight)));\nconst getNonFixedAndStickyCells = ($cells, addWidgetPrefix) => $cells.filter((_, cell) => $(cell).hasClass(addWidgetPrefix(CLASSES.stickyColumn)) || !isFixedCell($(cell), addWidgetPrefix));\nconst getLastLeftFixedCell = ($cells, $container, addWidgetPrefix) => {\n  const rtlEnabled = \"rtl\" === $container.css(\"direction\");\n  const processedCells = rtlEnabled ? $cells.toArray() : $cells.toArray().reverse();\n  const lastLeftFixedCell = processedCells.find(cell => isStickyCellPinnedToLeft($(cell), $container, addWidgetPrefix) || isLastLeftFixedCell($(cell), addWidgetPrefix));\n  return $(lastLeftFixedCell ?? \"\");\n};\nconst getFirstRightFixedCell = ($cells, $container, addWidgetPrefix) => {\n  const rtlEnabled = \"rtl\" === $container.css(\"direction\");\n  const processedCells = rtlEnabled ? $cells.toArray().reverse() : $cells.toArray();\n  const firstRightFixedCell = processedCells.find(cell => isStickyCellPinnedToRight($(cell), $container, addWidgetPrefix) || isFirstRightFixedCell($(cell), addWidgetPrefix));\n  return $(firstRightFixedCell ?? \"\");\n};\nconst getNonFixedAreaBoundingRect = ($cells, $container, addWidgetPrefix) => {\n  const containerRect = getBoundingRect($container.get(0));\n  const result = {\n    left: containerRect.left,\n    right: containerRect.right\n  };\n  if (null !== $cells && void 0 !== $cells && $cells.length) {\n    const $lastLeftFixedCell = getLastLeftFixedCell($cells, $container, addWidgetPrefix);\n    const $firstRightFixedCell = getFirstRightFixedCell($cells, $container, addWidgetPrefix);\n    if (null !== $lastLeftFixedCell && void 0 !== $lastLeftFixedCell && $lastLeftFixedCell.length) {\n      result.left = Math.round(getBoundingRect($lastLeftFixedCell[0]).right);\n    }\n    if (null !== $firstRightFixedCell && void 0 !== $firstRightFixedCell && $firstRightFixedCell.length) {\n      result.right = Math.round(getBoundingRect($firstRightFixedCell[0]).left);\n    }\n  }\n  return result;\n};\nconst noNeedToCreateResizingPoint = (that, _ref, addWidgetPrefix) => {\n  let {\n    point: point,\n    column: column,\n    nextColumn: nextColumn\n  } = _ref;\n  const {\n    item: item,\n    isLeftBoundary: isLeftBoundary,\n    isRightBoundary: isRightBoundary\n  } = point;\n  const $item = $(item);\n  const offsetX = Math.round(point.x);\n  const rtlEnabled = that.option(\"rtlEnabled\");\n  const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);\n  const $cells = $(that.getColumnElements() ?? \"\");\n  const $container = $(that.getContent());\n  const isFixedPoint = (null === column || void 0 === column ? void 0 : column.fixed) && (null === nextColumn || void 0 === nextColumn ? void 0 : nextColumn.fixed);\n  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);\n  if (isFixedPoint || isFixedEdge(point, column, nextColumn)) {\n    return false;\n  }\n  if (isSplitPoint) {\n    if (isLastLeftFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {\n      return isLeftBoundary;\n    }\n    if (isFirstRightFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {\n      return isRightBoundary;\n    }\n  }\n  const isOutsideVisibleArea = offsetX < nonFixedAreaBoundingRect.left || offsetX > nonFixedAreaBoundingRect.right;\n  const isPointBoundary = offsetX === nonFixedAreaBoundingRect.left || offsetX === nonFixedAreaBoundingRect.right;\n  const isLastOrFirstPoint = rtlEnabled ? 0 === point.index : point.index === $cells.length;\n  return isOutsideVisibleArea || !isLastOrFirstPoint && isPointBoundary;\n};\nconst noNeedToCreateReorderingPoint = (point, $cells, $container, addWidgetPrefix) => {\n  const {\n    item: item,\n    isLeftBoundary: isLeftBoundary,\n    isRightBoundary: isRightBoundary\n  } = point;\n  const $item = $(item);\n  const pointX = Math.round(point.x);\n  const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);\n  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);\n  if (isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {\n    return isSplitPoint && !isLeftBoundary;\n  }\n  if (isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {\n    return isSplitPoint && !isRightBoundary;\n  }\n  return pointX < nonFixedAreaBoundingRect.left || pointX > nonFixedAreaBoundingRect.right;\n};\nconst doesGroupCellEndInFirstColumn = $groupCell => {\n  const $groupRow = $groupCell.parent();\n  const commandColumns = $groupRow.children().filter(i => i < $groupCell.index());\n  const groupColSpanWithoutCommand = $groupCell.attr(\"colspan\") - commandColumns.length;\n  return 1 === groupColSpanWithoutCommand;\n};\nconst getScrollPadding = ($cells, $container, addWidgetPrefix) => {\n  const containerRect = getBoundingRect($container.get(0));\n  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);\n  return {\n    left: nonFixedAreaBoundingRect.left - containerRect.left,\n    right: containerRect.right - nonFixedAreaBoundingRect.right\n  };\n};\nconst isOutsideVisibleArea = ($element, $cells, $container, addWidgetPrefix) => {\n  const elementRect = getBoundingRect($element.get(0));\n  const elementRectLeft = Math.round(elementRect.left);\n  const elementRectRight = Math.round(elementRect.right);\n  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);\n  return elementRectLeft < nonFixedAreaBoundingRect.left || elementRectRight > nonFixedAreaBoundingRect.right;\n};\nconst isLastCell = $cell => {\n  if (!$cell.is(\"td\")) {\n    return false;\n  }\n  const $lastCell = $cell.parent().children().last();\n  return $cell[0] === $lastCell[0];\n};\nconst needToSkipHeaderCell = $cell => !$cell.is(\"[tabindex]\");\nconst getNextHeaderCell = function ($cell) {\n  let direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"next\";\n  let $nextCell = $cell;\n  let $nextRow = $cell.parent();\n  do {\n    $nextCell = \"next\" === direction ? $nextCell.next() : $nextCell.prev();\n    if (!$nextCell.length) {\n      $nextRow = \"next\" === direction ? $nextRow.next() : $nextRow.prev();\n      if ($nextRow.length) {\n        $nextCell = \"next\" === direction ? $nextRow.children().first() : $nextRow.children().last();\n      }\n    }\n  } while ($nextCell.length && needToSkipHeaderCell($nextCell));\n  return $nextCell;\n};\nexport const GridCoreStickyColumnsDom = {\n  toggleFirstHeaderClass: toggleFirstHeaderClass,\n  toggleColumnNoBorderClass: toggleColumnNoBorderClass,\n  addStickyColumnClass: addStickyColumnClass,\n  addStickyColumnBorderLeftClass: addStickyColumnBorderLeftClass,\n  addStickyColumnBorderRightClass: addStickyColumnBorderRightClass,\n  doesGroupCellEndInFirstColumn: doesGroupCellEndInFirstColumn,\n  toggleStickyColumnsClass: toggleStickyColumnsClass,\n  getLeftFixedCells: getLeftFixedCells,\n  getRightFixedCells: getRightFixedCells,\n  getNonFixedAndStickyCells: getNonFixedAndStickyCells,\n  getScrollPadding: getScrollPadding,\n  getNextHeaderCell: getNextHeaderCell,\n  noNeedToCreateResizingPoint: noNeedToCreateResizingPoint,\n  isFixedCellPinnedToRight: isFixedCellPinnedToRight,\n  noNeedToCreateReorderingPoint: noNeedToCreateReorderingPoint,\n  isFixedCell: isFixedCell,\n  isStickyCell: isStickyCell,\n  isStickyCellPinned: isStickyCellPinned,\n  isOutsideVisibleArea: isOutsideVisibleArea,\n  isLastCell: isLastCell\n};","map":{"version":3,"names":["$","getBoundingRect","isDefined","CLASSES","StickyPosition","isFixedEdge","addStickyColumnBorderLeftClass","$cell","addWidgetPrefix","addClass","stickyColumnBorderLeft","addStickyColumnBorderRightClass","stickyColumnBorderRight","addStickyColumnClass","fixedPosition","Right","stickyColumnRight","Sticky","stickyColumn","stickyColumnLeft","toggleFirstHeaderClass","value","toggleClass","firstHeader","toggleColumnNoBorderClass","columnNoBorder","toggleStickyColumnsClass","$element","hasStickyColumns","stickyColumns","isStickyCellPinnedToLeft","$container","isStickyCell","hasClass","cellLeft","parseFloat","style","left","cellRect","containerRect","calculatedCellLeft","Math","round","isStickyCellPinnedToRight","cellRight","right","calculatedCellRight","isStickyCellPinned","isFixedCellPinnedToRight","isLastLeftFixedCell","isFirstRightFixedCell","isFixedCell","getLeftFixedCells","$cells","filter","_","cell","getRightFixedCells","getNonFixedAndStickyCells","getLastLeftFixedCell","rtlEnabled","css","processedCells","toArray","reverse","lastLeftFixedCell","find","getFirstRightFixedCell","firstRightFixedCell","getNonFixedAreaBoundingRect","get","result","length","$lastLeftFixedCell","$firstRightFixedCell","noNeedToCreateResizingPoint","that","_ref","point","column","nextColumn","item","isLeftBoundary","isRightBoundary","$item","offsetX","x","option","isSplitPoint","getColumnElements","getContent","isFixedPoint","fixed","nonFixedAreaBoundingRect","isOutsideVisibleArea","isPointBoundary","isLastOrFirstPoint","index","noNeedToCreateReorderingPoint","pointX","doesGroupCellEndInFirstColumn","$groupCell","$groupRow","parent","commandColumns","children","i","groupColSpanWithoutCommand","attr","getScrollPadding","elementRect","elementRectLeft","elementRectRight","isLastCell","is","$lastCell","last","needToSkipHeaderCell","getNextHeaderCell","direction","arguments","$nextCell","$nextRow","next","prev","first","GridCoreStickyColumnsDom"],"sources":["C:/Users/Sofia/Desktop/Репозиторий ЦК/internship_project/client/node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/dom.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/grid_core/sticky_columns/dom.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport $ from \"../../../../core/renderer\";\r\nimport {\r\n    getBoundingRect\r\n} from \"../../../../core/utils/position\";\r\nimport {\r\n    isDefined\r\n} from \"../../../../core/utils/type\";\r\nimport {\r\n    CLASSES,\r\n    StickyPosition\r\n} from \"./const\";\r\nimport {\r\n    isFixedEdge\r\n} from \"./utils\";\r\nconst addStickyColumnBorderLeftClass = ($cell, addWidgetPrefix) => {\r\n    $cell.addClass(addWidgetPrefix(CLASSES.stickyColumnBorderLeft))\r\n};\r\nconst addStickyColumnBorderRightClass = ($cell, addWidgetPrefix) => {\r\n    $cell.addClass(addWidgetPrefix(CLASSES.stickyColumnBorderRight))\r\n};\r\nconst addStickyColumnClass = ($cell, fixedPosition, addWidgetPrefix) => {\r\n    switch (fixedPosition) {\r\n        case StickyPosition.Right:\r\n            $cell.addClass(addWidgetPrefix(CLASSES.stickyColumnRight));\r\n            break;\r\n        case StickyPosition.Sticky:\r\n            $cell.addClass(addWidgetPrefix(CLASSES.stickyColumn));\r\n            break;\r\n        default:\r\n            $cell.addClass(addWidgetPrefix(CLASSES.stickyColumnLeft))\r\n    }\r\n};\r\nconst toggleFirstHeaderClass = ($cell, value, addWidgetPrefix) => {\r\n    $cell.toggleClass(addWidgetPrefix(CLASSES.firstHeader), value)\r\n};\r\nconst toggleColumnNoBorderClass = ($cell, value, addWidgetPrefix) => {\r\n    $cell.toggleClass(addWidgetPrefix(CLASSES.columnNoBorder), value)\r\n};\r\nconst toggleStickyColumnsClass = ($element, hasStickyColumns, addWidgetPrefix) => {\r\n    $element.toggleClass(addWidgetPrefix(CLASSES.stickyColumns), hasStickyColumns)\r\n};\r\nconst isStickyCellPinnedToLeft = ($cell, $container, addWidgetPrefix) => {\r\n    const isStickyCell = $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumn));\r\n    if (!isStickyCell) {\r\n        return false\r\n    }\r\n    const cellLeft = parseFloat($cell[0].style.left);\r\n    const cellRect = getBoundingRect($cell[0]);\r\n    const containerRect = getBoundingRect($container[0]);\r\n    const calculatedCellLeft = cellRect.left - containerRect.left;\r\n    return Math.round(cellLeft) >= Math.round(calculatedCellLeft)\r\n};\r\nconst isStickyCellPinnedToRight = ($cell, $container, addWidgetPrefix) => {\r\n    const isStickyCell = $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumn));\r\n    if (!isStickyCell) {\r\n        return false\r\n    }\r\n    const cellRight = parseFloat($cell[0].style.right);\r\n    const cellRect = getBoundingRect($cell[0]);\r\n    const containerRect = getBoundingRect($container[0]);\r\n    const calculatedCellRight = containerRect.right - cellRect.right;\r\n    return Math.round(cellRight) >= Math.round(calculatedCellRight)\r\n};\r\nconst isStickyCellPinned = ($cell, $container, addWidgetPrefix) => isStickyCellPinnedToLeft($cell, $container, addWidgetPrefix) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);\r\nconst isFixedCellPinnedToRight = ($cell, $container, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnRight)) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);\r\nconst isLastLeftFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnLeft)) && $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnBorderRight));\r\nconst isFirstRightFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnRight)) && $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnBorderLeft));\r\nconst isStickyCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumn));\r\nconst isFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnLeft)) || $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumnRight)) || $cell.hasClass(addWidgetPrefix(CLASSES.stickyColumn));\r\nconst getLeftFixedCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => $(cell).hasClass(addWidgetPrefix(CLASSES.stickyColumnLeft))));\r\nconst getRightFixedCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => $(cell).hasClass(addWidgetPrefix(CLASSES.stickyColumnRight))));\r\nconst getNonFixedAndStickyCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => $(cell).hasClass(addWidgetPrefix(CLASSES.stickyColumn)) || !isFixedCell($(cell), addWidgetPrefix)));\r\nconst getLastLeftFixedCell = ($cells, $container, addWidgetPrefix) => {\r\n    const rtlEnabled = \"rtl\" === $container.css(\"direction\");\r\n    const processedCells = rtlEnabled ? $cells.toArray() : $cells.toArray().reverse();\r\n    const lastLeftFixedCell = processedCells.find((cell => isStickyCellPinnedToLeft($(cell), $container, addWidgetPrefix) || isLastLeftFixedCell($(cell), addWidgetPrefix)));\r\n    return $(lastLeftFixedCell ?? \"\")\r\n};\r\nconst getFirstRightFixedCell = ($cells, $container, addWidgetPrefix) => {\r\n    const rtlEnabled = \"rtl\" === $container.css(\"direction\");\r\n    const processedCells = rtlEnabled ? $cells.toArray().reverse() : $cells.toArray();\r\n    const firstRightFixedCell = processedCells.find((cell => isStickyCellPinnedToRight($(cell), $container, addWidgetPrefix) || isFirstRightFixedCell($(cell), addWidgetPrefix)));\r\n    return $(firstRightFixedCell ?? \"\")\r\n};\r\nconst getNonFixedAreaBoundingRect = ($cells, $container, addWidgetPrefix) => {\r\n    const containerRect = getBoundingRect($container.get(0));\r\n    const result = {\r\n        left: containerRect.left,\r\n        right: containerRect.right\r\n    };\r\n    if (null !== $cells && void 0 !== $cells && $cells.length) {\r\n        const $lastLeftFixedCell = getLastLeftFixedCell($cells, $container, addWidgetPrefix);\r\n        const $firstRightFixedCell = getFirstRightFixedCell($cells, $container, addWidgetPrefix);\r\n        if (null !== $lastLeftFixedCell && void 0 !== $lastLeftFixedCell && $lastLeftFixedCell.length) {\r\n            result.left = Math.round(getBoundingRect($lastLeftFixedCell[0]).right)\r\n        }\r\n        if (null !== $firstRightFixedCell && void 0 !== $firstRightFixedCell && $firstRightFixedCell.length) {\r\n            result.right = Math.round(getBoundingRect($firstRightFixedCell[0]).left)\r\n        }\r\n    }\r\n    return result\r\n};\r\nconst noNeedToCreateResizingPoint = (that, _ref, addWidgetPrefix) => {\r\n    let {\r\n        point: point,\r\n        column: column,\r\n        nextColumn: nextColumn\r\n    } = _ref;\r\n    const {\r\n        item: item,\r\n        isLeftBoundary: isLeftBoundary,\r\n        isRightBoundary: isRightBoundary\r\n    } = point;\r\n    const $item = $(item);\r\n    const offsetX = Math.round(point.x);\r\n    const rtlEnabled = that.option(\"rtlEnabled\");\r\n    const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);\r\n    const $cells = $(that.getColumnElements() ?? \"\");\r\n    const $container = $(that.getContent());\r\n    const isFixedPoint = (null === column || void 0 === column ? void 0 : column.fixed) && (null === nextColumn || void 0 === nextColumn ? void 0 : nextColumn.fixed);\r\n    const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);\r\n    if (isFixedPoint || isFixedEdge(point, column, nextColumn)) {\r\n        return false\r\n    }\r\n    if (isSplitPoint) {\r\n        if (isLastLeftFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {\r\n            return isLeftBoundary\r\n        }\r\n        if (isFirstRightFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {\r\n            return isRightBoundary\r\n        }\r\n    }\r\n    const isOutsideVisibleArea = offsetX < nonFixedAreaBoundingRect.left || offsetX > nonFixedAreaBoundingRect.right;\r\n    const isPointBoundary = offsetX === nonFixedAreaBoundingRect.left || offsetX === nonFixedAreaBoundingRect.right;\r\n    const isLastOrFirstPoint = rtlEnabled ? 0 === point.index : point.index === $cells.length;\r\n    return isOutsideVisibleArea || !isLastOrFirstPoint && isPointBoundary\r\n};\r\nconst noNeedToCreateReorderingPoint = (point, $cells, $container, addWidgetPrefix) => {\r\n    const {\r\n        item: item,\r\n        isLeftBoundary: isLeftBoundary,\r\n        isRightBoundary: isRightBoundary\r\n    } = point;\r\n    const $item = $(item);\r\n    const pointX = Math.round(point.x);\r\n    const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);\r\n    const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);\r\n    if (isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {\r\n        return isSplitPoint && !isLeftBoundary\r\n    }\r\n    if (isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {\r\n        return isSplitPoint && !isRightBoundary\r\n    }\r\n    return pointX < nonFixedAreaBoundingRect.left || pointX > nonFixedAreaBoundingRect.right\r\n};\r\nconst doesGroupCellEndInFirstColumn = $groupCell => {\r\n    const $groupRow = $groupCell.parent();\r\n    const commandColumns = $groupRow.children().filter((i => i < $groupCell.index()));\r\n    const groupColSpanWithoutCommand = $groupCell.attr(\"colspan\") - commandColumns.length;\r\n    return 1 === groupColSpanWithoutCommand\r\n};\r\nconst getScrollPadding = ($cells, $container, addWidgetPrefix) => {\r\n    const containerRect = getBoundingRect($container.get(0));\r\n    const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);\r\n    return {\r\n        left: nonFixedAreaBoundingRect.left - containerRect.left,\r\n        right: containerRect.right - nonFixedAreaBoundingRect.right\r\n    }\r\n};\r\nconst isOutsideVisibleArea = ($element, $cells, $container, addWidgetPrefix) => {\r\n    const elementRect = getBoundingRect($element.get(0));\r\n    const elementRectLeft = Math.round(elementRect.left);\r\n    const elementRectRight = Math.round(elementRect.right);\r\n    const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);\r\n    return elementRectLeft < nonFixedAreaBoundingRect.left || elementRectRight > nonFixedAreaBoundingRect.right\r\n};\r\nconst isLastCell = $cell => {\r\n    if (!$cell.is(\"td\")) {\r\n        return false\r\n    }\r\n    const $lastCell = $cell.parent().children().last();\r\n    return $cell[0] === $lastCell[0]\r\n};\r\nconst needToSkipHeaderCell = $cell => !$cell.is(\"[tabindex]\");\r\nconst getNextHeaderCell = function($cell) {\r\n    let direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"next\";\r\n    let $nextCell = $cell;\r\n    let $nextRow = $cell.parent();\r\n    do {\r\n        $nextCell = \"next\" === direction ? $nextCell.next() : $nextCell.prev();\r\n        if (!$nextCell.length) {\r\n            $nextRow = \"next\" === direction ? $nextRow.next() : $nextRow.prev();\r\n            if ($nextRow.length) {\r\n                $nextCell = \"next\" === direction ? $nextRow.children().first() : $nextRow.children().last()\r\n            }\r\n        }\r\n    } while ($nextCell.length && needToSkipHeaderCell($nextCell));\r\n    return $nextCell\r\n};\r\nexport const GridCoreStickyColumnsDom = {\r\n    toggleFirstHeaderClass: toggleFirstHeaderClass,\r\n    toggleColumnNoBorderClass: toggleColumnNoBorderClass,\r\n    addStickyColumnClass: addStickyColumnClass,\r\n    addStickyColumnBorderLeftClass: addStickyColumnBorderLeftClass,\r\n    addStickyColumnBorderRightClass: addStickyColumnBorderRightClass,\r\n    doesGroupCellEndInFirstColumn: doesGroupCellEndInFirstColumn,\r\n    toggleStickyColumnsClass: toggleStickyColumnsClass,\r\n    getLeftFixedCells: getLeftFixedCells,\r\n    getRightFixedCells: getRightFixedCells,\r\n    getNonFixedAndStickyCells: getNonFixedAndStickyCells,\r\n    getScrollPadding: getScrollPadding,\r\n    getNextHeaderCell: getNextHeaderCell,\r\n    noNeedToCreateResizingPoint: noNeedToCreateResizingPoint,\r\n    isFixedCellPinnedToRight: isFixedCellPinnedToRight,\r\n    noNeedToCreateReorderingPoint: noNeedToCreateReorderingPoint,\r\n    isFixedCell: isFixedCell,\r\n    isStickyCell: isStickyCell,\r\n    isStickyCellPinned: isStickyCellPinned,\r\n    isOutsideVisibleArea: isOutsideVisibleArea,\r\n    isLastCell: isLastCell\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}