{"ast":null,"code":"/**\r\n * DevExtreme (esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling_core.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport positionUtils from \"../../../../common/core/animation/position\";\nimport eventsEngine from \"../../../../common/core/events/core/events_engine\";\nimport $ from \"../../../../core/renderer\";\nimport browser from \"../../../../core/utils/browser\";\nimport Callbacks from \"../../../../core/utils/callbacks\";\nimport { Deferred } from \"../../../../core/utils/deferred\";\nimport { each } from \"../../../../core/utils/iterator\";\nimport { isDefined } from \"../../../../core/utils/type\";\nimport { getWindow } from \"../../../../core/utils/window\";\nimport gridCoreUtils from \"../m_utils\";\nimport { VirtualDataLoader } from \"../virtual_data_loader/m_virtual_data_loader\";\nconst SCROLLING_MODE_INFINITE = \"infinite\";\nconst SCROLLING_MODE_VIRTUAL = \"virtual\";\nconst LEGACY_SCROLLING_MODE = \"scrolling.legacyMode\";\nconst isVirtualMode = that => \"virtual\" === that.option(\"scrolling.mode\") || that._isVirtual;\nconst isAppendMode = that => \"infinite\" === that.option(\"scrolling.mode\") && !that._isVirtual;\nfunction subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {\n  let $scrollElement;\n  const scrollableArray = [];\n  const scrollToArray = [];\n  const disposeArray = [];\n  $targetElement = $targetElement || $element;\n  function getElementOffset(scrollable) {\n    const $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;\n    const scrollableOffset = positionUtils.offset($scrollableElement);\n    if (!scrollableOffset) {\n      return $element.offset().top;\n    }\n    return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top);\n  }\n  const widgetScrollStrategy = {\n    on(scrollable, eventName, handler) {\n      scrollable.on(\"scroll\", handler);\n    },\n    off(scrollable, eventName, handler) {\n      scrollable.off(\"scroll\", handler);\n    }\n  };\n  function subscribeToScrollEvents($scrollElement) {\n    const isDocument = \"#document\" === $scrollElement.get(0).nodeName;\n    const isElement = $scrollElement.get(0).nodeType === getWindow().Node.ELEMENT_NODE;\n    let scrollable = $scrollElement.data(\"dxScrollable\");\n    let eventsStrategy = widgetScrollStrategy;\n    if (!scrollable) {\n      scrollable = isDocument && $(getWindow()) || isElement && \"auto\" === $scrollElement.css(\"overflowY\") && $scrollElement;\n      eventsStrategy = eventsEngine;\n      if (!scrollable) {\n        return;\n      }\n    }\n    const handler = function (scrollable) {\n      return function () {\n        let scrollTop = scrollable.scrollTop() - getElementOffset(scrollable);\n        scrollTop = scrollTop > 0 ? scrollTop : 0;\n        scrollChangedHandler(scrollTop);\n      };\n    }(scrollable);\n    eventsStrategy.on(scrollable, \"scroll\", handler);\n    scrollToArray.push(pos => {\n      const topOffset = getElementOffset(scrollable);\n      const scrollMethod = scrollable.scrollTo ? \"scrollTo\" : \"scrollTop\";\n      if (pos - topOffset >= 0) {\n        scrollable[scrollMethod](pos + topOffset);\n      }\n    });\n    scrollableArray.push(scrollable);\n    disposeArray.push(() => {\n      eventsStrategy.off(scrollable, \"scroll\", handler);\n    });\n  }\n  const getScrollElementParent = $element => $($element.get(0).parentNode ?? $element.get(0).host);\n  for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = getScrollElementParent($scrollElement)) {\n    subscribeToScrollEvents($scrollElement);\n  }\n  return {\n    scrollTo(pos) {\n      each(scrollToArray, (_, scrollTo) => {\n        scrollTo(pos);\n      });\n    },\n    dispose() {\n      each(disposeArray, (_, dispose) => {\n        dispose();\n      });\n    }\n  };\n}\nclass VirtualScrollController {\n  constructor(component, dataOptions, isVirtual) {\n    this._dataOptions = dataOptions;\n    this.component = component;\n    this._viewportSize = false === component.option(LEGACY_SCROLLING_MODE) ? 15 : 0;\n    this._viewportItemSize = 20;\n    this._viewportItemIndex = 0;\n    this._position = 0;\n    this._isScrollingBack = false;\n    this._contentSize = 0;\n    this._itemSizes = {};\n    this._sizeRatio = 1;\n    this._isVirtual = isVirtual;\n    this.positionChanged = Callbacks();\n    this._dataLoader = new VirtualDataLoader(this, this._dataOptions);\n  }\n  getItemSizes() {\n    return this._itemSizes;\n  }\n  option(name, value) {\n    return this.component.option.apply(this.component, arguments);\n  }\n  isVirtual() {\n    return this._isVirtual;\n  }\n  virtualItemsCount() {\n    if (isVirtualMode(this)) {\n      const dataOptions = this._dataOptions;\n      const totalItemsCount = dataOptions.totalItemsCount();\n      if (false === this.option(LEGACY_SCROLLING_MODE) && -1 !== totalItemsCount) {\n        const viewportParams = this.getViewportParams();\n        const loadedOffset = dataOptions.loadedOffset();\n        const loadedItemCount = dataOptions.loadedItemCount();\n        const skip = Math.max(viewportParams.skip, loadedOffset);\n        const take = Math.min(viewportParams.take, loadedItemCount);\n        const endItemsCount = Math.max(totalItemsCount - (skip + take), 0);\n        return {\n          begin: skip,\n          end: endItemsCount\n        };\n      }\n      return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);\n    }\n    return;\n  }\n  getScrollingTimeout() {\n    const renderAsync = this.option(\"scrolling.renderAsync\");\n    let scrollingTimeout = 0;\n    if (!isDefined(renderAsync)) {\n      scrollingTimeout = Math.min(this.option(\"scrolling.timeout\") || 0, this._dataOptions.changingDuration());\n      if (scrollingTimeout < this.option(\"scrolling.renderingThreshold\")) {\n        scrollingTimeout = this.option(\"scrolling.minTimeout\") || 0;\n      }\n    } else if (renderAsync) {\n      scrollingTimeout = this.option(\"scrolling.timeout\") ?? 0;\n    }\n    return scrollingTimeout;\n  }\n  setViewportPosition(position) {\n    const result = new Deferred();\n    const scrollingTimeout = this.getScrollingTimeout();\n    clearTimeout(this._scrollTimeoutID);\n    if (scrollingTimeout > 0) {\n      this._scrollTimeoutID = setTimeout(() => {\n        this._setViewportPositionCore(position);\n        result.resolve();\n      }, scrollingTimeout);\n    } else {\n      this._setViewportPositionCore(position);\n      result.resolve();\n    }\n    return result.promise();\n  }\n  getViewportPosition() {\n    return this._position;\n  }\n  getItemIndexByPosition(position, viewportItemIndex, height) {\n    position = position ?? this._position;\n    const defaultItemSize = this.getItemSize();\n    let offset = 0;\n    let itemOffset = 0;\n    const itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);\n    for (let i = 0; i < itemOffsetsWithSize.length && offset < position; i++) {\n      const itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);\n      let itemOffsetDiff = (position - offset) / defaultItemSize;\n      if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {\n        itemOffset += itemOffsetDiff;\n        if (this._sizeRatio < 1 && isDefined(viewportItemIndex)) {\n          itemOffset = viewportItemIndex + height / this._viewportItemSize;\n        }\n        break;\n      } else {\n        itemOffsetDiff = itemOffsetWithSize - itemOffset;\n        offset += itemOffsetDiff * defaultItemSize;\n        itemOffset += itemOffsetDiff;\n      }\n      const itemSize = this._itemSizes[itemOffsetWithSize];\n      offset += itemSize;\n      itemOffset += offset < position ? 1 : (position - offset + itemSize) / itemSize;\n    }\n    return Math.round(50 * itemOffset) / 50;\n  }\n  isScrollingBack() {\n    return this._isScrollingBack;\n  }\n  _setViewportPositionCore(position) {\n    const prevPosition = this._position || 0;\n    this._position = position;\n    if (prevPosition !== this._position) {\n      this._isScrollingBack = this._position < prevPosition;\n    }\n    const itemIndex = this.getItemIndexByPosition();\n    const result = this.setViewportItemIndex(itemIndex);\n    this.positionChanged.fire();\n    return result;\n  }\n  setContentItemSizes(sizes) {\n    const virtualItemsCount = this.virtualItemsCount();\n    this._contentSize = sizes.reduce((a, b) => a + b, 0);\n    if (virtualItemsCount) {\n      sizes.forEach((size, index) => {\n        this._itemSizes[virtualItemsCount.begin + index] = size;\n      });\n      const virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;\n      const contentHeightLimit = gridCoreUtils.getContentHeightLimit(browser);\n      if (virtualContentSize > contentHeightLimit) {\n        this._sizeRatio = contentHeightLimit / virtualContentSize;\n      } else {\n        this._sizeRatio = 1;\n      }\n    }\n  }\n  getItemSize() {\n    return this._viewportItemSize * this._sizeRatio;\n  }\n  getItemOffset(itemIndex, isEnd) {\n    const virtualItemsCount = this.virtualItemsCount();\n    let itemCount = itemIndex;\n    if (!virtualItemsCount) {\n      return 0;\n    }\n    let offset = 0;\n    const totalItemsCount = this._dataOptions.totalItemsCount();\n    Object.keys(this._itemSizes).forEach(currentItemIndex => {\n      if (!itemCount) {\n        return;\n      }\n      if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {\n        offset += this._itemSizes[currentItemIndex];\n        itemCount--;\n      }\n    });\n    return Math.floor(offset + itemCount * this._viewportItemSize * this._sizeRatio);\n  }\n  getContentOffset(type) {\n    const isEnd = \"end\" === type;\n    const virtualItemsCount = this.virtualItemsCount();\n    if (!virtualItemsCount) {\n      return 0;\n    }\n    return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd);\n  }\n  getVirtualContentSize() {\n    const virtualItemsCount = this.virtualItemsCount();\n    return virtualItemsCount ? this.getContentOffset(\"begin\") + this.getContentOffset(\"end\") + this._contentSize : 0;\n  }\n  getViewportItemIndex() {\n    return this._viewportItemIndex;\n  }\n  setViewportItemIndex(itemIndex) {\n    this._viewportItemIndex = itemIndex;\n    if (false === this.option(LEGACY_SCROLLING_MODE)) {\n      return;\n    }\n    return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);\n  }\n  viewportItemSize(size) {\n    if (void 0 !== size) {\n      this._viewportItemSize = size;\n    }\n    return this._viewportItemSize;\n  }\n  viewportSize(size) {\n    if (void 0 !== size) {\n      this._viewportSize = size;\n    }\n    return this._viewportSize;\n  }\n  viewportHeight(height, scrollTop) {\n    const position = scrollTop ?? this._position;\n    const begin = this.getItemIndexByPosition(position);\n    const end = this.getItemIndexByPosition(position + height, begin, height);\n    this.viewportSize(Math.ceil(end - begin));\n    if (!isDefined(scrollTop) && this._viewportItemIndex !== begin) {\n      this._setViewportPositionCore(position);\n    }\n  }\n  reset(isRefresh) {\n    this._dataLoader.reset();\n    if (!isRefresh) {\n      this._itemSizes = {};\n    }\n  }\n  subscribeToWindowScrollEvents($element) {\n    this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, scrollTop => {\n      if (this.viewportItemSize()) {\n        this.setViewportPosition(scrollTop);\n      }\n    });\n  }\n  dispose() {\n    clearTimeout(this._scrollTimeoutID);\n    this._windowScroll && this._windowScroll.dispose();\n    this._windowScroll = null;\n  }\n  scrollTo(pos) {\n    this._windowScroll && this._windowScroll.scrollTo(pos);\n  }\n  isVirtualMode() {\n    return isVirtualMode(this);\n  }\n  isAppendMode() {\n    return isAppendMode(this);\n  }\n  getViewportParams() {\n    const virtualMode = \"virtual\" === this.option(\"scrolling.mode\");\n    const totalItemsCount = this._dataOptions.totalItemsCount();\n    const hasKnownLastPage = this._dataOptions.hasKnownLastPage();\n    const topIndex = hasKnownLastPage && this._viewportItemIndex > totalItemsCount ? totalItemsCount : this._viewportItemIndex;\n    const bottomIndex = this._viewportSize + topIndex;\n    const maxGap = this.option(\"scrolling.prerenderedRowChunkSize\") || 1;\n    const isScrollingBack = this.isScrollingBack();\n    const minGap = this.option(\"scrolling.prerenderedRowCount\") ?? 1;\n    const topMinGap = isScrollingBack ? minGap : 0;\n    const bottomMinGap = isScrollingBack ? 0 : minGap;\n    const skip = Math.floor(Math.max(0, topIndex - topMinGap) / maxGap) * maxGap;\n    let take = Math.ceil((bottomIndex + bottomMinGap - skip) / maxGap) * maxGap;\n    if (virtualMode) {\n      const remainedItems = Math.max(0, totalItemsCount - skip);\n      take = Math.min(take, remainedItems);\n    }\n    return {\n      skip: skip,\n      take: take\n    };\n  }\n  itemsCount() {\n    let result = 0;\n    if (this.option(LEGACY_SCROLLING_MODE)) {\n      result = this._dataLoader.itemsCount.apply(this._dataLoader, arguments);\n    } else {\n      result = this._dataOptions.itemsCount();\n    }\n    return result;\n  }\n  pageIndex() {\n    return this._dataLoader.pageIndex(...arguments);\n  }\n  beginPageIndex() {\n    return this._dataLoader.beginPageIndex(...arguments);\n  }\n  endPageIndex() {\n    return this._dataLoader.endPageIndex(...arguments);\n  }\n  pageSize() {\n    return this._dataLoader.pageSize(...arguments);\n  }\n  load() {\n    return this._dataLoader.load(...arguments);\n  }\n  loadIfNeed() {\n    return this._dataLoader.loadIfNeed(...arguments);\n  }\n  handleDataChanged() {\n    return this._dataLoader.handleDataChanged(...arguments);\n  }\n  getDelayDeferred() {\n    return this._dataLoader.getDelayDeferred();\n  }\n}\nexport default {\n  VirtualScrollController: VirtualScrollController\n};\nexport { subscribeToExternalScrollers, VirtualScrollController };","map":{"version":3,"names":["positionUtils","eventsEngine","$","browser","Callbacks","Deferred","each","isDefined","getWindow","gridCoreUtils","VirtualDataLoader","SCROLLING_MODE_INFINITE","SCROLLING_MODE_VIRTUAL","LEGACY_SCROLLING_MODE","isVirtualMode","that","option","_isVirtual","isAppendMode","subscribeToExternalScrollers","$element","scrollChangedHandler","$targetElement","$scrollElement","scrollableArray","scrollToArray","disposeArray","getElementOffset","scrollable","$scrollableElement","element","scrollableOffset","offset","top","scrollTop","widgetScrollStrategy","on","eventName","handler","off","subscribeToScrollEvents","isDocument","get","nodeName","isElement","nodeType","Node","ELEMENT_NODE","data","eventsStrategy","css","push","pos","topOffset","scrollMethod","scrollTo","getScrollElementParent","parentNode","host","parent","length","_","dispose","VirtualScrollController","constructor","component","dataOptions","isVirtual","_dataOptions","_viewportSize","_viewportItemSize","_viewportItemIndex","_position","_isScrollingBack","_contentSize","_itemSizes","_sizeRatio","positionChanged","_dataLoader","getItemSizes","name","value","apply","arguments","virtualItemsCount","totalItemsCount","viewportParams","getViewportParams","loadedOffset","loadedItemCount","skip","Math","max","take","min","endItemsCount","begin","end","getScrollingTimeout","renderAsync","scrollingTimeout","changingDuration","setViewportPosition","position","result","clearTimeout","_scrollTimeoutID","setTimeout","_setViewportPositionCore","resolve","promise","getViewportPosition","getItemIndexByPosition","viewportItemIndex","height","defaultItemSize","getItemSize","itemOffset","itemOffsetsWithSize","Object","keys","concat","i","itemOffsetWithSize","parseInt","itemOffsetDiff","itemSize","round","isScrollingBack","prevPosition","itemIndex","setViewportItemIndex","fire","setContentItemSizes","sizes","reduce","a","b","forEach","size","index","virtualContentSize","itemsCount","contentHeightLimit","getContentHeightLimit","getItemOffset","isEnd","itemCount","currentItemIndex","floor","getContentOffset","type","getVirtualContentSize","getViewportItemIndex","viewportItemIndexChanged","viewportItemSize","viewportSize","viewportHeight","ceil","reset","isRefresh","subscribeToWindowScrollEvents","_windowScroll","virtualMode","hasKnownLastPage","topIndex","bottomIndex","maxGap","minGap","topMinGap","bottomMinGap","remainedItems","pageIndex","beginPageIndex","endPageIndex","pageSize","load","loadIfNeed","handleDataChanged","getDelayDeferred"],"sources":["C:/Users/Sofia/Desktop/Репозиторий ЦК/internship_project/client/node_modules/devextreme/esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling_core.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling_core.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport positionUtils from \"../../../../common/core/animation/position\";\r\nimport eventsEngine from \"../../../../common/core/events/core/events_engine\";\r\nimport $ from \"../../../../core/renderer\";\r\nimport browser from \"../../../../core/utils/browser\";\r\nimport Callbacks from \"../../../../core/utils/callbacks\";\r\nimport {\r\n    Deferred\r\n} from \"../../../../core/utils/deferred\";\r\nimport {\r\n    each\r\n} from \"../../../../core/utils/iterator\";\r\nimport {\r\n    isDefined\r\n} from \"../../../../core/utils/type\";\r\nimport {\r\n    getWindow\r\n} from \"../../../../core/utils/window\";\r\nimport gridCoreUtils from \"../m_utils\";\r\nimport {\r\n    VirtualDataLoader\r\n} from \"../virtual_data_loader/m_virtual_data_loader\";\r\nconst SCROLLING_MODE_INFINITE = \"infinite\";\r\nconst SCROLLING_MODE_VIRTUAL = \"virtual\";\r\nconst LEGACY_SCROLLING_MODE = \"scrolling.legacyMode\";\r\nconst isVirtualMode = that => \"virtual\" === that.option(\"scrolling.mode\") || that._isVirtual;\r\nconst isAppendMode = that => \"infinite\" === that.option(\"scrolling.mode\") && !that._isVirtual;\r\n\r\nfunction subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {\r\n    let $scrollElement;\r\n    const scrollableArray = [];\r\n    const scrollToArray = [];\r\n    const disposeArray = [];\r\n    $targetElement = $targetElement || $element;\r\n\r\n    function getElementOffset(scrollable) {\r\n        const $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;\r\n        const scrollableOffset = positionUtils.offset($scrollableElement);\r\n        if (!scrollableOffset) {\r\n            return $element.offset().top\r\n        }\r\n        return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top)\r\n    }\r\n    const widgetScrollStrategy = {\r\n        on(scrollable, eventName, handler) {\r\n            scrollable.on(\"scroll\", handler)\r\n        },\r\n        off(scrollable, eventName, handler) {\r\n            scrollable.off(\"scroll\", handler)\r\n        }\r\n    };\r\n\r\n    function subscribeToScrollEvents($scrollElement) {\r\n        const isDocument = \"#document\" === $scrollElement.get(0).nodeName;\r\n        const isElement = $scrollElement.get(0).nodeType === getWindow().Node.ELEMENT_NODE;\r\n        let scrollable = $scrollElement.data(\"dxScrollable\");\r\n        let eventsStrategy = widgetScrollStrategy;\r\n        if (!scrollable) {\r\n            scrollable = isDocument && $(getWindow()) || isElement && \"auto\" === $scrollElement.css(\"overflowY\") && $scrollElement;\r\n            eventsStrategy = eventsEngine;\r\n            if (!scrollable) {\r\n                return\r\n            }\r\n        }\r\n        const handler = function(scrollable) {\r\n            return function() {\r\n                let scrollTop = scrollable.scrollTop() - getElementOffset(scrollable);\r\n                scrollTop = scrollTop > 0 ? scrollTop : 0;\r\n                scrollChangedHandler(scrollTop)\r\n            }\r\n        }(scrollable);\r\n        eventsStrategy.on(scrollable, \"scroll\", handler);\r\n        scrollToArray.push((pos => {\r\n            const topOffset = getElementOffset(scrollable);\r\n            const scrollMethod = scrollable.scrollTo ? \"scrollTo\" : \"scrollTop\";\r\n            if (pos - topOffset >= 0) {\r\n                scrollable[scrollMethod](pos + topOffset)\r\n            }\r\n        }));\r\n        scrollableArray.push(scrollable);\r\n        disposeArray.push((() => {\r\n            eventsStrategy.off(scrollable, \"scroll\", handler)\r\n        }))\r\n    }\r\n    const getScrollElementParent = $element => $($element.get(0).parentNode ?? $element.get(0).host);\r\n    for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = getScrollElementParent($scrollElement)) {\r\n        subscribeToScrollEvents($scrollElement)\r\n    }\r\n    return {\r\n        scrollTo(pos) {\r\n            each(scrollToArray, ((_, scrollTo) => {\r\n                scrollTo(pos)\r\n            }))\r\n        },\r\n        dispose() {\r\n            each(disposeArray, ((_, dispose) => {\r\n                dispose()\r\n            }))\r\n        }\r\n    }\r\n}\r\nclass VirtualScrollController {\r\n    constructor(component, dataOptions, isVirtual) {\r\n        this._dataOptions = dataOptions;\r\n        this.component = component;\r\n        this._viewportSize = false === component.option(LEGACY_SCROLLING_MODE) ? 15 : 0;\r\n        this._viewportItemSize = 20;\r\n        this._viewportItemIndex = 0;\r\n        this._position = 0;\r\n        this._isScrollingBack = false;\r\n        this._contentSize = 0;\r\n        this._itemSizes = {};\r\n        this._sizeRatio = 1;\r\n        this._isVirtual = isVirtual;\r\n        this.positionChanged = Callbacks();\r\n        this._dataLoader = new VirtualDataLoader(this, this._dataOptions)\r\n    }\r\n    getItemSizes() {\r\n        return this._itemSizes\r\n    }\r\n    option(name, value) {\r\n        return this.component.option.apply(this.component, arguments)\r\n    }\r\n    isVirtual() {\r\n        return this._isVirtual\r\n    }\r\n    virtualItemsCount() {\r\n        if (isVirtualMode(this)) {\r\n            const dataOptions = this._dataOptions;\r\n            const totalItemsCount = dataOptions.totalItemsCount();\r\n            if (false === this.option(LEGACY_SCROLLING_MODE) && -1 !== totalItemsCount) {\r\n                const viewportParams = this.getViewportParams();\r\n                const loadedOffset = dataOptions.loadedOffset();\r\n                const loadedItemCount = dataOptions.loadedItemCount();\r\n                const skip = Math.max(viewportParams.skip, loadedOffset);\r\n                const take = Math.min(viewportParams.take, loadedItemCount);\r\n                const endItemsCount = Math.max(totalItemsCount - (skip + take), 0);\r\n                return {\r\n                    begin: skip,\r\n                    end: endItemsCount\r\n                }\r\n            }\r\n            return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments)\r\n        }\r\n        return\r\n    }\r\n    getScrollingTimeout() {\r\n        const renderAsync = this.option(\"scrolling.renderAsync\");\r\n        let scrollingTimeout = 0;\r\n        if (!isDefined(renderAsync)) {\r\n            scrollingTimeout = Math.min(this.option(\"scrolling.timeout\") || 0, this._dataOptions.changingDuration());\r\n            if (scrollingTimeout < this.option(\"scrolling.renderingThreshold\")) {\r\n                scrollingTimeout = this.option(\"scrolling.minTimeout\") || 0\r\n            }\r\n        } else if (renderAsync) {\r\n            scrollingTimeout = this.option(\"scrolling.timeout\") ?? 0\r\n        }\r\n        return scrollingTimeout\r\n    }\r\n    setViewportPosition(position) {\r\n        const result = new Deferred;\r\n        const scrollingTimeout = this.getScrollingTimeout();\r\n        clearTimeout(this._scrollTimeoutID);\r\n        if (scrollingTimeout > 0) {\r\n            this._scrollTimeoutID = setTimeout((() => {\r\n                this._setViewportPositionCore(position);\r\n                result.resolve()\r\n            }), scrollingTimeout)\r\n        } else {\r\n            this._setViewportPositionCore(position);\r\n            result.resolve()\r\n        }\r\n        return result.promise()\r\n    }\r\n    getViewportPosition() {\r\n        return this._position\r\n    }\r\n    getItemIndexByPosition(position, viewportItemIndex, height) {\r\n        position = position ?? this._position;\r\n        const defaultItemSize = this.getItemSize();\r\n        let offset = 0;\r\n        let itemOffset = 0;\r\n        const itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);\r\n        for (let i = 0; i < itemOffsetsWithSize.length && offset < position; i++) {\r\n            const itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);\r\n            let itemOffsetDiff = (position - offset) / defaultItemSize;\r\n            if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {\r\n                itemOffset += itemOffsetDiff;\r\n                if (this._sizeRatio < 1 && isDefined(viewportItemIndex)) {\r\n                    itemOffset = viewportItemIndex + height / this._viewportItemSize\r\n                }\r\n                break\r\n            } else {\r\n                itemOffsetDiff = itemOffsetWithSize - itemOffset;\r\n                offset += itemOffsetDiff * defaultItemSize;\r\n                itemOffset += itemOffsetDiff\r\n            }\r\n            const itemSize = this._itemSizes[itemOffsetWithSize];\r\n            offset += itemSize;\r\n            itemOffset += offset < position ? 1 : (position - offset + itemSize) / itemSize\r\n        }\r\n        return Math.round(50 * itemOffset) / 50\r\n    }\r\n    isScrollingBack() {\r\n        return this._isScrollingBack\r\n    }\r\n    _setViewportPositionCore(position) {\r\n        const prevPosition = this._position || 0;\r\n        this._position = position;\r\n        if (prevPosition !== this._position) {\r\n            this._isScrollingBack = this._position < prevPosition\r\n        }\r\n        const itemIndex = this.getItemIndexByPosition();\r\n        const result = this.setViewportItemIndex(itemIndex);\r\n        this.positionChanged.fire();\r\n        return result\r\n    }\r\n    setContentItemSizes(sizes) {\r\n        const virtualItemsCount = this.virtualItemsCount();\r\n        this._contentSize = sizes.reduce(((a, b) => a + b), 0);\r\n        if (virtualItemsCount) {\r\n            sizes.forEach(((size, index) => {\r\n                this._itemSizes[virtualItemsCount.begin + index] = size\r\n            }));\r\n            const virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;\r\n            const contentHeightLimit = gridCoreUtils.getContentHeightLimit(browser);\r\n            if (virtualContentSize > contentHeightLimit) {\r\n                this._sizeRatio = contentHeightLimit / virtualContentSize\r\n            } else {\r\n                this._sizeRatio = 1\r\n            }\r\n        }\r\n    }\r\n    getItemSize() {\r\n        return this._viewportItemSize * this._sizeRatio\r\n    }\r\n    getItemOffset(itemIndex, isEnd) {\r\n        const virtualItemsCount = this.virtualItemsCount();\r\n        let itemCount = itemIndex;\r\n        if (!virtualItemsCount) {\r\n            return 0\r\n        }\r\n        let offset = 0;\r\n        const totalItemsCount = this._dataOptions.totalItemsCount();\r\n        Object.keys(this._itemSizes).forEach((currentItemIndex => {\r\n            if (!itemCount) {\r\n                return\r\n            }\r\n            if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {\r\n                offset += this._itemSizes[currentItemIndex];\r\n                itemCount--\r\n            }\r\n        }));\r\n        return Math.floor(offset + itemCount * this._viewportItemSize * this._sizeRatio)\r\n    }\r\n    getContentOffset(type) {\r\n        const isEnd = \"end\" === type;\r\n        const virtualItemsCount = this.virtualItemsCount();\r\n        if (!virtualItemsCount) {\r\n            return 0\r\n        }\r\n        return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd)\r\n    }\r\n    getVirtualContentSize() {\r\n        const virtualItemsCount = this.virtualItemsCount();\r\n        return virtualItemsCount ? this.getContentOffset(\"begin\") + this.getContentOffset(\"end\") + this._contentSize : 0\r\n    }\r\n    getViewportItemIndex() {\r\n        return this._viewportItemIndex\r\n    }\r\n    setViewportItemIndex(itemIndex) {\r\n        this._viewportItemIndex = itemIndex;\r\n        if (false === this.option(LEGACY_SCROLLING_MODE)) {\r\n            return\r\n        }\r\n        return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments)\r\n    }\r\n    viewportItemSize(size) {\r\n        if (void 0 !== size) {\r\n            this._viewportItemSize = size\r\n        }\r\n        return this._viewportItemSize\r\n    }\r\n    viewportSize(size) {\r\n        if (void 0 !== size) {\r\n            this._viewportSize = size\r\n        }\r\n        return this._viewportSize\r\n    }\r\n    viewportHeight(height, scrollTop) {\r\n        const position = scrollTop ?? this._position;\r\n        const begin = this.getItemIndexByPosition(position);\r\n        const end = this.getItemIndexByPosition(position + height, begin, height);\r\n        this.viewportSize(Math.ceil(end - begin));\r\n        if (!isDefined(scrollTop) && this._viewportItemIndex !== begin) {\r\n            this._setViewportPositionCore(position)\r\n        }\r\n    }\r\n    reset(isRefresh) {\r\n        this._dataLoader.reset();\r\n        if (!isRefresh) {\r\n            this._itemSizes = {}\r\n        }\r\n    }\r\n    subscribeToWindowScrollEvents($element) {\r\n        this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, (scrollTop => {\r\n            if (this.viewportItemSize()) {\r\n                this.setViewportPosition(scrollTop)\r\n            }\r\n        }))\r\n    }\r\n    dispose() {\r\n        clearTimeout(this._scrollTimeoutID);\r\n        this._windowScroll && this._windowScroll.dispose();\r\n        this._windowScroll = null\r\n    }\r\n    scrollTo(pos) {\r\n        this._windowScroll && this._windowScroll.scrollTo(pos)\r\n    }\r\n    isVirtualMode() {\r\n        return isVirtualMode(this)\r\n    }\r\n    isAppendMode() {\r\n        return isAppendMode(this)\r\n    }\r\n    getViewportParams() {\r\n        const virtualMode = \"virtual\" === this.option(\"scrolling.mode\");\r\n        const totalItemsCount = this._dataOptions.totalItemsCount();\r\n        const hasKnownLastPage = this._dataOptions.hasKnownLastPage();\r\n        const topIndex = hasKnownLastPage && this._viewportItemIndex > totalItemsCount ? totalItemsCount : this._viewportItemIndex;\r\n        const bottomIndex = this._viewportSize + topIndex;\r\n        const maxGap = this.option(\"scrolling.prerenderedRowChunkSize\") || 1;\r\n        const isScrollingBack = this.isScrollingBack();\r\n        const minGap = this.option(\"scrolling.prerenderedRowCount\") ?? 1;\r\n        const topMinGap = isScrollingBack ? minGap : 0;\r\n        const bottomMinGap = isScrollingBack ? 0 : minGap;\r\n        const skip = Math.floor(Math.max(0, topIndex - topMinGap) / maxGap) * maxGap;\r\n        let take = Math.ceil((bottomIndex + bottomMinGap - skip) / maxGap) * maxGap;\r\n        if (virtualMode) {\r\n            const remainedItems = Math.max(0, totalItemsCount - skip);\r\n            take = Math.min(take, remainedItems)\r\n        }\r\n        return {\r\n            skip: skip,\r\n            take: take\r\n        }\r\n    }\r\n    itemsCount() {\r\n        let result = 0;\r\n        if (this.option(LEGACY_SCROLLING_MODE)) {\r\n            result = this._dataLoader.itemsCount.apply(this._dataLoader, arguments)\r\n        } else {\r\n            result = this._dataOptions.itemsCount()\r\n        }\r\n        return result\r\n    }\r\n    pageIndex() {\r\n        return this._dataLoader.pageIndex(...arguments)\r\n    }\r\n    beginPageIndex() {\r\n        return this._dataLoader.beginPageIndex(...arguments)\r\n    }\r\n    endPageIndex() {\r\n        return this._dataLoader.endPageIndex(...arguments)\r\n    }\r\n    pageSize() {\r\n        return this._dataLoader.pageSize(...arguments)\r\n    }\r\n    load() {\r\n        return this._dataLoader.load(...arguments)\r\n    }\r\n    loadIfNeed() {\r\n        return this._dataLoader.loadIfNeed(...arguments)\r\n    }\r\n    handleDataChanged() {\r\n        return this._dataLoader.handleDataChanged(...arguments)\r\n    }\r\n    getDelayDeferred() {\r\n        return this._dataLoader.getDelayDeferred()\r\n    }\r\n}\r\nexport default {\r\n    VirtualScrollController: VirtualScrollController\r\n};\r\nexport {\r\n    subscribeToExternalScrollers,\r\n    VirtualScrollController\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}